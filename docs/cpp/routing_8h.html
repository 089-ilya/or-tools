<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>OR-Tools</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">OR-Tools 7.1@</span>
            </div>
        </div>
        <div id="content">
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_a7cc1eeded8f693d0da6c729bc88c45a.html">ortools</a></li><li class="navelem"><a class="el" href="dir_afbb39f66221aac28bbdefd1dca2b2b0.html">constraint_solver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">routing.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;queue&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;absl/container/flat_hash_map.h&quot;</code><br />
<code>#include &quot;absl/container/flat_hash_set.h&quot;</code><br />
<code>#include &quot;absl/hash/hash.h&quot;</code><br />
<code>#include &quot;absl/time/time.h&quot;</code><br />
<code>#include &quot;ortools/base/adjustable_priority_queue-inl.h&quot;</code><br />
<code>#include &quot;ortools/base/commandlineflags.h&quot;</code><br />
<code>#include &quot;ortools/base/hash.h&quot;</code><br />
<code>#include &quot;ortools/base/int_type_indexed_vector.h&quot;</code><br />
<code>#include &quot;<a class="el" href="constraint__solver_8h_source.html">ortools/constraint_solver/constraint_solver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="constraint__solveri_8h_source.html">ortools/constraint_solver/constraint_solveri.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="routing__index__manager_8h_source.html">ortools/constraint_solver/routing_index_manager.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="routing__parameters_8pb_8h_source.html">ortools/constraint_solver/routing_parameters.pb.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="routing__types_8h_source.html">ortools/constraint_solver/routing_types.h</a>&quot;</code><br />
<code>#include &quot;ortools/glop/lp_solver.h&quot;</code><br />
<code>#include &quot;<a class="el" href="graph_8h_source.html">ortools/graph/graph.h</a>&quot;</code><br />
<code>#include &quot;ortools/sat/theta_tree.h&quot;</code><br />
<code>#include &quot;ortools/util/range_query_function.h&quot;</code><br />
<code>#include &quot;<a class="el" href="sorted__interval__list_8h_source.html">ortools/util/sorted_interval_list.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="routing_8h__dep__incl.png" border="0" usemap="#routing_8hdep" alt=""/></div>
<map name="routing_8hdep" id="routing_8hdep">
<area shape="rect"  title=" " alt="" coords="50,5,123,31"/>
<area shape="rect"  href="routing__lp__scheduling_8h.html" title=" " alt="" coords="5,79,168,104"/>
</map>
</div>
</div>
<p><a href="routing_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDisjunctivePropagator_1_1Tasks.html">DisjunctivePropagator::Tasks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to hold tasks described by their features.  <a href="structDisjunctivePropagator_1_1Tasks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeRegulationsChecker_1_1NodeCount.html">TypeRegulationsChecker::NodeCount</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimpleBoundCosts_1_1BoundCost.html">SimpleBoundCosts::BoundCost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRoutingDimension_1_1NodePrecedence.html">RoutingDimension::NodePrecedence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCheapestInsertionFilteredDecisionBuilder_1_1StartEndValue.html">CheapestInsertionFilteredDecisionBuilder::StartEndValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSavingsFilteredDecisionBuilder_1_1SavingsParameters.html">SavingsFilteredDecisionBuilder::SavingsParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSavingsFilteredDecisionBuilder_1_1SavingsContainer.html">SavingsFilteredDecisionBuilder::SavingsContainer&lt; S &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSavingsFilteredDecisionBuilder_1_1VehicleClassEntry.html">SavingsFilteredDecisionBuilder::VehicleClassEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af52b05a44d013985efe92bec167e0bd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#af52b05a44d013985efe92bec167e0bd7">OR_TOOLS_CONSTRAINT_SOLVER_ROUTING_H_</a></td></tr>
<tr class="separator:af52b05a44d013985efe92bec167e0bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0e106a97f0156868f1d1c741b283793e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a0e106a97f0156868f1d1c741b283793e">GetTabuVarsCallback</a> = std::function&lt; std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">operations_research::IntVar</a> * &gt;(RoutingModel *)&gt;</td></tr>
<tr class="memdesc:a0e106a97f0156868f1d1c741b283793e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback returning the variable to use for the Tabu Search metaheuristic.  <a href="#a0e106a97f0156868f1d1c741b283793e">More...</a><br /></td></tr>
<tr class="separator:a0e106a97f0156868f1d1c741b283793e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a874eb2862dd884ad47e30746e03627f5"><td class="memItemLeft" align="right" valign="top">routing_no_lns(default:false) int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a874eb2862dd884ad47e30746e03627f5">GetVisitType</a> (int64 index) const</td></tr>
<tr class="memdesc:a874eb2862dd884ad47e30746e03627f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  <a href="#a874eb2862dd884ad47e30746e03627f5">More...</a><br /></td></tr>
<tr class="separator:a874eb2862dd884ad47e30746e03627f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822458cc9a9a6fa02e86af3e3a1e5c89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a822458cc9a9a6fa02e86af3e3a1e5c89">CloseVisitTypes</a> ()</td></tr>
<tr class="memdesc:a822458cc9a9a6fa02e86af3e3a1e5c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called once all node visit types have been set and prior to adding any incompatibilities/requirements.  <a href="#a822458cc9a9a6fa02e86af3e3a1e5c89">More...</a><br /></td></tr>
<tr class="separator:a822458cc9a9a6fa02e86af3e3a1e5c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24478803a7138d68852093b9c2743892"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a24478803a7138d68852093b9c2743892">GetNumberOfVisitTypes</a> () const</td></tr>
<tr class="separator:a24478803a7138d68852093b9c2743892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796b4eed03ed53bbbaed642f4ae94952"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a796b4eed03ed53bbbaed642f4ae94952">AddHardTypeIncompatibility</a> (int type1, int type2)</td></tr>
<tr class="memdesc:a796b4eed03ed53bbbaed642f4ae94952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incompatibilities: Two nodes with "hard" incompatible types cannot share the same route at all, while with a "temporal" incompatibility they can't be on the same route at the same time.  <a href="#a796b4eed03ed53bbbaed642f4ae94952">More...</a><br /></td></tr>
<tr class="separator:a796b4eed03ed53bbbaed642f4ae94952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7086a908f1890a7e1550c97b774e6384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a7086a908f1890a7e1550c97b774e6384">AddTemporalTypeIncompatibility</a> (int type1, int type2)</td></tr>
<tr class="separator:a7086a908f1890a7e1550c97b774e6384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fb0661acf38ed1442819e2cc452311"><td class="memItemLeft" align="right" valign="top">const absl::flat_hash_set&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a51fb0661acf38ed1442819e2cc452311">GetHardTypeIncompatibilitiesOfType</a> (int type) const</td></tr>
<tr class="memdesc:a51fb0661acf38ed1442819e2cc452311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns visit types incompatible with a given type.  <a href="#a51fb0661acf38ed1442819e2cc452311">More...</a><br /></td></tr>
<tr class="separator:a51fb0661acf38ed1442819e2cc452311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8ead500db4128d0d27f8066d1f8208"><td class="memItemLeft" align="right" valign="top">const absl::flat_hash_set&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a9d8ead500db4128d0d27f8066d1f8208">GetTemporalTypeIncompatibilitiesOfType</a> (int type) const</td></tr>
<tr class="separator:a9d8ead500db4128d0d27f8066d1f8208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c58894df747f5498c335a3a8c5c0c88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a9c58894df747f5498c335a3a8c5c0c88">HasHardTypeIncompatibilities</a> () const</td></tr>
<tr class="memdesc:a9c58894df747f5498c335a3a8c5c0c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff any hard (resp.  <a href="#a9c58894df747f5498c335a3a8c5c0c88">More...</a><br /></td></tr>
<tr class="separator:a9c58894df747f5498c335a3a8c5c0c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19492313b68e5a963af3793aaec8d90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ad19492313b68e5a963af3793aaec8d90">HasTemporalTypeIncompatibilities</a> () const</td></tr>
<tr class="separator:ad19492313b68e5a963af3793aaec8d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22e9cfd1fbf1b4af4f8a9be46ec88a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ac22e9cfd1fbf1b4af4f8a9be46ec88a1">AddSameVehicleRequiredTypeAlternatives</a> (int dependent_type, absl::flat_hash_set&lt; int &gt; required_type_alternatives)</td></tr>
<tr class="memdesc:ac22e9cfd1fbf1b4af4f8a9be46ec88a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requirements:  <a href="#ac22e9cfd1fbf1b4af4f8a9be46ec88a1">More...</a><br /></td></tr>
<tr class="separator:ac22e9cfd1fbf1b4af4f8a9be46ec88a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ee209f167d3974329301d784010b63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a92ee209f167d3974329301d784010b63">AddTemporalRequiredTypeAlternatives</a> (int dependent_type, absl::flat_hash_set&lt; int &gt; required_type_alternatives)</td></tr>
<tr class="memdesc:a92ee209f167d3974329301d784010b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">If type_D temporally depends on type_R, any non-delivery node_D of type_D requires at least one non-delivered node of type_R on its vehicle at the time node_D is visited.  <a href="#a92ee209f167d3974329301d784010b63">More...</a><br /></td></tr>
<tr class="separator:a92ee209f167d3974329301d784010b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae350d70cb713a6772283e3753f4f2f7a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ae350d70cb713a6772283e3753f4f2f7a">GetSameVehicleRequiredTypeAlternativesOfType</a> (int type) const</td></tr>
<tr class="memdesc:ae350d70cb713a6772283e3753f4f2f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">clang-format off Returns the sets of same-vehicle/temporal requirement alternatives for the given type.  <a href="#ae350d70cb713a6772283e3753f4f2f7a">More...</a><br /></td></tr>
<tr class="separator:ae350d70cb713a6772283e3753f4f2f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1652af55e9d83490d9c59d35d991ce9"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ab1652af55e9d83490d9c59d35d991ce9">GetTemporalRequiredTypeAlternativesOfType</a> (int type) const</td></tr>
<tr class="separator:ab1652af55e9d83490d9c59d35d991ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc101a64a3c876dcdf1b7176d59bd2c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#abc101a64a3c876dcdf1b7176d59bd2c9">HasSameVehicleTypeRequirements</a> () const</td></tr>
<tr class="memdesc:abc101a64a3c876dcdf1b7176d59bd2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">clang-format on Returns true iff any same-route (resp.  <a href="#abc101a64a3c876dcdf1b7176d59bd2c9">More...</a><br /></td></tr>
<tr class="separator:abc101a64a3c876dcdf1b7176d59bd2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3f4c6871f7b2c67fd5b1ad6c94d891"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a5e3f4c6871f7b2c67fd5b1ad6c94d891">HasTemporalTypeRequirements</a> () const</td></tr>
<tr class="separator:a5e3f4c6871f7b2c67fd5b1ad6c94d891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab313d84a56c5e9b1b8f28da70b8d4045"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ab313d84a56c5e9b1b8f28da70b8d4045">HasTypeRegulations</a> () const</td></tr>
<tr class="memdesc:ab313d84a56c5e9b1b8f28da70b8d4045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the model has any incompatibilities or requirements set on node types.  <a href="#ab313d84a56c5e9b1b8f28da70b8d4045">More...</a><br /></td></tr>
<tr class="separator:ab313d84a56c5e9b1b8f28da70b8d4045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3600327c657a0c83430d7bd9566e9ab6"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a3600327c657a0c83430d7bd9566e9ab6">UnperformedPenalty</a> (int64 var_index) const</td></tr>
<tr class="memdesc:a3600327c657a0c83430d7bd9566e9ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "unperformed" penalty of a node.  <a href="#a3600327c657a0c83430d7bd9566e9ab6">More...</a><br /></td></tr>
<tr class="separator:a3600327c657a0c83430d7bd9566e9ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8364b53d49a5b46e994d41124c4ffd6"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ae8364b53d49a5b46e994d41124c4ffd6">UnperformedPenaltyOrValue</a> (int64 default_value, int64 var_index) const</td></tr>
<tr class="memdesc:ae8364b53d49a5b46e994d41124c4ffd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above except that it returns default_value instead of 0 when penalty is not well defined (default value is passed as first argument to simplify the usage of the method in a callback).  <a href="#ae8364b53d49a5b46e994d41124c4ffd6">More...</a><br /></td></tr>
<tr class="separator:ae8364b53d49a5b46e994d41124c4ffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca75b5d3bfe2433c5805b049815f533"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#acca75b5d3bfe2433c5805b049815f533">GetDepot</a> () const</td></tr>
<tr class="memdesc:acca75b5d3bfe2433c5805b049815f533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variable index of the first starting or ending node of all routes.  <a href="#acca75b5d3bfe2433c5805b049815f533">More...</a><br /></td></tr>
<tr class="separator:acca75b5d3bfe2433c5805b049815f533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d61705aa4291d2cd437ba0a7dfccbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ab8d61705aa4291d2cd437ba0a7dfccbf">SetArcCostEvaluatorOfAllVehicles</a> (int evaluator_index)</td></tr>
<tr class="memdesc:ab8d61705aa4291d2cd437ba0a7dfccbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the cost function of the model such that the cost of a segment of a route between node 'from' and 'to' is evaluator(from, to), whatever the route or vehicle performing the route.  <a href="#ab8d61705aa4291d2cd437ba0a7dfccbf">More...</a><br /></td></tr>
<tr class="separator:ab8d61705aa4291d2cd437ba0a7dfccbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75d9f49c157b7784fc8baa7d623ee35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ae75d9f49c157b7784fc8baa7d623ee35">SetArcCostEvaluatorOfVehicle</a> (int evaluator_index, int vehicle)</td></tr>
<tr class="memdesc:ae75d9f49c157b7784fc8baa7d623ee35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the cost function for a given vehicle route.  <a href="#ae75d9f49c157b7784fc8baa7d623ee35">More...</a><br /></td></tr>
<tr class="separator:ae75d9f49c157b7784fc8baa7d623ee35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b796e9f91ee5b4c5e99c7f23e2f743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a07b796e9f91ee5b4c5e99c7f23e2f743">SetFixedCostOfAllVehicles</a> (int64 cost)</td></tr>
<tr class="memdesc:a07b796e9f91ee5b4c5e99c7f23e2f743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fixed cost of all vehicle routes.  <a href="#a07b796e9f91ee5b4c5e99c7f23e2f743">More...</a><br /></td></tr>
<tr class="separator:a07b796e9f91ee5b4c5e99c7f23e2f743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8f5b5f090cf084347eda6eb803813a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a4e8f5b5f090cf084347eda6eb803813a">SetFixedCostOfVehicle</a> (int64 cost, int vehicle)</td></tr>
<tr class="memdesc:a4e8f5b5f090cf084347eda6eb803813a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fixed cost of one vehicle route.  <a href="#a4e8f5b5f090cf084347eda6eb803813a">More...</a><br /></td></tr>
<tr class="separator:a4e8f5b5f090cf084347eda6eb803813a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bab641f5b9bf8de266adad29558b4c2"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a4bab641f5b9bf8de266adad29558b4c2">GetFixedCostOfVehicle</a> (int vehicle) const</td></tr>
<tr class="memdesc:a4bab641f5b9bf8de266adad29558b4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the route fixed cost taken into account if the route of the vehicle is not empty, aka there's at least one node on the route other than the first and last nodes.  <a href="#a4bab641f5b9bf8de266adad29558b4c2">More...</a><br /></td></tr>
<tr class="separator:a4bab641f5b9bf8de266adad29558b4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d92ac74ce8d3e57551677e88e2c846"><td class="memItemLeft" align="right" valign="top">quadratic_cost_factor_of_vehicle_ *[v] square of length of route v void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aa3d92ac74ce8d3e57551677e88e2c846">SetAmortizedCostFactorsOfAllVehicles</a> (int64 linear_cost_factor, int64 quadratic_cost_factor)</td></tr>
<tr class="memdesc:aa3d92ac74ce8d3e57551677e88e2c846"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following methods set the linear and quadratic cost factors of vehicles (must be positive values).  <a href="#aa3d92ac74ce8d3e57551677e88e2c846">More...</a><br /></td></tr>
<tr class="separator:aa3d92ac74ce8d3e57551677e88e2c846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1acdfe3dcf892d108d2a2ecab94e936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ae1acdfe3dcf892d108d2a2ecab94e936">SetAmortizedCostFactorsOfVehicle</a> (int64 linear_cost_factor, int64 quadratic_cost_factor, int vehicle)</td></tr>
<tr class="memdesc:ae1acdfe3dcf892d108d2a2ecab94e936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the linear and quadratic cost factor of the given vehicle.  <a href="#ae1acdfe3dcf892d108d2a2ecab94e936">More...</a><br /></td></tr>
<tr class="separator:ae1acdfe3dcf892d108d2a2ecab94e936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01519be299cb5ddef36111ee6f8a5cc"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int64 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aa01519be299cb5ddef36111ee6f8a5cc">GetAmortizedLinearCostFactorOfVehicles</a> () const</td></tr>
<tr class="separator:aa01519be299cb5ddef36111ee6f8a5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeaf95383c1c03da6f22c522d119775b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int64 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aaeaf95383c1c03da6f22c522d119775b">GetAmortizedQuadraticCostFactorOfVehicles</a> () const</td></tr>
<tr class="separator:aaeaf95383c1c03da6f22c522d119775b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccaa3133378da76d3fd5cdb560038ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a7ccaa3133378da76d3fd5cdb560038ae">ConsiderEmptyRouteCostsForVehicle</a> (bool consider_costs, int vehicle)</td></tr>
<tr class="separator:a7ccaa3133378da76d3fd5cdb560038ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6760664a6e4f3427832ee3b7ba0602"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aed6760664a6e4f3427832ee3b7ba0602">AreEmptyRouteCostsConsideredForVehicle</a> (int vehicle) const</td></tr>
<tr class="separator:aed6760664a6e4f3427832ee3b7ba0602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660cb5477a6d3fbf146657aa7af73968"><td class="memItemLeft" align="right" valign="top">const Solver::IndexEvaluator2 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a660cb5477a6d3fbf146657aa7af73968">first_solution_evaluator</a> () const</td></tr>
<tr class="memdesc:a660cb5477a6d3fbf146657aa7af73968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search Gets/sets the evaluator used during the search.  <a href="#a660cb5477a6d3fbf146657aa7af73968">More...</a><br /></td></tr>
<tr class="separator:a660cb5477a6d3fbf146657aa7af73968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69145472d51d341f82d3ad29e9c6be2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ab69145472d51d341f82d3ad29e9c6be2">SetFirstSolutionEvaluator</a> (Solver::IndexEvaluator2 evaluator)</td></tr>
<tr class="memdesc:ab69145472d51d341f82d3ad29e9c6be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of evaluator.  <a href="#ab69145472d51d341f82d3ad29e9c6be2">More...</a><br /></td></tr>
<tr class="separator:ab69145472d51d341f82d3ad29e9c6be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1156fa8214dba09e2a2a94862244aa1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a1156fa8214dba09e2a2a94862244aa1f">AddLocalSearchOperator</a> (LocalSearchOperator *ls_operator)</td></tr>
<tr class="memdesc:a1156fa8214dba09e2a2a94862244aa1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a local search operator to the set of operators used to solve the vehicle routing problem.  <a href="#a1156fa8214dba09e2a2a94862244aa1f">More...</a><br /></td></tr>
<tr class="separator:a1156fa8214dba09e2a2a94862244aa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e23be986e4c3b96a50c8798aa5f536d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a0e23be986e4c3b96a50c8798aa5f536d">AddSearchMonitor</a> (SearchMonitor *const monitor)</td></tr>
<tr class="memdesc:a0e23be986e4c3b96a50c8798aa5f536d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a search monitor to the search used to solve the routing model.  <a href="#a0e23be986e4c3b96a50c8798aa5f536d">More...</a><br /></td></tr>
<tr class="separator:a0e23be986e4c3b96a50c8798aa5f536d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086605d9650ce3c576d8a9c45ce0b9fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a086605d9650ce3c576d8a9c45ce0b9fc">AddAtSolutionCallback</a> (std::function&lt; void()&gt; callback)</td></tr>
<tr class="memdesc:a086605d9650ce3c576d8a9c45ce0b9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback called each time a solution is found during the search.  <a href="#a086605d9650ce3c576d8a9c45ce0b9fc">More...</a><br /></td></tr>
<tr class="separator:a086605d9650ce3c576d8a9c45ce0b9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4768ba91c34c542eddec212a68d79473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a4768ba91c34c542eddec212a68d79473">AddVariableMinimizedByFinalizer</a> (IntVar *var)</td></tr>
<tr class="memdesc:a4768ba91c34c542eddec212a68d79473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable to minimize in the solution finalizer.  <a href="#a4768ba91c34c542eddec212a68d79473">More...</a><br /></td></tr>
<tr class="separator:a4768ba91c34c542eddec212a68d79473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdcf3bd412a5a61d811ef85e115e5ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aabdcf3bd412a5a61d811ef85e115e5ff">AddVariableMaximizedByFinalizer</a> (IntVar *var)</td></tr>
<tr class="memdesc:aabdcf3bd412a5a61d811ef85e115e5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable to maximize in the solution finalizer (see above for information on the solution finalizer).  <a href="#aabdcf3bd412a5a61d811ef85e115e5ff">More...</a><br /></td></tr>
<tr class="separator:aabdcf3bd412a5a61d811ef85e115e5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add71470f4175a0859e6e3d69c2a53988"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#add71470f4175a0859e6e3d69c2a53988">CloseModel</a> ()</td></tr>
<tr class="memdesc:add71470f4175a0859e6e3d69c2a53988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the current routing model; after this method is called, no modification to the model can be done, but RoutesToAssignment becomes available.  <a href="#add71470f4175a0859e6e3d69c2a53988">More...</a><br /></td></tr>
<tr class="separator:add71470f4175a0859e6e3d69c2a53988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79f8d482de4dd0ef86a1b54999686af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aa79f8d482de4dd0ef86a1b54999686af">CloseModelWithParameters</a> (const RoutingSearchParameters &amp;search_parameters)</td></tr>
<tr class="memdesc:aa79f8d482de4dd0ef86a1b54999686af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above taking search parameters (as of 10/2015 some the parameters have to be set when closing the model).  <a href="#aa79f8d482de4dd0ef86a1b54999686af">More...</a><br /></td></tr>
<tr class="separator:aa79f8d482de4dd0ef86a1b54999686af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562e4c0a80f7f4eda9573a482af288d1"><td class="memItemLeft" align="right" valign="top">const Assignment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a562e4c0a80f7f4eda9573a482af288d1">Solve</a> (const Assignment *assignment=nullptr)</td></tr>
<tr class="memdesc:a562e4c0a80f7f4eda9573a482af288d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the current routing model; closes the current model.  <a href="#a562e4c0a80f7f4eda9573a482af288d1">More...</a><br /></td></tr>
<tr class="separator:a562e4c0a80f7f4eda9573a482af288d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e97be54c31d45d312d168ce1c8ba6f"><td class="memItemLeft" align="right" valign="top">const Assignment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#af4e97be54c31d45d312d168ce1c8ba6f">SolveWithParameters</a> (const RoutingSearchParameters &amp;search_parameters, std::vector&lt; const Assignment * &gt; *solutions=nullptr)</td></tr>
<tr class="memdesc:af4e97be54c31d45d312d168ce1c8ba6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the current routing model with the given parameters.  <a href="#af4e97be54c31d45d312d168ce1c8ba6f">More...</a><br /></td></tr>
<tr class="separator:af4e97be54c31d45d312d168ce1c8ba6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e06d63a6d3792ab5cd64e51724632b"><td class="memItemLeft" align="right" valign="top">const Assignment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a56e06d63a6d3792ab5cd64e51724632b">SolveFromAssignmentWithParameters</a> (const Assignment *assignment, const RoutingSearchParameters &amp;search_parameters, std::vector&lt; const Assignment * &gt; *solutions=nullptr)</td></tr>
<tr class="separator:a56e06d63a6d3792ab5cd64e51724632b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a2ab630f6b13644ca6853c7893f413"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ac1a2ab630f6b13644ca6853c7893f413">SetAssignmentFromOtherModelAssignment</a> (Assignment *target_assignment, const RoutingModel *source_model, const Assignment *source_assignment)</td></tr>
<tr class="memdesc:ac1a2ab630f6b13644ca6853c7893f413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a "source_model" and its "source_assignment", resets "target_assignment" with the IntVar variables (nexts_, and vehicle_vars_ if costs aren't homogeneous across vehicles) of "this" model, with the values set according to those in "other_assignment".  <a href="#ac1a2ab630f6b13644ca6853c7893f413">More...</a><br /></td></tr>
<tr class="separator:ac1a2ab630f6b13644ca6853c7893f413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b2404a26ab1e6acf562b8261eeba38"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ae9b2404a26ab1e6acf562b8261eeba38">ComputeLowerBound</a> ()</td></tr>
<tr class="memdesc:ae9b2404a26ab1e6acf562b8261eeba38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a lower bound to the routing problem solving a linear assignment problem.  <a href="#ae9b2404a26ab1e6acf562b8261eeba38">More...</a><br /></td></tr>
<tr class="separator:ae9b2404a26ab1e6acf562b8261eeba38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1490a44086db009cdb51f854a02a65"><td class="memItemLeft" align="right" valign="top">Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#adb1490a44086db009cdb51f854a02a65">status</a> () const</td></tr>
<tr class="memdesc:adb1490a44086db009cdb51f854a02a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current status of the routing model.  <a href="#adb1490a44086db009cdb51f854a02a65">More...</a><br /></td></tr>
<tr class="separator:adb1490a44086db009cdb51f854a02a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf71584ad4bffea7a489dc53787fa6f8"><td class="memItemLeft" align="right" valign="top">IntVar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aaf71584ad4bffea7a489dc53787fa6f8">ApplyLocks</a> (const std::vector&lt; int64 &gt; &amp;locks)</td></tr>
<tr class="memdesc:aaf71584ad4bffea7a489dc53787fa6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a lock chain to the next search.  <a href="#aaf71584ad4bffea7a489dc53787fa6f8">More...</a><br /></td></tr>
<tr class="separator:aaf71584ad4bffea7a489dc53787fa6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410f7da30cf944b7874eebe57eebe41a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a410f7da30cf944b7874eebe57eebe41a">ApplyLocksToAllVehicles</a> (const std::vector&lt; std::vector&lt; int64 &gt;&gt; &amp;locks, bool close_routes)</td></tr>
<tr class="memdesc:a410f7da30cf944b7874eebe57eebe41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies lock chains to all vehicles to the next search, such that locks[p] is the lock chain for route p.  <a href="#a410f7da30cf944b7874eebe57eebe41a">More...</a><br /></td></tr>
<tr class="separator:a410f7da30cf944b7874eebe57eebe41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae033bc458ffce1ecc4874f3e212896f7"><td class="memItemLeft" align="right" valign="top">const Assignment *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ae033bc458ffce1ecc4874f3e212896f7">PreAssignment</a> () const</td></tr>
<tr class="memdesc:ae033bc458ffce1ecc4874f3e212896f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an assignment used to fix some of the variables of the problem.  <a href="#ae033bc458ffce1ecc4874f3e212896f7">More...</a><br /></td></tr>
<tr class="separator:ae033bc458ffce1ecc4874f3e212896f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af1158b77552d60afc3f0473de3892d"><td class="memItemLeft" align="right" valign="top">Assignment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a3af1158b77552d60afc3f0473de3892d">MutablePreAssignment</a> ()</td></tr>
<tr class="separator:a3af1158b77552d60afc3f0473de3892d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcef421e8c8cd243157543f741d6a73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#acfcef421e8c8cd243157543f741d6a73">WriteAssignment</a> (const std::string &amp;file_name) const</td></tr>
<tr class="memdesc:acfcef421e8c8cd243157543f741d6a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the current solution to a file containing an AssignmentProto.  <a href="#acfcef421e8c8cd243157543f741d6a73">More...</a><br /></td></tr>
<tr class="separator:acfcef421e8c8cd243157543f741d6a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e3de2ce73322e1860be0713c07c33e"><td class="memItemLeft" align="right" valign="top">Assignment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a74e3de2ce73322e1860be0713c07c33e">ReadAssignment</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:a74e3de2ce73322e1860be0713c07c33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an assignment from a file and returns the current solution.  <a href="#a74e3de2ce73322e1860be0713c07c33e">More...</a><br /></td></tr>
<tr class="separator:a74e3de2ce73322e1860be0713c07c33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566ddf59563c1b37e8c178b1805aa0f4"><td class="memItemLeft" align="right" valign="top">Assignment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a566ddf59563c1b37e8c178b1805aa0f4">RestoreAssignment</a> (const Assignment &amp;solution)</td></tr>
<tr class="memdesc:a566ddf59563c1b37e8c178b1805aa0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores an assignment as a solution in the routing model and returns the new solution.  <a href="#a566ddf59563c1b37e8c178b1805aa0f4">More...</a><br /></td></tr>
<tr class="separator:a566ddf59563c1b37e8c178b1805aa0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97dca877bb5083a72c147628a8439770"><td class="memItemLeft" align="right" valign="top">Assignment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a97dca877bb5083a72c147628a8439770">ReadAssignmentFromRoutes</a> (const std::vector&lt; std::vector&lt; int64 &gt;&gt; &amp;routes, bool ignore_inactive_indices)</td></tr>
<tr class="memdesc:a97dca877bb5083a72c147628a8439770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the routes as the current solution.  <a href="#a97dca877bb5083a72c147628a8439770">More...</a><br /></td></tr>
<tr class="separator:a97dca877bb5083a72c147628a8439770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f7f1cb8b08b7ec1d477a14447bd8d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a78f7f1cb8b08b7ec1d477a14447bd8d4">RoutesToAssignment</a> (const std::vector&lt; std::vector&lt; int64 &gt;&gt; &amp;routes, bool ignore_inactive_indices, bool close_routes, Assignment *const assignment) const</td></tr>
<tr class="memdesc:a78f7f1cb8b08b7ec1d477a14447bd8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an assignment from a specification of the routes of the vehicles.  <a href="#a78f7f1cb8b08b7ec1d477a14447bd8d4">More...</a><br /></td></tr>
<tr class="separator:a78f7f1cb8b08b7ec1d477a14447bd8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d152b7049084186342b719eee6fa15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a97d152b7049084186342b719eee6fa15">AssignmentToRoutes</a> (const Assignment &amp;assignment, std::vector&lt; std::vector&lt; int64 &gt;&gt; *const routes) const</td></tr>
<tr class="memdesc:a97d152b7049084186342b719eee6fa15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the solution in the given assignment to routes for all vehicles.  <a href="#a97d152b7049084186342b719eee6fa15">More...</a><br /></td></tr>
<tr class="separator:a97d152b7049084186342b719eee6fa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7f20d14ae5261cb2f250c6e99f4383"><td class="memItemLeft" align="right" valign="top">Assignment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a1b7f20d14ae5261cb2f250c6e99f4383">CompactAssignment</a> (const Assignment &amp;assignment) const</td></tr>
<tr class="memdesc:a1b7f20d14ae5261cb2f250c6e99f4383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a compacted version of the given assignment, in which all vehicles with id lower or equal to some N have non-empty routes, and all vehicles with id greater than N have empty routes.  <a href="#a1b7f20d14ae5261cb2f250c6e99f4383">More...</a><br /></td></tr>
<tr class="separator:a1b7f20d14ae5261cb2f250c6e99f4383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e87a7710617f6ac19dca14adad9c5a6"><td class="memItemLeft" align="right" valign="top">Assignment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a3e87a7710617f6ac19dca14adad9c5a6">CompactAndCheckAssignment</a> (const Assignment &amp;assignment) const</td></tr>
<tr class="memdesc:a3e87a7710617f6ac19dca14adad9c5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="routing_8h.html#a1b7f20d14ae5261cb2f250c6e99f4383" title="Returns a compacted version of the given assignment, in which all vehicles with id lower or equal to ...">CompactAssignment()</a> but also checks the validity of the final compact solution; if it is not valid, no attempts to repair it are made (instead, the method returns nullptr).  <a href="#a3e87a7710617f6ac19dca14adad9c5a6">More...</a><br /></td></tr>
<tr class="separator:a3e87a7710617f6ac19dca14adad9c5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437ae499bef0aa64f2753166a000f5bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a437ae499bef0aa64f2753166a000f5bd">AddToAssignment</a> (IntVar *const var)</td></tr>
<tr class="memdesc:a437ae499bef0aa64f2753166a000f5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an extra variable to the vehicle routing assignment.  <a href="#a437ae499bef0aa64f2753166a000f5bd">More...</a><br /></td></tr>
<tr class="separator:a437ae499bef0aa64f2753166a000f5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab878a81ace850e3ecd26e95966409f61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ab878a81ace850e3ecd26e95966409f61">AddIntervalToAssignment</a> (IntervalVar *const interval)</td></tr>
<tr class="separator:ab878a81ace850e3ecd26e95966409f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc6e6b421a6dfc8650cc38e116fff03"><td class="memItemLeft" align="right" valign="top">const Assignment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a5cc6e6b421a6dfc8650cc38e116fff03">PackCumulsOfOptimizerDimensionsFromAssignment</a> (const Assignment *original_assignment, absl::Duration duration_limit)</td></tr>
<tr class="memdesc:a5cc6e6b421a6dfc8650cc38e116fff03"><td class="mdescLeft">&#160;</td><td class="mdescRight">For every dimension in the model's dimensions_for_local/global_optimizer_, this method tries to pack the cumul values of the dimension, such that:  <a href="#a5cc6e6b421a6dfc8650cc38e116fff03">More...</a><br /></td></tr>
<tr class="separator:a5cc6e6b421a6dfc8650cc38e116fff03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700982f228080c6278eb5a2f7f06f31d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a700982f228080c6278eb5a2f7f06f31d">SetSweepArranger</a> (SweepArranger *<a class="el" href="routing_8h.html#a71815ec83f6605bddb11578ebb835aae">sweep_arranger</a>)</td></tr>
<tr class="separator:a700982f228080c6278eb5a2f7f06f31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71815ec83f6605bddb11578ebb835aae"><td class="memItemLeft" align="right" valign="top">SweepArranger *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a71815ec83f6605bddb11578ebb835aae">sweep_arranger</a> () const</td></tr>
<tr class="memdesc:a71815ec83f6605bddb11578ebb835aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sweep arranger to be used by routing heuristics.  <a href="#a71815ec83f6605bddb11578ebb835aae">More...</a><br /></td></tr>
<tr class="separator:a71815ec83f6605bddb11578ebb835aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566384949e6395952f6f6b48603fd87f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a566384949e6395952f6f6b48603fd87f">AddLocalSearchFilter</a> (LocalSearchFilter *filter)</td></tr>
<tr class="memdesc:a566384949e6395952f6f6b48603fd87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a custom local search filter to the list of filters used to speed up local search by pruning unfeasible variable assignments.  <a href="#a566384949e6395952f6f6b48603fd87f">More...</a><br /></td></tr>
<tr class="separator:a566384949e6395952f6f6b48603fd87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdbdfc9491ef0586459d38cc5ef4cb8"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#acbdbdfc9491ef0586459d38cc5ef4cb8">Start</a> (int vehicle) const</td></tr>
<tr class="memdesc:acbdbdfc9491ef0586459d38cc5ef4cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model inspection.  <a href="#acbdbdfc9491ef0586459d38cc5ef4cb8">More...</a><br /></td></tr>
<tr class="separator:acbdbdfc9491ef0586459d38cc5ef4cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc8d32892f78532c8ee7a7186158e07"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a1dc8d32892f78532c8ee7a7186158e07">End</a> (int vehicle) const</td></tr>
<tr class="memdesc:a1dc8d32892f78532c8ee7a7186158e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variable index of the ending node of a vehicle route.  <a href="#a1dc8d32892f78532c8ee7a7186158e07">More...</a><br /></td></tr>
<tr class="separator:a1dc8d32892f78532c8ee7a7186158e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1adbc353c105572655ae866124c61b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ae1adbc353c105572655ae866124c61b6">IsStart</a> (int64 index) const</td></tr>
<tr class="memdesc:ae1adbc353c105572655ae866124c61b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if 'index' represents the first node of a route.  <a href="#ae1adbc353c105572655ae866124c61b6">More...</a><br /></td></tr>
<tr class="separator:ae1adbc353c105572655ae866124c61b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2530e17cabaf267e12929ca0ee1bee0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ae2530e17cabaf267e12929ca0ee1bee0">IsEnd</a> (int64 index) const</td></tr>
<tr class="memdesc:ae2530e17cabaf267e12929ca0ee1bee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if 'index' represents the last node of a route.  <a href="#ae2530e17cabaf267e12929ca0ee1bee0">More...</a><br /></td></tr>
<tr class="separator:ae2530e17cabaf267e12929ca0ee1bee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd33c037942b971eeefad43c6022c20e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#abd33c037942b971eeefad43c6022c20e">VehicleIndex</a> (int index) const</td></tr>
<tr class="memdesc:abd33c037942b971eeefad43c6022c20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vehicle of the given start/end index, and -1 if the given index is not a vehicle start/end.  <a href="#abd33c037942b971eeefad43c6022c20e">More...</a><br /></td></tr>
<tr class="separator:abd33c037942b971eeefad43c6022c20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a69d9769aa92122c7e5e20f49e3da3"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a46a69d9769aa92122c7e5e20f49e3da3">Next</a> (const Assignment &amp;assignment, int64 index) const</td></tr>
<tr class="memdesc:a46a69d9769aa92122c7e5e20f49e3da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment inspection Returns the variable index of the node directly after the node corresponding to 'index' in 'assignment'.  <a href="#a46a69d9769aa92122c7e5e20f49e3da3">More...</a><br /></td></tr>
<tr class="separator:a46a69d9769aa92122c7e5e20f49e3da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb8dca94b15e5465fef1667d1a81db6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aedb8dca94b15e5465fef1667d1a81db6">IsVehicleUsed</a> (const Assignment &amp;assignment, int vehicle) const</td></tr>
<tr class="memdesc:aedb8dca94b15e5465fef1667d1a81db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the route of 'vehicle' is non empty in 'assignment'.  <a href="#aedb8dca94b15e5465fef1667d1a81db6">More...</a><br /></td></tr>
<tr class="separator:aedb8dca94b15e5465fef1667d1a81db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad154b31953d2b467bbac3e4ac696cd6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; IntVar * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aad154b31953d2b467bbac3e4ac696cd6">Nexts</a> () const</td></tr>
<tr class="memdesc:aad154b31953d2b467bbac3e4ac696cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variables.  <a href="#aad154b31953d2b467bbac3e4ac696cd6">More...</a><br /></td></tr>
<tr class="separator:aad154b31953d2b467bbac3e4ac696cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80572a238b48c2cefe38409e7544f161"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; IntVar * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a80572a238b48c2cefe38409e7544f161">VehicleVars</a> () const</td></tr>
<tr class="memdesc:a80572a238b48c2cefe38409e7544f161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all vehicle variables of the model, such that VehicleVars(i) is the vehicle variable of the node corresponding to i.  <a href="#a80572a238b48c2cefe38409e7544f161">More...</a><br /></td></tr>
<tr class="separator:a80572a238b48c2cefe38409e7544f161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fb44c05f9875685e9c332fbdfb643b"><td class="memItemLeft" align="right" valign="top">IntVar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a66fb44c05f9875685e9c332fbdfb643b">NextVar</a> (int64 index) const</td></tr>
<tr class="memdesc:a66fb44c05f9875685e9c332fbdfb643b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next variable of the node corresponding to index.  <a href="#a66fb44c05f9875685e9c332fbdfb643b">More...</a><br /></td></tr>
<tr class="separator:a66fb44c05f9875685e9c332fbdfb643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadc1348f0318e9bc8cebb75b2fc4234"><td class="memItemLeft" align="right" valign="top">IntVar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#afadc1348f0318e9bc8cebb75b2fc4234">ActiveVar</a> (int64 index) const</td></tr>
<tr class="memdesc:afadc1348f0318e9bc8cebb75b2fc4234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the active variable of the node corresponding to index.  <a href="#afadc1348f0318e9bc8cebb75b2fc4234">More...</a><br /></td></tr>
<tr class="separator:afadc1348f0318e9bc8cebb75b2fc4234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2d33eef73401442fd9f2e205056c73"><td class="memItemLeft" align="right" valign="top">IntVar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a7c2d33eef73401442fd9f2e205056c73">VehicleCostsConsideredVar</a> (int vehicle) const</td></tr>
<tr class="memdesc:a7c2d33eef73401442fd9f2e205056c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variable specifying whether or not costs are considered for vehicle.  <a href="#a7c2d33eef73401442fd9f2e205056c73">More...</a><br /></td></tr>
<tr class="separator:a7c2d33eef73401442fd9f2e205056c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cded3d3d6746c179a8ec0eddad24342"><td class="memItemLeft" align="right" valign="top">IntVar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a8cded3d3d6746c179a8ec0eddad24342">VehicleVar</a> (int64 index) const</td></tr>
<tr class="memdesc:a8cded3d3d6746c179a8ec0eddad24342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vehicle variable of the node corresponding to index.  <a href="#a8cded3d3d6746c179a8ec0eddad24342">More...</a><br /></td></tr>
<tr class="separator:a8cded3d3d6746c179a8ec0eddad24342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbe77312783c0a5aa4926ace764533b"><td class="memItemLeft" align="right" valign="top">IntVar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#abcbe77312783c0a5aa4926ace764533b">CostVar</a> () const</td></tr>
<tr class="memdesc:abcbe77312783c0a5aa4926ace764533b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global cost variable which is being minimized.  <a href="#abcbe77312783c0a5aa4926ace764533b">More...</a><br /></td></tr>
<tr class="separator:abcbe77312783c0a5aa4926ace764533b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dd6fccc1cca84aa10efc8f3ece396c"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a50dd6fccc1cca84aa10efc8f3ece396c">GetArcCostForVehicle</a> (int64 from_index, int64 to_index, int64 vehicle) const</td></tr>
<tr class="memdesc:a50dd6fccc1cca84aa10efc8f3ece396c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cost of the transit arc between two nodes for a given vehicle.  <a href="#a50dd6fccc1cca84aa10efc8f3ece396c">More...</a><br /></td></tr>
<tr class="separator:a50dd6fccc1cca84aa10efc8f3ece396c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c21c6d4e99cb309b8b298d280e4853"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ae0c21c6d4e99cb309b8b298d280e4853">CostsAreHomogeneousAcrossVehicles</a> () const</td></tr>
<tr class="memdesc:ae0c21c6d4e99cb309b8b298d280e4853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether costs are homogeneous across all vehicles.  <a href="#ae0c21c6d4e99cb309b8b298d280e4853">More...</a><br /></td></tr>
<tr class="separator:ae0c21c6d4e99cb309b8b298d280e4853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa241abc19460575d250a5788f03afbf6"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aa241abc19460575d250a5788f03afbf6">GetHomogeneousCost</a> (int64 from_index, int64 to_index) const</td></tr>
<tr class="memdesc:aa241abc19460575d250a5788f03afbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cost of the segment between two nodes supposing all vehicle costs are the same (returns the cost for the first vehicle otherwise).  <a href="#aa241abc19460575d250a5788f03afbf6">More...</a><br /></td></tr>
<tr class="separator:aa241abc19460575d250a5788f03afbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6569b0ea25fa25c91c2b8b63bedeacc6"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a6569b0ea25fa25c91c2b8b63bedeacc6">GetArcCostForFirstSolution</a> (int64 from_index, int64 to_index) const</td></tr>
<tr class="memdesc:a6569b0ea25fa25c91c2b8b63bedeacc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cost of the arc in the context of the first solution strategy.  <a href="#a6569b0ea25fa25c91c2b8b63bedeacc6">More...</a><br /></td></tr>
<tr class="separator:a6569b0ea25fa25c91c2b8b63bedeacc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d7882c311f7d9d0c55c4def34150dd"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a92d7882c311f7d9d0c55c4def34150dd">GetArcCostForClass</a> (int64 from_index, int64 to_index, int64 cost_class_index) const</td></tr>
<tr class="memdesc:a92d7882c311f7d9d0c55c4def34150dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cost of the segment between two nodes for a given cost class.  <a href="#a92d7882c311f7d9d0c55c4def34150dd">More...</a><br /></td></tr>
<tr class="separator:a92d7882c311f7d9d0c55c4def34150dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bba655accbd7dc8e23d30bf679b880"><td class="memItemLeft" align="right" valign="top">CostClassIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a32bba655accbd7dc8e23d30bf679b880">GetCostClassIndexOfVehicle</a> (int64 vehicle) const</td></tr>
<tr class="memdesc:a32bba655accbd7dc8e23d30bf679b880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cost class index of the given vehicle.  <a href="#a32bba655accbd7dc8e23d30bf679b880">More...</a><br /></td></tr>
<tr class="separator:a32bba655accbd7dc8e23d30bf679b880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e8d10adbcc563f428069f9b2c04b63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a67e8d10adbcc563f428069f9b2c04b63">HasVehicleWithCostClassIndex</a> (CostClassIndex cost_class_index) const</td></tr>
<tr class="memdesc:a67e8d10adbcc563f428069f9b2c04b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the model contains a vehicle with the given cost_class_index.  <a href="#a67e8d10adbcc563f428069f9b2c04b63">More...</a><br /></td></tr>
<tr class="separator:a67e8d10adbcc563f428069f9b2c04b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b144985c2b4b24cf39b839dbd9c16d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ad3b144985c2b4b24cf39b839dbd9c16d">GetCostClassesCount</a> () const</td></tr>
<tr class="memdesc:ad3b144985c2b4b24cf39b839dbd9c16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of different cost classes in the model.  <a href="#ad3b144985c2b4b24cf39b839dbd9c16d">More...</a><br /></td></tr>
<tr class="separator:ad3b144985c2b4b24cf39b839dbd9c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa74f74aefe075aedb6b16259a4404e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#abaa74f74aefe075aedb6b16259a4404e">GetNonZeroCostClassesCount</a> () const</td></tr>
<tr class="memdesc:abaa74f74aefe075aedb6b16259a4404e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ditto, minus the 'always zero', built-in cost class.  <a href="#abaa74f74aefe075aedb6b16259a4404e">More...</a><br /></td></tr>
<tr class="separator:abaa74f74aefe075aedb6b16259a4404e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8e134df97e40d1fc498f7f985c33ec"><td class="memItemLeft" align="right" valign="top">VehicleClassIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a7a8e134df97e40d1fc498f7f985c33ec">GetVehicleClassIndexOfVehicle</a> (int64 vehicle) const</td></tr>
<tr class="separator:a7a8e134df97e40d1fc498f7f985c33ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ab0d5fa45360b5e6a42b9a78cfe5a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a34ab0d5fa45360b5e6a42b9a78cfe5a8">GetVehicleClassesCount</a> () const</td></tr>
<tr class="memdesc:a34ab0d5fa45360b5e6a42b9a78cfe5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of different vehicle classes in the model.  <a href="#a34ab0d5fa45360b5e6a42b9a78cfe5a8">More...</a><br /></td></tr>
<tr class="separator:a34ab0d5fa45360b5e6a42b9a78cfe5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8c7a97b5465ae4ba4cb1a92c39b756"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a0f8c7a97b5465ae4ba4cb1a92c39b756">GetSameVehicleIndicesOfIndex</a> (int node) const</td></tr>
<tr class="memdesc:a0f8c7a97b5465ae4ba4cb1a92c39b756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns variable indices of nodes constrained to be on the same route.  <a href="#a0f8c7a97b5465ae4ba4cb1a92c39b756">More...</a><br /></td></tr>
<tr class="separator:a0f8c7a97b5465ae4ba4cb1a92c39b756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1048b3f7ef92f0d7747f93c8586ea1cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a1048b3f7ef92f0d7747f93c8586ea1cc">ArcIsMoreConstrainedThanArc</a> (int64 from, int64 to1, int64 to2)</td></tr>
<tr class="memdesc:a1048b3f7ef92f0d7747f93c8586ea1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the arc from-&gt;to1 is more constrained than from-&gt;to2, taking into account, in order:  <a href="#a1048b3f7ef92f0d7747f93c8586ea1cc">More...</a><br /></td></tr>
<tr class="separator:a1048b3f7ef92f0d7747f93c8586ea1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d079aaf52ffdf6d547384b523ff018"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a25d079aaf52ffdf6d547384b523ff018">DebugOutputAssignment</a> (const Assignment &amp;solution_assignment, const std::string &amp;dimension_to_print) const</td></tr>
<tr class="memdesc:a25d079aaf52ffdf6d547384b523ff018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print some debugging information about an assignment, including the feasible intervals of the CumulVar for dimension "dimension_to_print" at each step of the routes.  <a href="#a25d079aaf52ffdf6d547384b523ff018">More...</a><br /></td></tr>
<tr class="separator:a25d079aaf52ffdf6d547384b523ff018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f32c22c620c811754ba7b6f977db864"><td class="memItemLeft" align="right" valign="top">Solver *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a5f32c22c620c811754ba7b6f977db864">solver</a> () const</td></tr>
<tr class="memdesc:a5f32c22c620c811754ba7b6f977db864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying constraint solver.  <a href="#a5f32c22c620c811754ba7b6f977db864">More...</a><br /></td></tr>
<tr class="separator:a5f32c22c620c811754ba7b6f977db864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5d70fe48cb54cbc5d8f6bba55b007d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a3f5d70fe48cb54cbc5d8f6bba55b007d">CheckLimit</a> ()</td></tr>
<tr class="memdesc:a3f5d70fe48cb54cbc5d8f6bba55b007d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the search limit has been crossed.  <a href="#a3f5d70fe48cb54cbc5d8f6bba55b007d">More...</a><br /></td></tr>
<tr class="separator:a3f5d70fe48cb54cbc5d8f6bba55b007d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0524e488894fa8f88764c74abb31f5"><td class="memItemLeft" align="right" valign="top">absl::Duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#adb0524e488894fa8f88764c74abb31f5">RemainingTime</a> () const</td></tr>
<tr class="memdesc:adb0524e488894fa8f88764c74abb31f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time left in the search limit.  <a href="#adb0524e488894fa8f88764c74abb31f5">More...</a><br /></td></tr>
<tr class="separator:adb0524e488894fa8f88764c74abb31f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f38add802397fef1f57b7d90ccd5aef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a0f38add802397fef1f57b7d90ccd5aef">nodes</a> () const</td></tr>
<tr class="memdesc:a0f38add802397fef1f57b7d90ccd5aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sizes and indices Returns the number of nodes in the model.  <a href="#a0f38add802397fef1f57b7d90ccd5aef">More...</a><br /></td></tr>
<tr class="separator:a0f38add802397fef1f57b7d90ccd5aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e7ba89833775f29889744fe9480d29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aa9e7ba89833775f29889744fe9480d29">vehicles</a> () const</td></tr>
<tr class="memdesc:aa9e7ba89833775f29889744fe9480d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vehicle routes in the model.  <a href="#aa9e7ba89833775f29889744fe9480d29">More...</a><br /></td></tr>
<tr class="separator:aa9e7ba89833775f29889744fe9480d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354dd8c252cf59b748602b342db6019d"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a354dd8c252cf59b748602b342db6019d">Size</a> () const</td></tr>
<tr class="memdesc:a354dd8c252cf59b748602b342db6019d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of next variables in the model.  <a href="#a354dd8c252cf59b748602b342db6019d">More...</a><br /></td></tr>
<tr class="separator:a354dd8c252cf59b748602b342db6019d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bd106a61d493872cabb0f41f7f118f"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a04bd106a61d493872cabb0f41f7f118f">GetNumberOfDecisionsInFirstSolution</a> (const RoutingSearchParameters &amp;search_parameters) const</td></tr>
<tr class="memdesc:a04bd106a61d493872cabb0f41f7f118f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns statistics on first solution search, number of decisions sent to filters, number of decisions rejected by filters.  <a href="#a04bd106a61d493872cabb0f41f7f118f">More...</a><br /></td></tr>
<tr class="separator:a04bd106a61d493872cabb0f41f7f118f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefff345740a5db07caea065ec14ec52f"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aefff345740a5db07caea065ec14ec52f">GetNumberOfRejectsInFirstSolution</a> (const RoutingSearchParameters &amp;search_parameters) const</td></tr>
<tr class="separator:aefff345740a5db07caea065ec14ec52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8347e84488d1b5eb7b5e6972fb32be3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#ac8347e84488d1b5eb7b5e6972fb32be3">IsMatchingModel</a> () const</td></tr>
<tr class="memdesc:ac8347e84488d1b5eb7b5e6972fb32be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a vehicle/node matching problem is detected.  <a href="#ac8347e84488d1b5eb7b5e6972fb32be3">More...</a><br /></td></tr>
<tr class="separator:ac8347e84488d1b5eb7b5e6972fb32be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2d405cde11bc4a08d752d0e669912c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a7e2d405cde11bc4a08d752d0e669912c">SetTabuVarsCallback</a> (<a class="el" href="routing_8h.html#a0e106a97f0156868f1d1c741b283793e">GetTabuVarsCallback</a> tabu_var_callback)</td></tr>
<tr class="separator:a7e2d405cde11bc4a08d752d0e669912c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d0a3f5cec2e425c86f358e5f06b4a8"><td class="memItemLeft" align="right" valign="top">DecisionBuilder *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a20d0a3f5cec2e425c86f358e5f06b4a8">MakeGuidedSlackFinalizer</a> (const <a class="el" href="routing_8h.html#a50ba9dd11704e0be7edaa9e9f24142ff">RoutingDimension</a> *dimension, std::function&lt; int64(int64)&gt; initializer)</td></tr>
<tr class="memdesc:a20d0a3f5cec2e425c86f358e5f06b4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next few members are in the public section only for testing purposes.  <a href="#a20d0a3f5cec2e425c86f358e5f06b4a8">More...</a><br /></td></tr>
<tr class="separator:a20d0a3f5cec2e425c86f358e5f06b4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c45751ee316e0948ba32494262f006"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; LocalSearchOperator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#aa1c45751ee316e0948ba32494262f006">MakeGreedyDescentLSOperator</a> (std::vector&lt; IntVar * &gt; variables)</td></tr>
<tr class="separator:aa1c45751ee316e0948ba32494262f006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c3abe7b321f4caf06a0a5e72586cac"><td class="memItemLeft" align="right" valign="top">DecisionBuilder *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="routing_8h.html#a56c3abe7b321f4caf06a0a5e72586cac">MakeSelfDependentDimensionFinalizer</a> (const <a class="el" href="routing_8h.html#a50ba9dd11704e0be7edaa9e9f24142ff">RoutingDimension</a> *dimension)</td></tr>
<tr class="memdesc:a56c3abe7b321f4caf06a0a5e72586cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">MakeSelfDependentDimensionFinalizer is a finalizer for the slacks of a self-dependent dimension.  <a href="#a56c3abe7b321f4caf06a0a5e72586cac">More...</a><br /></td></tr>
<tr class="separator:a56c3abe7b321f4caf06a0a5e72586cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af52b05a44d013985efe92bec167e0bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52b05a44d013985efe92bec167e0bd7">&#9670;&nbsp;</a></span>OR_TOOLS_CONSTRAINT_SOLVER_ROUTING_H_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OR_TOOLS_CONSTRAINT_SOLVER_ROUTING_H_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0e106a97f0156868f1d1c741b283793e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e106a97f0156868f1d1c741b283793e">&#9670;&nbsp;</a></span>GetTabuVarsCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="routing_8h.html#a0e106a97f0156868f1d1c741b283793e">GetTabuVarsCallback</a> =  std::function&lt;std::vector&lt;<a class="el" href="classoperations__research_1_1IntVar.html">operations_research::IntVar</a>*&gt;(RoutingModel*)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the callback returning the variable to use for the Tabu Search metaheuristic. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01200">1200</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afadc1348f0318e9bc8cebb75b2fc4234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afadc1348f0318e9bc8cebb75b2fc4234">&#9670;&nbsp;</a></span>ActiveVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntVar* ActiveVar </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the active variable of the node corresponding to index. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01068">1068</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a086605d9650ce3c576d8a9c45ce0b9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086605d9650ce3c576d8a9c45ce0b9fc">&#9670;&nbsp;</a></span>AddAtSolutionCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddAtSolutionCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a callback called each time a solution is found during the search. </p>
<p>This is a shortcut to creating a monitor to call the callback on AtSolution() and adding it with AddSearchMonitor. </p>

</div>
</div>
<a id="a796b4eed03ed53bbbaed642f4ae94952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796b4eed03ed53bbbaed642f4ae94952">&#9670;&nbsp;</a></span>AddHardTypeIncompatibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddHardTypeIncompatibility </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incompatibilities: Two nodes with "hard" incompatible types cannot share the same route at all, while with a "temporal" incompatibility they can't be on the same route at the same time. </p>

</div>
</div>
<a id="ab878a81ace850e3ecd26e95966409f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab878a81ace850e3ecd26e95966409f61">&#9670;&nbsp;</a></span>AddIntervalToAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddIntervalToAssignment </td>
          <td>(</td>
          <td class="paramtype">IntervalVar *const&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a566384949e6395952f6f6b48603fd87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566384949e6395952f6f6b48603fd87f">&#9670;&nbsp;</a></span>AddLocalSearchFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddLocalSearchFilter </td>
          <td>(</td>
          <td class="paramtype">LocalSearchFilter *&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a custom local search filter to the list of filters used to speed up local search by pruning unfeasible variable assignments. </p>
<p>Calling this method after the routing model has been closed (<a class="el" href="routing_8h.html#add71470f4175a0859e6e3d69c2a53988" title="Closes the current routing model; after this method is called, no modification to the model can be do...">CloseModel()</a> or <a class="el" href="routing_8h.html#a562e4c0a80f7f4eda9573a482af288d1" title="Solves the current routing model; closes the current model.">Solve()</a> has been called) has no effect. The routing model does not take ownership of the filter. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01029">1029</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a1156fa8214dba09e2a2a94862244aa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1156fa8214dba09e2a2a94862244aa1f">&#9670;&nbsp;</a></span>AddLocalSearchOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddLocalSearchOperator </td>
          <td>(</td>
          <td class="paramtype">LocalSearchOperator *&#160;</td>
          <td class="paramname"><em>ls_operator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a local search operator to the set of operators used to solve the vehicle routing problem. </p>

</div>
</div>
<a id="ac22e9cfd1fbf1b4af4f8a9be46ec88a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22e9cfd1fbf1b4af4f8a9be46ec88a1">&#9670;&nbsp;</a></span>AddSameVehicleRequiredTypeAlternatives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddSameVehicleRequiredTypeAlternatives </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dependent_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::flat_hash_set&lt; int &gt;&#160;</td>
          <td class="paramname"><em>required_type_alternatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requirements: </p>
<dl class="section note"><dt>Note</dt><dd>As of 2019-04, cycles in the requirement graph are not supported, and lead to the dependent nodes being skipped if possible (otherwise the model is considered infeasible). The following functions specify that "dependent_type" requires at least one of the types in "required_type_alternatives".</dd></dl>
<p>For same-vehicle requirements, a node of dependent type type_D requires at least one node of type type_R among the required alternatives on the same route. </p>

</div>
</div>
<a id="a0e23be986e4c3b96a50c8798aa5f536d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e23be986e4c3b96a50c8798aa5f536d">&#9670;&nbsp;</a></span>AddSearchMonitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddSearchMonitor </td>
          <td>(</td>
          <td class="paramtype">SearchMonitor *const&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a search monitor to the search used to solve the routing model. </p>

</div>
</div>
<a id="a92ee209f167d3974329301d784010b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ee209f167d3974329301d784010b63">&#9670;&nbsp;</a></span>AddTemporalRequiredTypeAlternatives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddTemporalRequiredTypeAlternatives </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dependent_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::flat_hash_set&lt; int &gt;&#160;</td>
          <td class="paramname"><em>required_type_alternatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If type_D temporally depends on type_R, any non-delivery node_D of type_D requires at least one non-delivered node of type_R on its vehicle at the time node_D is visited. </p>

</div>
</div>
<a id="a7086a908f1890a7e1550c97b774e6384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7086a908f1890a7e1550c97b774e6384">&#9670;&nbsp;</a></span>AddTemporalTypeIncompatibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddTemporalTypeIncompatibility </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a437ae499bef0aa64f2753166a000f5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437ae499bef0aa64f2753166a000f5bd">&#9670;&nbsp;</a></span>AddToAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddToAssignment </td>
          <td>(</td>
          <td class="paramtype">IntVar *const&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an extra variable to the vehicle routing assignment. </p>

</div>
</div>
<a id="aabdcf3bd412a5a61d811ef85e115e5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabdcf3bd412a5a61d811ef85e115e5ff">&#9670;&nbsp;</a></span>AddVariableMaximizedByFinalizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddVariableMaximizedByFinalizer </td>
          <td>(</td>
          <td class="paramtype">IntVar *&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a variable to maximize in the solution finalizer (see above for information on the solution finalizer). </p>

</div>
</div>
<a id="a4768ba91c34c542eddec212a68d79473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4768ba91c34c542eddec212a68d79473">&#9670;&nbsp;</a></span>AddVariableMinimizedByFinalizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddVariableMinimizedByFinalizer </td>
          <td>(</td>
          <td class="paramtype">IntVar *&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a variable to minimize in the solution finalizer. </p>
<p>The solution finalizer is called each time a solution is found during the search and allows to instantiate secondary variables (such as dimension cumul variables). </p>

</div>
</div>
<a id="aaf71584ad4bffea7a489dc53787fa6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf71584ad4bffea7a489dc53787fa6f8">&#9670;&nbsp;</a></span>ApplyLocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntVar* ApplyLocks </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int64 &gt; &amp;&#160;</td>
          <td class="paramname"><em>locks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a lock chain to the next search. </p>
<p>'locks' represents an ordered vector of nodes representing a partial route which will be fixed during the next search; it will constrain next variables such that: next[locks[i]] == locks[i+1]. Returns the next variable at the end of the locked chain; this variable is not locked. An assignment containing the locks can be obtained by calling <a class="el" href="routing_8h.html#ae033bc458ffce1ecc4874f3e212896f7" title="Returns an assignment used to fix some of the variables of the problem.">PreAssignment()</a>. </p>

</div>
</div>
<a id="a410f7da30cf944b7874eebe57eebe41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410f7da30cf944b7874eebe57eebe41a">&#9670;&nbsp;</a></span>ApplyLocksToAllVehicles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ApplyLocksToAllVehicles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int64 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>locks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>close_routes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies lock chains to all vehicles to the next search, such that locks[p] is the lock chain for route p. </p>
<p>Returns false if the locks do not contain valid routes; expects that the routes do not contain the depots, i.e. there are empty vectors in place of empty routes. If close_routes is set to true, adds the end nodes to the route of each vehicle and deactivates other nodes. An assignment containing the locks can be obtained by calling <a class="el" href="routing_8h.html#ae033bc458ffce1ecc4874f3e212896f7" title="Returns an assignment used to fix some of the variables of the problem.">PreAssignment()</a>. </p>

</div>
</div>
<a id="a1048b3f7ef92f0d7747f93c8586ea1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1048b3f7ef92f0d7747f93c8586ea1cc">&#9670;&nbsp;</a></span>ArcIsMoreConstrainedThanArc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArcIsMoreConstrainedThanArc </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>to1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>to2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the arc from-&gt;to1 is more constrained than from-&gt;to2, taking into account, in order: </p>
<ul>
<li>whether the destination node isn't an end node</li>
<li>whether the destination node is mandatory</li>
<li>whether the destination node is bound to the same vehicle as the source</li>
<li>the "primary constrained" dimension (see SetPrimaryConstrainedDimension) It then breaks ties using, in order:</li>
<li>the arc cost (taking unperformed penalties into account)</li>
<li>the size of the vehicle vars of "to1" and "to2" (lowest size wins)</li>
<li>the value: the lowest value of the indices to1 and to2 wins. See the .cc for details. The more constrained arc is typically preferable when building a first solution. This method is intended to be used as a callback for the BestValueByComparisonSelector value selector. Args: from: the variable index of the source node to1: the variable index of the first candidate destination node. to2: the variable index of the second candidate destination node. </li>
</ul>

</div>
</div>
<a id="aed6760664a6e4f3427832ee3b7ba0602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6760664a6e4f3427832ee3b7ba0602">&#9670;&nbsp;</a></span>AreEmptyRouteCostsConsideredForVehicle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AreEmptyRouteCostsConsideredForVehicle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vehicle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00831">831</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a97d152b7049084186342b719eee6fa15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d152b7049084186342b719eee6fa15">&#9670;&nbsp;</a></span>AssignmentToRoutes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AssignmentToRoutes </td>
          <td>(</td>
          <td class="paramtype">const Assignment &amp;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int64 &gt;&gt; *const&#160;</td>
          <td class="paramname"><em>routes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the solution in the given assignment to routes for all vehicles. </p>
<p>Expects that assignment contains a valid solution (i.e. routes for all vehicles end with an end index for that vehicle). </p>

</div>
</div>
<a id="a3f5d70fe48cb54cbc5d8f6bba55b007d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5d70fe48cb54cbc5d8f6bba55b007d">&#9670;&nbsp;</a></span>CheckLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the search limit has been crossed. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01167">1167</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="add71470f4175a0859e6e3d69c2a53988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add71470f4175a0859e6e3d69c2a53988">&#9670;&nbsp;</a></span>CloseModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CloseModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the current routing model; after this method is called, no modification to the model can be done, but RoutesToAssignment becomes available. </p>
<p>Note that <a class="el" href="routing_8h.html#add71470f4175a0859e6e3d69c2a53988" title="Closes the current routing model; after this method is called, no modification to the model can be do...">CloseModel()</a> is automatically called by <a class="el" href="routing_8h.html#a562e4c0a80f7f4eda9573a482af288d1" title="Solves the current routing model; closes the current model.">Solve()</a> and other methods that produce solution. This is equivalent to calling CloseModelWithParameters(DefaultRoutingSearchParameters()). </p>

</div>
</div>
<a id="aa79f8d482de4dd0ef86a1b54999686af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79f8d482de4dd0ef86a1b54999686af">&#9670;&nbsp;</a></span>CloseModelWithParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CloseModelWithParameters </td>
          <td>(</td>
          <td class="paramtype">const RoutingSearchParameters &amp;&#160;</td>
          <td class="paramname"><em>search_parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above taking search parameters (as of 10/2015 some the parameters have to be set when closing the model). </p>

</div>
</div>
<a id="a822458cc9a9a6fa02e86af3e3a1e5c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822458cc9a9a6fa02e86af3e3a1e5c89">&#9670;&nbsp;</a></span>CloseVisitTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CloseVisitTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called once all node visit types have been set and prior to adding any incompatibilities/requirements. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd>(user): Reconsider the logic and potentially remove the need to "close" types. </dd></dl>

</div>
</div>
<a id="a3e87a7710617f6ac19dca14adad9c5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e87a7710617f6ac19dca14adad9c5a6">&#9670;&nbsp;</a></span>CompactAndCheckAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assignment* CompactAndCheckAssignment </td>
          <td>(</td>
          <td class="paramtype">const Assignment &amp;&#160;</td>
          <td class="paramname"><em>assignment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="routing_8h.html#a1b7f20d14ae5261cb2f250c6e99f4383" title="Returns a compacted version of the given assignment, in which all vehicles with id lower or equal to ...">CompactAssignment()</a> but also checks the validity of the final compact solution; if it is not valid, no attempts to repair it are made (instead, the method returns nullptr). </p>

</div>
</div>
<a id="a1b7f20d14ae5261cb2f250c6e99f4383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7f20d14ae5261cb2f250c6e99f4383">&#9670;&nbsp;</a></span>CompactAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assignment* CompactAssignment </td>
          <td>(</td>
          <td class="paramtype">const Assignment &amp;&#160;</td>
          <td class="paramname"><em>assignment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a compacted version of the given assignment, in which all vehicles with id lower or equal to some N have non-empty routes, and all vehicles with id greater than N have empty routes. </p>
<p>Does not take ownership of the returned object. If found, the cost of the compact assignment is the same as in the original assignment and it preserves the values of 'active' variables. Returns nullptr if a compact assignment was not found. This method only works in homogenous mode, and it only swaps equivalent vehicles (vehicles with the same start and end nodes). When creating the compact assignment, the empty plan is replaced by the route assigned to the compatible vehicle with the highest id. Note that with more complex constraints on vehicle variables, this method might fail even if a compact solution exists. This method changes the vehicle and dimension variables as necessary. While compacting the solution, only basic checks on vehicle variables are performed; if one of these checks fails no attempts to repair it are made (instead, the method returns nullptr). </p>

</div>
</div>
<a id="ae9b2404a26ab1e6acf562b8261eeba38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b2404a26ab1e6acf562b8261eeba38">&#9670;&nbsp;</a></span>ComputeLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 ComputeLowerBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a lower bound to the routing problem solving a linear assignment problem. </p>
<p>The routing model must be closed before calling this method. </p><dl class="section note"><dt>Note</dt><dd>problems with node disjunction constraints (including optional nodes) and non-homogenous costs are not supported (the method returns 0 in these cases). </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000032">Todo:</a></b></dt><dd>(user): Add support for non-homogeneous costs and disjunctions. </dd></dl>

</div>
</div>
<a id="a7ccaa3133378da76d3fd5cdb560038ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccaa3133378da76d3fd5cdb560038ae">&#9670;&nbsp;</a></span>ConsiderEmptyRouteCostsForVehicle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConsiderEmptyRouteCostsForVehicle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>consider_costs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vehicle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00826">826</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="ae0c21c6d4e99cb309b8b298d280e4853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c21c6d4e99cb309b8b298d280e4853">&#9670;&nbsp;</a></span>CostsAreHomogeneousAcrossVehicles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CostsAreHomogeneousAcrossVehicles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether costs are homogeneous across all vehicles. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01085">1085</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="abcbe77312783c0a5aa4926ace764533b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbe77312783c0a5aa4926ace764533b">&#9670;&nbsp;</a></span>CostVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntVar* CostVar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the global cost variable which is being minimized. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01078">1078</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a25d079aaf52ffdf6d547384b523ff018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d079aaf52ffdf6d547384b523ff018">&#9670;&nbsp;</a></span>DebugOutputAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DebugOutputAssignment </td>
          <td>(</td>
          <td class="paramtype">const Assignment &amp;&#160;</td>
          <td class="paramname"><em>solution_assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dimension_to_print</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print some debugging information about an assignment, including the feasible intervals of the CumulVar for dimension "dimension_to_print" at each step of the routes. </p>
<p>If "dimension_to_print" is omitted, all dimensions will be printed. </p>

</div>
</div>
<a id="a1dc8d32892f78532c8ee7a7186158e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc8d32892f78532c8ee7a7186158e07">&#9670;&nbsp;</a></span>End()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 End </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vehicle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the variable index of the ending node of a vehicle route. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01041">1041</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a660cb5477a6d3fbf146657aa7af73968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660cb5477a6d3fbf146657aa7af73968">&#9670;&nbsp;</a></span>first_solution_evaluator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Solver::IndexEvaluator2&amp; first_solution_evaluator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search Gets/sets the evaluator used during the search. </p>
<p>Only relevant when RoutingSearchParameters.first_solution_strategy = EVALUATOR_STRATEGY. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00840">840</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="aa01519be299cb5ddef36111ee6f8a5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01519be299cb5ddef36111ee6f8a5cc">&#9670;&nbsp;</a></span>GetAmortizedLinearCostFactorOfVehicles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int64&gt;&amp; GetAmortizedLinearCostFactorOfVehicles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00819">819</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="aaeaf95383c1c03da6f22c522d119775b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeaf95383c1c03da6f22c522d119775b">&#9670;&nbsp;</a></span>GetAmortizedQuadraticCostFactorOfVehicles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int64&gt;&amp; GetAmortizedQuadraticCostFactorOfVehicles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00822">822</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a92d7882c311f7d9d0c55c4def34150dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d7882c311f7d9d0c55c4def34150dd">&#9670;&nbsp;</a></span>GetArcCostForClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 GetArcCostForClass </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>from_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>to_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>cost_class_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the cost of the segment between two nodes for a given cost class. </p>
<p>Input are variable indices of nodes and the cost class. Unlike <a class="el" href="routing_8h.html#a50dd6fccc1cca84aa10efc8f3ece396c" title="Returns the cost of the transit arc between two nodes for a given vehicle.">GetArcCostForVehicle()</a>, if cost_class is kNoCost, then the returned cost won't necessarily be zero: only some of the components of the cost that depend on the cost class will be omited. See the code for details. </p>

</div>
</div>
<a id="a6569b0ea25fa25c91c2b8b63bedeacc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6569b0ea25fa25c91c2b8b63bedeacc6">&#9670;&nbsp;</a></span>GetArcCostForFirstSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 GetArcCostForFirstSolution </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>from_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>to_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the cost of the arc in the context of the first solution strategy. </p>
<p>This is typically a simplification of the actual cost; see the .cc. </p>

</div>
</div>
<a id="a50dd6fccc1cca84aa10efc8f3ece396c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dd6fccc1cca84aa10efc8f3ece396c">&#9670;&nbsp;</a></span>GetArcCostForVehicle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 GetArcCostForVehicle </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>from_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>to_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>vehicle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the cost of the transit arc between two nodes for a given vehicle. </p>
<p>Input are variable indices of node. This returns 0 if vehicle &lt; 0. </p>

</div>
</div>
<a id="ad3b144985c2b4b24cf39b839dbd9c16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b144985c2b4b24cf39b839dbd9c16d">&#9670;&nbsp;</a></span>GetCostClassesCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetCostClassesCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of different cost classes in the model. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01119">1119</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a32bba655accbd7dc8e23d30bf679b880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bba655accbd7dc8e23d30bf679b880">&#9670;&nbsp;</a></span>GetCostClassIndexOfVehicle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CostClassIndex GetCostClassIndexOfVehicle </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>vehicle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cost class index of the given vehicle. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01105">1105</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="acca75b5d3bfe2433c5805b049815f533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca75b5d3bfe2433c5805b049815f533">&#9670;&nbsp;</a></span>GetDepot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 GetDepot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the variable index of the first starting or ending node of all routes. </p>
<p>If all routes start and end at the same node (single depot), this is the node returned. </p>

</div>
</div>
<a id="a4bab641f5b9bf8de266adad29558b4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bab641f5b9bf8de266adad29558b4c2">&#9670;&nbsp;</a></span>GetFixedCostOfVehicle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 GetFixedCostOfVehicle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vehicle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the route fixed cost taken into account if the route of the vehicle is not empty, aka there's at least one node on the route other than the first and last nodes. </p>

</div>
</div>
<a id="a51fb0661acf38ed1442819e2cc452311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fb0661acf38ed1442819e2cc452311">&#9670;&nbsp;</a></span>GetHardTypeIncompatibilitiesOfType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const absl::flat_hash_set&lt;int&gt;&amp; GetHardTypeIncompatibilitiesOfType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns visit types incompatible with a given type. </p>

</div>
</div>
<a id="aa241abc19460575d250a5788f03afbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa241abc19460575d250a5788f03afbf6">&#9670;&nbsp;</a></span>GetHomogeneousCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 GetHomogeneousCost </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>from_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>to_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the cost of the segment between two nodes supposing all vehicle costs are the same (returns the cost for the first vehicle otherwise). </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01090">1090</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="abaa74f74aefe075aedb6b16259a4404e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa74f74aefe075aedb6b16259a4404e">&#9670;&nbsp;</a></span>GetNonZeroCostClassesCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetNonZeroCostClassesCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ditto, minus the 'always zero', built-in cost class. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01121">1121</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a04bd106a61d493872cabb0f41f7f118f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bd106a61d493872cabb0f41f7f118f">&#9670;&nbsp;</a></span>GetNumberOfDecisionsInFirstSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 GetNumberOfDecisionsInFirstSolution </td>
          <td>(</td>
          <td class="paramtype">const RoutingSearchParameters &amp;&#160;</td>
          <td class="paramname"><em>search_parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns statistics on first solution search, number of decisions sent to filters, number of decisions rejected by filters. </p>

</div>
</div>
<a id="aefff345740a5db07caea065ec14ec52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefff345740a5db07caea065ec14ec52f">&#9670;&nbsp;</a></span>GetNumberOfRejectsInFirstSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 GetNumberOfRejectsInFirstSolution </td>
          <td>(</td>
          <td class="paramtype">const RoutingSearchParameters &amp;&#160;</td>
          <td class="paramname"><em>search_parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24478803a7138d68852093b9c2743892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24478803a7138d68852093b9c2743892">&#9670;&nbsp;</a></span>GetNumberOfVisitTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetNumberOfVisitTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00706">706</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a0f8c7a97b5465ae4ba4cb1a92c39b756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8c7a97b5465ae4ba4cb1a92c39b756">&#9670;&nbsp;</a></span>GetSameVehicleIndicesOfIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int&gt;&amp; GetSameVehicleIndicesOfIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns variable indices of nodes constrained to be on the same route. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01131">1131</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="ae350d70cb713a6772283e3753f4f2f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae350d70cb713a6772283e3753f4f2f7a">&#9670;&nbsp;</a></span>GetSameVehicleRequiredTypeAlternativesOfType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;absl::flat_hash_set&lt;int&gt; &gt;&amp; GetSameVehicleRequiredTypeAlternativesOfType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clang-format off Returns the sets of same-vehicle/temporal requirement alternatives for the given type. </p>

</div>
</div>
<a id="ab1652af55e9d83490d9c59d35d991ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1652af55e9d83490d9c59d35d991ce9">&#9670;&nbsp;</a></span>GetTemporalRequiredTypeAlternativesOfType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;absl::flat_hash_set&lt;int&gt; &gt;&amp; GetTemporalRequiredTypeAlternativesOfType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d8ead500db4128d0d27f8066d1f8208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8ead500db4128d0d27f8066d1f8208">&#9670;&nbsp;</a></span>GetTemporalTypeIncompatibilitiesOfType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const absl::flat_hash_set&lt;int&gt;&amp; GetTemporalTypeIncompatibilitiesOfType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34ab0d5fa45360b5e6a42b9a78cfe5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ab0d5fa45360b5e6a42b9a78cfe5a8">&#9670;&nbsp;</a></span>GetVehicleClassesCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetVehicleClassesCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of different vehicle classes in the model. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01129">1129</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a7a8e134df97e40d1fc498f7f985c33ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8e134df97e40d1fc498f7f985c33ec">&#9670;&nbsp;</a></span>GetVehicleClassIndexOfVehicle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VehicleClassIndex GetVehicleClassIndexOfVehicle </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>vehicle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01124">1124</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a874eb2862dd884ad47e30746e03627f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874eb2862dd884ad47e30746e03627f5">&#9670;&nbsp;</a></span>GetVisitType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">routing_no_lns (default: false) int GetVisitType </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. </p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. The vehicle routing library lets one model and solve generic vehicle routing problems ranging from the Traveling Salesman Problem to more complex problems such as the Capacitated Vehicle Routing Problem with Time Windows.</p>
<p>The objective of a vehicle routing problem is to build routes covering a set of nodes minimizing the overall cost of the routes (usually proportional to the sum of the lengths of each segment of the routes) while respecting some problem-specific constraints (such as the length of a route). A route is equivalent to a path connecting nodes, starting/ending at specific starting/ending nodes.</p>
<p>The term "vehicle routing" is historical and the category of problems solved is not limited to the routing of vehicles: any problem involving finding routes visiting a given number of nodes optimally falls under this category of problems, such as finding the optimal sequence in a playlist. The literature around vehicle routing problems is extremely dense but one can find some basic introductions in the following links:</p><ul>
<li><a href="http://en.wikipedia.org/wiki/Travelling_salesman_problem">http://en.wikipedia.org/wiki/Travelling_salesman_problem</a></li>
<li><a href="http://www.tsp.gatech.edu/history/index.html">http://www.tsp.gatech.edu/history/index.html</a></li>
<li><a href="http://en.wikipedia.org/wiki/Vehicle_routing_problem">http://en.wikipedia.org/wiki/Vehicle_routing_problem</a></li>
</ul>
<p>The vehicle routing library is a vertical layer above the constraint programming library (ortools/constraint_programming:cp). One has access to all underlying constrained variables of the vehicle routing model which can therefore be enriched by adding any constraint available in the constraint programming library.</p>
<p>There are two sets of variables available:</p><ul>
<li>path variables:<ul>
<li>"next(i)" variables representing the immediate successor of the node corresponding to i; use IndexToNode() to get the node corresponding to a "next" variable value; note that node indices are strongly typed integers (cf. ortools/base/int_type.h);</li>
<li>"vehicle(i)" variables representing the vehicle route to which the node corresponding to i belongs;</li>
<li>"active(i)" boolean variables, true if the node corresponding to i is visited and false if not; this can be false when nodes are either optional or part of a disjunction;</li>
<li>The following relationships hold for all i: active(i) == 0 &lt;=&gt; next(i) == i &lt;=&gt; vehicle(i) == -1, next(i) == j =&gt; vehicle(j) == vehicle(i).</li>
</ul>
</li>
<li>dimension variables, used when one is accumulating quantities along routes, such as weight or volume carried, distance or time:<ul>
<li>"cumul(i,d)" variables representing the quantity of dimension d when arriving at the node corresponding to i;</li>
<li>"transit(i,d)" variables representing the quantity of dimension d added after visiting the node corresponding to i.</li>
<li>The following relationship holds for all (i,d): next(i) == j =&gt; cumul(j,d) == cumul(i,d) + transit(i,d). Solving the vehicle routing problems is mainly done using approximate methods (namely local search, cf. <a href="http://en.wikipedia.org/wiki/Local_search_(optimization)">http://en.wikipedia.org/wiki/Local_search_(optimization)</a> ), potentially combined with exact techniques based on dynamic programming and exhaustive tree search. <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000029">Todo:</a></b></dt><dd>(user): Add a section on costs (vehicle arc costs, span costs, disjunctions costs).</dd></dl>
</li>
</ul>
</li>
</ul>
<p>Advanced tips: Flags are available to tune the search used to solve routing problems. Here is a quick overview of the ones one might want to modify:</p><ul>
<li>Limiting the search for solutions:<ul>
<li>routing_solution_limit (default: kint64max): stop the search after finding 'routing_solution_limit' improving solutions;</li>
<li>routing_time_limit (default: kint64max): stop the search after 'routing_time_limit' milliseconds;</li>
</ul>
</li>
<li>Customizing search:<ul>
<li>routing_first_solution (default: select the first node with an unbound successor and connect it to the first available node): selects the heuristic to build a first solution which will then be improved by local search; possible values are GlobalCheapestArc (iteratively connect two nodes which produce the cheapest route segment), LocalCheapestArc (select the first node with an unbound successor and connect it to the node which produces the cheapest route segment), PathCheapestArc (starting from a route "start" node, connect it to the node which produces the cheapest route segment, then extend the route by iterating on the last node added to the route).</li>
<li>Local search neighborhoods: Search (LNS); LNS can find good solutions but is usually very slow. Refer to the description of PATHLNS in the LocalSearchOperators enum in <a class="el" href="constraint__solver_8h.html">constraint_solver.h</a> for more information. solve "sub"-traveling salesman problems (TSPs) of the current model (such as sub-parts of a route, or one route in a multiple route problem). Uses dynamic programming to solve such TSPs with a maximum size (in number of nodes) up to cp_local_search_tsp_opt_size (flag with a default value of 13 nodes). It is not activated by default because it can slow down the search.</li>
</ul>
</li>
<li>Meta-heuristics: used to guide the search out of local minima found by local search. Note that, in general, a search with metaheuristics activated never stops, therefore one must specify a search limit. Several types of metaheuristics are provided: search (cf. <a href="http://en.wikipedia.org/wiki/Guided_Local_Search">http://en.wikipedia.org/wiki/Guided_Local_Search</a>); this is generally the most efficient metaheuristic for vehicle routing; accordingly. <dl class="section note"><dt>Note</dt><dd>These incompatibilities and requirements are only handled when each node index appears in at most one pickup/delivery pair, i.e. when the same node isn't a pickup and/or delivery in multiple pickup/delivery pairs. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000030">Todo:</a></b></dt><dd>(user): Support multiple visit types per node? </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a9c58894df747f5498c335a3a8c5c0c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c58894df747f5498c335a3a8c5c0c88">&#9670;&nbsp;</a></span>HasHardTypeIncompatibilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasHardTypeIncompatibilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff any hard (resp. </p>
<p>temporal) type incompatibilities have been added to the model. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00720">720</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="abc101a64a3c876dcdf1b7176d59bd2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc101a64a3c876dcdf1b7176d59bd2c9">&#9670;&nbsp;</a></span>HasSameVehicleTypeRequirements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasSameVehicleTypeRequirements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clang-format on Returns true iff any same-route (resp. </p>
<p>temporal) type requirements have been added to the model. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00753">753</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="ad19492313b68e5a963af3793aaec8d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19492313b68e5a963af3793aaec8d90">&#9670;&nbsp;</a></span>HasTemporalTypeIncompatibilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasTemporalTypeIncompatibilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00723">723</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a5e3f4c6871f7b2c67fd5b1ad6c94d891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3f4c6871f7b2c67fd5b1ad6c94d891">&#9670;&nbsp;</a></span>HasTemporalTypeRequirements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasTemporalTypeRequirements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00756">756</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="ab313d84a56c5e9b1b8f28da70b8d4045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab313d84a56c5e9b1b8f28da70b8d4045">&#9670;&nbsp;</a></span>HasTypeRegulations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasTypeRegulations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the model has any incompatibilities or requirements set on node types. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00762">762</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a67e8d10adbcc563f428069f9b2c04b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e8d10adbcc563f428069f9b2c04b63">&#9670;&nbsp;</a></span>HasVehicleWithCostClassIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasVehicleWithCostClassIndex </td>
          <td>(</td>
          <td class="paramtype">CostClassIndex&#160;</td>
          <td class="paramname"><em>cost_class_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the model contains a vehicle with the given cost_class_index. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01111">1111</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="ae2530e17cabaf267e12929ca0ee1bee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2530e17cabaf267e12929ca0ee1bee0">&#9670;&nbsp;</a></span>IsEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsEnd </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if 'index' represents the last node of a route. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01045">1045</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="ac8347e84488d1b5eb7b5e6972fb32be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8347e84488d1b5eb7b5e6972fb32be3">&#9670;&nbsp;</a></span>IsMatchingModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsMatchingModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a vehicle/node matching problem is detected. </p>

</div>
</div>
<a id="ae1adbc353c105572655ae866124c61b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1adbc353c105572655ae866124c61b6">&#9670;&nbsp;</a></span>IsStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsStart </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if 'index' represents the first node of a route. </p>

</div>
</div>
<a id="aedb8dca94b15e5465fef1667d1a81db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb8dca94b15e5465fef1667d1a81db6">&#9670;&nbsp;</a></span>IsVehicleUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsVehicleUsed </td>
          <td>(</td>
          <td class="paramtype">const Assignment &amp;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vehicle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the route of 'vehicle' is non empty in 'assignment'. </p>

</div>
</div>
<a id="aa1c45751ee316e0948ba32494262f006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c45751ee316e0948ba32494262f006">&#9670;&nbsp;</a></span>MakeGreedyDescentLSOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;LocalSearchOperator&gt; MakeGreedyDescentLSOperator </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; IntVar * &gt;&#160;</td>
          <td class="paramname"><em>variables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd>(user): MakeGreedyDescentLSOperator is too general for <a class="el" href="routing_8h.html">routing.h</a>.</dd></dl>
<p>Perhaps move it to <a class="el" href="constraint__solver_8h.html">constraint_solver.h</a>. MakeGreedyDescentLSOperator creates a local search operator that tries to improve the initial assignment by moving a logarithmically decreasing step away in each possible dimension. </p>

</div>
</div>
<a id="a20d0a3f5cec2e425c86f358e5f06b4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d0a3f5cec2e425c86f358e5f06b4a8">&#9670;&nbsp;</a></span>MakeGuidedSlackFinalizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DecisionBuilder* MakeGuidedSlackFinalizer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="routing_8h.html#a50ba9dd11704e0be7edaa9e9f24142ff">RoutingDimension</a> *&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64(int64)&gt;&#160;</td>
          <td class="paramname"><em>initializer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The next few members are in the public section only for testing purposes. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd>(user): Find a way to test and restrict the access at the same time.</dd></dl>
<p>MakeGuidedSlackFinalizer creates a DecisionBuilder for the slacks of a dimension using a callback to choose which values to start with. The finalizer works only when all next variables in the model have been fixed. It has the following two characteristics:</p><ol type="1">
<li>It follows the routes defined by the nexts variables when choosing a variable to make a decision on.</li>
<li>When it comes to choose a value for the slack of node i, the decision builder first calls the callback with argument i, and supposingly the returned value is x it creates decisions slack[i] = x, slack[i] = x + 1, slack[i] = x - 1, slack[i] = x + 2, etc. </li>
</ol>

</div>
</div>
<a id="a56c3abe7b321f4caf06a0a5e72586cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c3abe7b321f4caf06a0a5e72586cac">&#9670;&nbsp;</a></span>MakeSelfDependentDimensionFinalizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DecisionBuilder* MakeSelfDependentDimensionFinalizer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="routing_8h.html#a50ba9dd11704e0be7edaa9e9f24142ff">RoutingDimension</a> *&#160;</td>
          <td class="paramname"><em>dimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MakeSelfDependentDimensionFinalizer is a finalizer for the slacks of a self-dependent dimension. </p>
<p>It makes an extensive use of the caches of the state dependent transits. In detail, MakeSelfDependentDimensionFinalizer returns a composition of a local search decision builder with a greedy descent operator for the cumul of the start of each route and a guided slack finalizer. Provided there are no time windows and the maximum slacks are large enough, once the cumul of the start of route is fixed, the guided finalizer can find optimal values of the slacks for the rest of the route in time proportional to the length of the route. Therefore the composed finalizer generally works in time O(log(t)*n*m), where t is the latest possible departute time, n is the number of nodes in the network and m is the number of vehicles. </p>

</div>
</div>
<a id="a3af1158b77552d60afc3f0473de3892d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af1158b77552d60afc3f0473de3892d">&#9670;&nbsp;</a></span>MutablePreAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assignment* MutablePreAssignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00936">936</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a46a69d9769aa92122c7e5e20f49e3da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a69d9769aa92122c7e5e20f49e3da3">&#9670;&nbsp;</a></span>Next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 Next </td>
          <td>(</td>
          <td class="paramtype">const Assignment &amp;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment inspection Returns the variable index of the node directly after the node corresponding to 'index' in 'assignment'. </p>

</div>
</div>
<a id="aad154b31953d2b467bbac3e4ac696cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad154b31953d2b467bbac3e4ac696cd6">&#9670;&nbsp;</a></span>Nexts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;IntVar*&gt;&amp; Nexts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variables. </p>
<p>Returns all next variables of the model, such that Nexts(i) is the next variable of the node corresponding to i. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01059">1059</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a66fb44c05f9875685e9c332fbdfb643b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fb44c05f9875685e9c332fbdfb643b">&#9670;&nbsp;</a></span>NextVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntVar* NextVar </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next variable of the node corresponding to index. </p>
<p>Note that NextVar(index) == index is equivalent to ActiveVar(index) == 0. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01066">1066</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a0f38add802397fef1f57b7d90ccd5aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f38add802397fef1f57b7d90ccd5aef">&#9670;&nbsp;</a></span>nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sizes and indices Returns the number of nodes in the model. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01180">1180</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a5cc6e6b421a6dfc8650cc38e116fff03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc6e6b421a6dfc8650cc38e116fff03">&#9670;&nbsp;</a></span>PackCumulsOfOptimizerDimensionsFromAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Assignment* PackCumulsOfOptimizerDimensionsFromAssignment </td>
          <td>(</td>
          <td class="paramtype">const Assignment *&#160;</td>
          <td class="paramname"><em>original_assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Duration&#160;</td>
          <td class="paramname"><em>duration_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For every dimension in the model's dimensions_for_local/global_optimizer_, this method tries to pack the cumul values of the dimension, such that: </p>
<ul>
<li>The cumul costs (span costs, soft lower and upper bound costs, etc) are minimized.</li>
<li>The cumuls of the ends of the routes are minimized for this given minimal cumul cost.</li>
<li>Given these minimal end cumuls, the route start cumuls are maximized. Returns the assignment resulting from allocating these packed cumuls with the solver, and nullptr if these cumuls could not be set by the solver. </li>
</ul>

</div>
</div>
<a id="ae033bc458ffce1ecc4874f3e212896f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae033bc458ffce1ecc4874f3e212896f7">&#9670;&nbsp;</a></span>PreAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Assignment* const PreAssignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an assignment used to fix some of the variables of the problem. </p>
<p>In practice, this assignment locks partial routes of the problem. This can be used in the context of locking the parts of the routes which have already been driven in online routing problems. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00935">935</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a74e3de2ce73322e1860be0713c07c33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e3de2ce73322e1860be0713c07c33e">&#9670;&nbsp;</a></span>ReadAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assignment* ReadAssignment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an assignment from a file and returns the current solution. </p>
<p>Returns nullptr if the file cannot be opened or if the assignment is not valid. </p>

</div>
</div>
<a id="a97dca877bb5083a72c147628a8439770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97dca877bb5083a72c147628a8439770">&#9670;&nbsp;</a></span>ReadAssignmentFromRoutes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assignment* ReadAssignmentFromRoutes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int64 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>routes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_inactive_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores the routes as the current solution. </p>
<p>Returns nullptr if the solution cannot be restored (routes do not contain a valid solution). Note that calling this method will run the solver to assign values to the dimension variables; this may take considerable amount of time, especially when using dimensions with slack. </p>

</div>
</div>
<a id="adb0524e488894fa8f88764c74abb31f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0524e488894fa8f88764c74abb31f5">&#9670;&nbsp;</a></span>RemainingTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Duration RemainingTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time left in the search limit. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01173">1173</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a566ddf59563c1b37e8c178b1805aa0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566ddf59563c1b37e8c178b1805aa0f4">&#9670;&nbsp;</a></span>RestoreAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assignment* RestoreAssignment </td>
          <td>(</td>
          <td class="paramtype">const Assignment &amp;&#160;</td>
          <td class="paramname"><em>solution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores an assignment as a solution in the routing model and returns the new solution. </p>
<p>Returns nullptr if the assignment is not valid. </p>

</div>
</div>
<a id="a78f7f1cb8b08b7ec1d477a14447bd8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f7f1cb8b08b7ec1d477a14447bd8d4">&#9670;&nbsp;</a></span>RoutesToAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RoutesToAssignment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int64 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>routes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_inactive_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>close_routes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Assignment *const&#160;</td>
          <td class="paramname"><em>assignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills an assignment from a specification of the routes of the vehicles. </p>
<p>The routes are specified as lists of variable indices that appear on the routes of the vehicles. The indices of the outer vector in 'routes' correspond to vehicles IDs, the inner vector contains the variable indices on the routes for the given vehicle. The inner vectors must not contain the start and end indices, as these are determined by the routing model. Sets the value of NextVars in the assignment, adding the variables to the assignment if necessary. The method does not touch other variables in the assignment. The method can only be called after the model is closed. With ignore_inactive_indices set to false, this method will fail (return nullptr) in case some of the route contain indices that are deactivated in the model; when set to true, these indices will be skipped. Returns true if routes were successfully loaded. However, such assignment still might not be a valid solution to the routing problem due to more complex constraints; it is advisible to call <a class="el" href="routing_8h.html#a5f32c22c620c811754ba7b6f977db864" title="Returns the underlying constraint solver.">solver()</a>-&gt;CheckSolution() afterwards. </p>

</div>
</div>
<a id="aa3d92ac74ce8d3e57551677e88e2c846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d92ac74ce8d3e57551677e88e2c846">&#9670;&nbsp;</a></span>SetAmortizedCostFactorsOfAllVehicles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quadratic_cost_factor_of_vehicle_* [v] square of length of route v void SetAmortizedCostFactorsOfAllVehicles </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>linear_cost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>quadratic_cost_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following methods set the linear and quadratic cost factors of vehicles (must be positive values). </p>
<p>The default value of these parameters is zero for all vehicles. When set, the cost_ of the model will contain terms aiming at reducing the number of vehicles used in the model, by adding the following to the objective for every vehicle v: INDICATOR(v used in the model) * [linear_cost_factor_of_vehicle_[v] i.e. for every used vehicle, we add the linear factor as fixed cost, and subtract the square of the route length multiplied by the quadratic factor. This second term aims at making the routes as dense as possible.</p>
<p>Sets the linear and quadratic cost factor of all vehicles. </p>

</div>
</div>
<a id="ae1acdfe3dcf892d108d2a2ecab94e936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1acdfe3dcf892d108d2a2ecab94e936">&#9670;&nbsp;</a></span>SetAmortizedCostFactorsOfVehicle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetAmortizedCostFactorsOfVehicle </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>linear_cost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>quadratic_cost_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vehicle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the linear and quadratic cost factor of the given vehicle. </p>

</div>
</div>
<a id="ab8d61705aa4291d2cd437ba0a7dfccbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d61705aa4291d2cd437ba0a7dfccbf">&#9670;&nbsp;</a></span>SetArcCostEvaluatorOfAllVehicles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetArcCostEvaluatorOfAllVehicles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>evaluator_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the cost function of the model such that the cost of a segment of a route between node 'from' and 'to' is evaluator(from, to), whatever the route or vehicle performing the route. </p>

</div>
</div>
<a id="ae75d9f49c157b7784fc8baa7d623ee35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75d9f49c157b7784fc8baa7d623ee35">&#9670;&nbsp;</a></span>SetArcCostEvaluatorOfVehicle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetArcCostEvaluatorOfVehicle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>evaluator_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vehicle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the cost function for a given vehicle route. </p>

</div>
</div>
<a id="ac1a2ab630f6b13644ca6853c7893f413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a2ab630f6b13644ca6853c7893f413">&#9670;&nbsp;</a></span>SetAssignmentFromOtherModelAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetAssignmentFromOtherModelAssignment </td>
          <td>(</td>
          <td class="paramtype">Assignment *&#160;</td>
          <td class="paramname"><em>target_assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RoutingModel *&#160;</td>
          <td class="paramname"><em>source_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Assignment *&#160;</td>
          <td class="paramname"><em>source_assignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a "source_model" and its "source_assignment", resets "target_assignment" with the IntVar variables (nexts_, and vehicle_vars_ if costs aren't homogeneous across vehicles) of "this" model, with the values set according to those in "other_assignment". </p>
<p>The objective_element of target_assignment is set to this-&gt;cost_. </p>

</div>
</div>
<a id="ab69145472d51d341f82d3ad29e9c6be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69145472d51d341f82d3ad29e9c6be2">&#9670;&nbsp;</a></span>SetFirstSolutionEvaluator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFirstSolutionEvaluator </td>
          <td>(</td>
          <td class="paramtype">Solver::IndexEvaluator2&#160;</td>
          <td class="paramname"><em>evaluator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes ownership of evaluator. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00845">845</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a07b796e9f91ee5b4c5e99c7f23e2f743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b796e9f91ee5b4c5e99c7f23e2f743">&#9670;&nbsp;</a></span>SetFixedCostOfAllVehicles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFixedCostOfAllVehicles </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>cost</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fixed cost of all vehicle routes. </p>
<p>It is equivalent to calling SetFixedCostOfVehicle on all vehicle routes. </p>

</div>
</div>
<a id="a4e8f5b5f090cf084347eda6eb803813a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8f5b5f090cf084347eda6eb803813a">&#9670;&nbsp;</a></span>SetFixedCostOfVehicle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFixedCostOfVehicle </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vehicle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fixed cost of one vehicle route. </p>

</div>
</div>
<a id="a700982f228080c6278eb5a2f7f06f31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700982f228080c6278eb5a2f7f06f31d">&#9670;&nbsp;</a></span>SetSweepArranger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetSweepArranger </td>
          <td>(</td>
          <td class="paramtype">SweepArranger *&#160;</td>
          <td class="paramname"><em>sweep_arranger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000033">Todo:</a></b></dt><dd>(user): Revisit if coordinates are added to the RoutingModel class. </dd></dl>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01018">1018</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a7e2d405cde11bc4a08d752d0e669912c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2d405cde11bc4a08d752d0e669912c">&#9670;&nbsp;</a></span>SetTabuVarsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetTabuVarsCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="routing_8h.html#a0e106a97f0156868f1d1c741b283793e">GetTabuVarsCallback</a>&#160;</td>
          <td class="paramname"><em>tabu_var_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a354dd8c252cf59b748602b342db6019d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354dd8c252cf59b748602b342db6019d">&#9670;&nbsp;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of next variables in the model. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01184">1184</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a562e4c0a80f7f4eda9573a482af288d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562e4c0a80f7f4eda9573a482af288d1">&#9670;&nbsp;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Assignment* Solve </td>
          <td>(</td>
          <td class="paramtype">const Assignment *&#160;</td>
          <td class="paramname"><em>assignment</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the current routing model; closes the current model. </p>
<p>This is equivalent to calling SolveWithParameters(DefaultRoutingSearchParameters()) or SolveFromAssignmentWithParameters(assignment, <a class="el" href="namespaceoperations__research.html#adcac4a11f1e4d36ceb47f7251461487d">DefaultRoutingSearchParameters()</a>). </p>

</div>
</div>
<a id="a56e06d63a6d3792ab5cd64e51724632b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e06d63a6d3792ab5cd64e51724632b">&#9670;&nbsp;</a></span>SolveFromAssignmentWithParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Assignment* SolveFromAssignmentWithParameters </td>
          <td>(</td>
          <td class="paramtype">const Assignment *&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RoutingSearchParameters &amp;&#160;</td>
          <td class="paramname"><em>search_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const Assignment * &gt; *&#160;</td>
          <td class="paramname"><em>solutions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f32c22c620c811754ba7b6f977db864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f32c22c620c811754ba7b6f977db864">&#9670;&nbsp;</a></span>solver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Solver* solver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the underlying constraint solver. </p>
<p>Can be used to add extra constraints and/or modify search algoithms. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01164">1164</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="af4e97be54c31d45d312d168ce1c8ba6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e97be54c31d45d312d168ce1c8ba6f">&#9670;&nbsp;</a></span>SolveWithParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Assignment* SolveWithParameters </td>
          <td>(</td>
          <td class="paramtype">const RoutingSearchParameters &amp;&#160;</td>
          <td class="paramname"><em>search_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const Assignment * &gt; *&#160;</td>
          <td class="paramname"><em>solutions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the current routing model with the given parameters. </p>
<p>If 'solutions' is specified, it will contain the k best solutions found during the search (from worst to best, including the one returned by this method), where k corresponds to the 'number_of_solutions_to_collect' in 'search_parameters'. </p><dl class="section note"><dt>Note</dt><dd>the Assignment returned by the method and the ones in solutions are owned by the underlying solver and should not be deleted. </dd></dl>

</div>
</div>
<a id="acbdbdfc9491ef0586459d38cc5ef4cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbdbdfc9491ef0586459d38cc5ef4cb8">&#9670;&nbsp;</a></span>Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 Start </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vehicle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Model inspection. </p>
<p>Returns the variable index of the starting node of a vehicle route. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01039">1039</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="adb1490a44086db009cdb51f854a02a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1490a44086db009cdb51f854a02a65">&#9670;&nbsp;</a></span>status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Status status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current status of the routing model. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l00912">912</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a71815ec83f6605bddb11578ebb835aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71815ec83f6605bddb11578ebb835aae">&#9670;&nbsp;</a></span>sweep_arranger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SweepArranger* sweep_arranger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sweep arranger to be used by routing heuristics. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01022">1022</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a3600327c657a0c83430d7bd9566e9ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3600327c657a0c83430d7bd9566e9ab6">&#9670;&nbsp;</a></span>UnperformedPenalty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 UnperformedPenalty </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>var_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the "unperformed" penalty of a node. </p>
<p>This is only well defined if the node is only part of a single Disjunction involving only itself, and that disjunction has a penalty. In all other cases, including forced active nodes, this returns 0. </p>

</div>
</div>
<a id="ae8364b53d49a5b46e994d41124c4ffd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8364b53d49a5b46e994d41124c4ffd6">&#9670;&nbsp;</a></span>UnperformedPenaltyOrValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 UnperformedPenaltyOrValue </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>var_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above except that it returns default_value instead of 0 when penalty is not well defined (default value is passed as first argument to simplify the usage of the method in a callback). </p>

</div>
</div>
<a id="a7c2d33eef73401442fd9f2e205056c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2d33eef73401442fd9f2e205056c73">&#9670;&nbsp;</a></span>VehicleCostsConsideredVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntVar* VehicleCostsConsideredVar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vehicle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the variable specifying whether or not costs are considered for vehicle. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01071">1071</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="abd33c037942b971eeefad43c6022c20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd33c037942b971eeefad43c6022c20e">&#9670;&nbsp;</a></span>VehicleIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VehicleIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vehicle of the given start/end index, and -1 if the given index is not a vehicle start/end. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01048">1048</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="aa9e7ba89833775f29889744fe9480d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e7ba89833775f29889744fe9480d29">&#9670;&nbsp;</a></span>vehicles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vehicles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of vehicle routes in the model. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01182">1182</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a8cded3d3d6746c179a8ec0eddad24342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cded3d3d6746c179a8ec0eddad24342">&#9670;&nbsp;</a></span>VehicleVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntVar* VehicleVar </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vehicle variable of the node corresponding to index. </p>
<p>Note that VehicleVar(index) == -1 is equivalent to ActiveVar(index) == 0. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01076">1076</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="a80572a238b48c2cefe38409e7544f161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80572a238b48c2cefe38409e7544f161">&#9670;&nbsp;</a></span>VehicleVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;IntVar*&gt;&amp; VehicleVars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all vehicle variables of the model, such that VehicleVars(i) is the vehicle variable of the node corresponding to i. </p>

<p class="definition">Definition at line <a class="el" href="routing_8h_source.html#l01062">1062</a> of file <a class="el" href="routing_8h_source.html">routing.h</a>.</p>

</div>
</div>
<a id="acfcef421e8c8cd243157543f741d6a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcef421e8c8cd243157543f741d6a73">&#9670;&nbsp;</a></span>WriteAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WriteAssignment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the current solution to a file containing an AssignmentProto. </p>
<p>Returns false if the file cannot be opened or if there is no current solution. </p>

</div>
</div>
</div><!-- contents -->
        </div>
        <div id="footer-container">
            <div id="footer">
            </div>
        </div>
    </body>
</html>
