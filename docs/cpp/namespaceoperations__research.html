<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>OR-Tools</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">OR-Tools 7.1@</span>
            </div>
        </div>
        <div id="content">
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">operations_research Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceoperations__research_1_1or__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1or__internal.html">or_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceoperations__research_1_1sat"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1AnnotatedGraphBuildManager.html">AnnotatedGraphBuildManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ArcFunctorOrderingByTailAndHead.html">ArcFunctorOrderingByTailAndHead</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ArcIndexOrderingByTailNode.html">ArcIndexOrderingByTailNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logically this class should be defined inside OptimizeGraphLayout, but compilation fails if we do that because C++98 doesn't allow instantiation of member templates with function-scoped types as template parameters, which in turn is because those function-scoped types lack linkage.  <a href="classoperations__research_1_1ArcIndexOrderingByTailNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ArgumentHolder.html">ArgumentHolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument Holder: useful when visiting a model.  <a href="classoperations__research_1_1ArgumentHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ArrayWithOffset.html">ArrayWithOffset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Utility Class for Callbacks --&mdash;  <a href="classoperations__research_1_1ArrayWithOffset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Assignment.html">Assignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1Assignment.html" title="--— Assignment --—">Assignment</a> --&mdash;  <a href="classoperations__research_1_1Assignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1AssignmentContainer.html">AssignmentContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1Assignment.html" title="--— Assignment --—">Assignment</a> element container --&mdash;  <a href="classoperations__research_1_1AssignmentContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1AssignmentElement.html">AssignmentElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">------&mdash; Assignments -------------------------&mdash;  <a href="classoperations__research_1_1AssignmentElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1BaseIntExpr.html">BaseIntExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for all expressions that are not variables.  <a href="classoperations__research_1_1BaseIntExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1BaseLns.html">BaseLns</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Base Large Neighborhood Search operator class -&mdash;  <a href="classoperations__research_1_1BaseLns.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1BaseObject.html">BaseObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful Search and Modeling Objects.  <a href="classoperations__research_1_1BaseObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1BooleanVar.html">BooleanVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Boolean Variable --&mdash;  <a href="classoperations__research_1_1BooleanVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1BronKerboschAlgorithm.html">BronKerboschAlgorithm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Bron-Kerbosch algorithm for finding maximal cliques.  <a href="classoperations__research_1_1BronKerboschAlgorithm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1CallMethod0.html">CallMethod0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classoperations__research_1_1Demon.html" title="A Demon is the base element of a propagation queue.">Demon</a> proxy to a method on the constraint with no arguments.  <a href="classoperations__research_1_1CallMethod0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1CallMethod1.html">CallMethod1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classoperations__research_1_1Demon.html" title="A Demon is the base element of a propagation queue.">Demon</a> proxy to a method on the constraint with one argument.  <a href="classoperations__research_1_1CallMethod1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1CallMethod2.html">CallMethod2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classoperations__research_1_1Demon.html" title="A Demon is the base element of a propagation queue.">Demon</a> proxy to a method on the constraint with two arguments.  <a href="classoperations__research_1_1CallMethod2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1CallMethod3.html">CallMethod3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classoperations__research_1_1Demon.html" title="A Demon is the base element of a propagation queue.">Demon</a> proxy to a method on the constraint with three arguments.  <a href="classoperations__research_1_1CallMethod3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1CastConstraint.html">CastConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast constraints are special channeling constraints designed to keep a variable in sync with an expression.  <a href="classoperations__research_1_1CastConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ChangeValue.html">ChangeValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1ChangeValue.html" title="--— ChangeValue Operators --—">ChangeValue</a> Operators --&mdash;  <a href="classoperations__research_1_1ChangeValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ChristofidesPathSolver.html">ChristofidesPathSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1ClosedInterval.html">ClosedInterval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a closed interval [start, end]. We must have start &lt;= end.  <a href="structoperations__research_1_1ClosedInterval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ConnectedComponents.html">ConnectedComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class implementing a Union-Find algorithm with path compression for maintaining the connected components of a graph.  <a href="classoperations__research_1_1ConnectedComponents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Constraint.html">Constraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint is the main modeling object.  <a href="classoperations__research_1_1Constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1CostValueCycleHandler.html">CostValueCycleHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Decision.html">Decision</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classoperations__research_1_1Decision.html" title="A Decision represents a choice point in the search tree.">Decision</a> represents a choice point in the search tree.  <a href="classoperations__research_1_1Decision.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DecisionBuilder.html">DecisionBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classoperations__research_1_1DecisionBuilder.html" title="A DecisionBuilder is responsible for creating the search tree.">DecisionBuilder</a> is responsible for creating the search tree.  <a href="classoperations__research_1_1DecisionBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DecisionVisitor.html">DecisionVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classoperations__research_1_1DecisionVisitor.html" title="A DecisionVisitor is used to inspect a decision.">DecisionVisitor</a> is used to inspect a decision.  <a href="classoperations__research_1_1DecisionVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1DefaultPhaseParameters.html">DefaultPhaseParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct holds all parameters for the default search.  <a href="structoperations__research_1_1DefaultPhaseParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DelayedCallMethod0.html">DelayedCallMethod0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-priority demon proxy to a method on the constraint with no arguments.  <a href="classoperations__research_1_1DelayedCallMethod0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DelayedCallMethod1.html">DelayedCallMethod1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-priority demon proxy to a method on the constraint with one argument.  <a href="classoperations__research_1_1DelayedCallMethod1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DelayedCallMethod2.html">DelayedCallMethod2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-priority demon proxy to a method on the constraint with two arguments.  <a href="classoperations__research_1_1DelayedCallMethod2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classoperations__research_1_1Demon.html" title="A Demon is the base element of a propagation queue.">Demon</a> is the base element of a propagation queue.  <a href="classoperations__research_1_1Demon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DimensionCumulOptimizerCore.html">DimensionCumulOptimizerCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes to solve dimension cumul placement (aka scheduling) problems using linear programming.  <a href="classoperations__research_1_1DimensionCumulOptimizerCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DisjunctiveConstraint.html">DisjunctiveConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Disjunctive <a class="el" href="classoperations__research_1_1Constraint.html" title="A constraint is the main modeling object.">Constraint</a> --&mdash;  <a href="classoperations__research_1_1DisjunctiveConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Domain.html">Domain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We call "domain" any subset of Int64 = [kint64min, kint64max].  <a href="classoperations__research_1_1Domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1EbertGraph.html">EbertGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declarations.  <a href="classoperations__research_1_1EbertGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1EbertGraphBase.html">EbertGraphBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for the base class that holds the functionality that exists in common between the EbertGraph&lt;&gt; template and the ForwardEbertGraph&lt;&gt; template.  <a href="classoperations__research_1_1EbertGraphBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ElementIterator.html">ElementIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ExchangeSubtrip.html">ExchangeSubtrip</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1FirstSolutionStrategy.html">FirstSolutionStrategy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ForwardEbertGraph.html">ForwardEbertGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward-star-only graph representation for greater efficiency in those algorithms that don't need reverse arcs.  <a href="classoperations__research_1_1ForwardEbertGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ForwardStaticGraph.html">ForwardStaticGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1GenericMaxFlow.html">GenericMaxFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="classoperations__research_1_1GenericMaxFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1GenericMinCostFlow.html">GenericMinCostFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="classoperations__research_1_1GenericMinCostFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1GlobalDimensionCumulOptimizer.html">GlobalDimensionCumulOptimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1graph__traits.html">graph_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits for <a class="el" href="classoperations__research_1_1EbertGraphBase.html" title="A template for the base class that holds the functionality that exists in common between the EbertGra...">EbertGraphBase</a> types, for use in testing and clients that work with both forward-only and forward/reverse graphs.  <a href="structoperations__research_1_1graph__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1graph__traits_3_01ForwardEbertGraph_3_01NodeIndexType_00_01ArcIndexType_01_4_01_4.html">graph_traits&lt; ForwardEbertGraph&lt; NodeIndexType, ArcIndexType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1graph__traits_3_01ForwardStaticGraph_3_01NodeIndexType_00_01ArcIndexType_01_4_01_4.html">graph_traits&lt; ForwardStaticGraph&lt; NodeIndexType, ArcIndexType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1Graphs.html">Graphs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since StarGraph does not have exactly the same interface as the other graphs, we define a correspondence there.  <a href="structoperations__research_1_1Graphs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1Graphs_3_01operations__research_1_1StarGraph_01_4.html">Graphs&lt; operations_research::StarGraph &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html">HamiltonianPathSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1IndexPairSwapActiveOperator.html">IndexPairSwapActiveOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator which inserts inactive nodes into a path and makes a pair of active nodes inactive.  <a href="classoperations__research_1_1IndexPairSwapActiveOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1InitAndGetValues.html">InitAndGetValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to encapsulate an <a class="el" href="classoperations__research_1_1IntVarIterator.html" title="The class Iterator has two direct subclasses.">IntVarIterator</a> and use it in a range-based loop.  <a href="classoperations__research_1_1InitAndGetValues.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1IntervalVar.html">IntervalVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">-------&mdash; Interval Var -------&mdash;  <a href="classoperations__research_1_1IntervalVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1IntervalVarElement.html">IntervalVarElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1IntervalVarElement.html" title="--— IntervalVarElement --—">IntervalVarElement</a> --&mdash;  <a href="classoperations__research_1_1IntervalVarElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1IntExpr.html">IntExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class <a class="el" href="classoperations__research_1_1IntExpr.html" title="The class IntExpr is the base of all integer expressions in constraint programming.">IntExpr</a> is the base of all integer expressions in constraint programming.  <a href="classoperations__research_1_1IntExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class <a class="el" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a> is a subset of <a class="el" href="classoperations__research_1_1IntExpr.html" title="The class IntExpr is the base of all integer expressions in constraint programming.">IntExpr</a>.  <a href="classoperations__research_1_1IntVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1IntVarElement.html">IntVarElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1IntVarElement.html" title="--— IntVarElement --—">IntVarElement</a> --&mdash;  <a href="classoperations__research_1_1IntVarElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1IntVarIterator.html">IntVarIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class Iterator has two direct subclasses.  <a href="classoperations__research_1_1IntVarIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1IntVarLocalSearchFilter.html">IntVarLocalSearchFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1IntVarLocalSearchFilter.html" title="--— IntVarLocalSearchFilter --—">IntVarLocalSearchFilter</a> --&mdash;  <a href="classoperations__research_1_1IntVarLocalSearchFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1IntVarLocalSearchHandler.html">IntVarLocalSearchHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Base operator class for operators manipulating IntVars --&mdash;  <a href="classoperations__research_1_1IntVarLocalSearchHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1IntVarLocalSearchOperator.html">IntVarLocalSearchOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classoperations__research_1_1LocalSearchOperator.html" title="-------— Local search operators -------—">LocalSearchOperator</a> built from an array of IntVars which specifies the scope of the operator.  <a href="classoperations__research_1_1IntVarLocalSearchOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LatticeMemoryManager.html">LatticeMemoryManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Dynamic Programming (DP) algorithm memorizes the values f(set, node) for node in set, for all the subsets of cardinality &lt;= max_card_.  <a href="classoperations__research_1_1LatticeMemoryManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LightPairRelocateOperator.html">LightPairRelocateOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classoperations__research_1_1LinearExpr.html" title="LinearExpr models a quantity that is linear in the decision variables (MPVariable) of an optimization...">LinearExpr</a> models a quantity that is linear in the decision variables (MPVariable) of an optimization problem, i.e.  <a href="classoperations__research_1_1LinearExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression of the form: lower_bound &lt;= sum_{i in S} a_i*x_i &lt;= upper_bound.  <a href="classoperations__research_1_1LinearRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LinearSumAssignment.html">LinearSumAssignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class does not take ownership of its underlying graph.  <a href="classoperations__research_1_1LinearSumAssignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LocalDimensionCumulOptimizer.html">LocalDimensionCumulOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to compute optimal values for dimension cumuls of routes, minimizing cumul soft lower and upper bound costs, and vehicle span costs of a route.  <a href="classoperations__research_1_1LocalDimensionCumulOptimizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LocalSearchFilter.html">LocalSearchFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Local Search Filters ---&mdash;  <a href="classoperations__research_1_1LocalSearchFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LocalSearchFilterManager.html">LocalSearchFilterManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter manager: when a move is made, filters are executed to decide whether the solution is feasible and compute parts of the new cost.  <a href="classoperations__research_1_1LocalSearchFilterManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LocalSearchMetaheuristic.html">LocalSearchMetaheuristic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LocalSearchMonitor.html">LocalSearchMonitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">-------&mdash; <a class="el" href="classoperations__research_1_1LocalSearchMonitor.html" title="-------— LocalSearchMonitor -------—">LocalSearchMonitor</a> -------&mdash;  <a href="classoperations__research_1_1LocalSearchMonitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LocalSearchOperator.html">LocalSearchOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">-------&mdash; Local search operators -------&mdash;  <a href="classoperations__research_1_1LocalSearchOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MakePairActiveOperator.html">MakePairActiveOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair-based neighborhood operators, designed to move nodes by pairs (pairs are static and given).  <a href="classoperations__research_1_1MakePairActiveOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MakePairInactiveOperator.html">MakePairInactiveOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator which makes pairs of active nodes inactive.  <a href="classoperations__research_1_1MakePairInactiveOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MakeRelocateNeighborsOperator.html">MakeRelocateNeighborsOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocate neighborhood which moves chains of neighbors.  <a href="classoperations__research_1_1MakeRelocateNeighborsOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MaxFlow.html">MaxFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instance <a class="el" href="classoperations__research_1_1MaxFlow.html" title="Default instance MaxFlow that uses StarGraph.">MaxFlow</a> that uses StarGraph.  <a href="classoperations__research_1_1MaxFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MaxFlowStatusClass.html">MaxFlowStatusClass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We want an enum for the Status of a max flow run, and we want this enum to be scoped under GenericMaxFlow&lt;&gt;.  <a href="classoperations__research_1_1MaxFlowStatusClass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MinCostFlow.html">MinCostFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="classoperations__research_1_1MinCostFlow.html" title="Default MinCostFlow instance that uses StarGraph.">MinCostFlow</a> instance that uses StarGraph.  <a href="classoperations__research_1_1MinCostFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MinCostFlowBase.html">MinCostFlowBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different statuses for a solved problem.  <a href="classoperations__research_1_1MinCostFlowBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ModelCache.html">ModelCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a complete cache for model elements: expressions and constraints.  <a href="classoperations__research_1_1ModelCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ModelParser.html">ModelParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model Parser.  <a href="classoperations__research_1_1ModelParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ModelVisitor.html">ModelVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model visitor.  <a href="classoperations__research_1_1ModelVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPConstraintProto.html">MPConstraintProto</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPGeneralConstraintProto.html">MPGeneralConstraintProto</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPIndicatorConstraint.html">MPIndicatorConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPModelRequest.html">MPModelRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolutionResponse.html">MPSolutionResponse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolverCommonParameters.html">MPSolverCommonParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPVariableProto.html">MPVariableProto</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1NumericalRev.html">NumericalRev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Rev&lt;T&gt; which adds numerical operations.  <a href="classoperations__research_1_1NumericalRev.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1NumericalRevArray.html">NumericalRevArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of RevArray&lt;T&gt; which adds numerical operations.  <a href="classoperations__research_1_1NumericalRevArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1OptimizeVar.html">OptimizeVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">-------&mdash; Objective Management -------&mdash;  <a href="classoperations__research_1_1OptimizeVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1OptionalDouble.html">OptionalDouble</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Pack.html">Pack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">-------&mdash; <a class="el" href="classoperations__research_1_1Pack.html" title="-------— Pack Constraint -------—">Pack</a> <a class="el" href="classoperations__research_1_1Constraint.html" title="A constraint is the main modeling object.">Constraint</a> -------&mdash;  <a href="classoperations__research_1_1Pack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PairExchangeOperator.html">PairExchangeOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator which exchanges the position of two pairs; for both pairs the first node of the pair must be before the second node on the same path.  <a href="classoperations__research_1_1PairExchangeOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PairExchangeRelocateOperator.html">PairExchangeRelocateOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator which exchanges the paths of two pairs (path have to be different).  <a href="classoperations__research_1_1PairExchangeRelocateOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PairNodeSwapActiveOperator.html">PairNodeSwapActiveOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator which inserts pairs of inactive nodes into a path and makes an active node inactive.  <a href="classoperations__research_1_1PairNodeSwapActiveOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PairRelocateOperator.html">PairRelocateOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator which moves a pair of nodes to another position where the first node of the pair must be before the second node on the same path.  <a href="classoperations__research_1_1PairRelocateOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PartialVariableAssignment.html">PartialVariableAssignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PathOperator.html">PathOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Path-based Operators --&mdash;  <a href="classoperations__research_1_1PathOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PathWithPreviousNodesOperator.html">PathWithPreviousNodesOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple <a class="el" href="classoperations__research_1_1PathOperator.html" title="--— Path-based Operators --—">PathOperator</a> wrapper that also stores the current previous nodes, and is thus able to provide the "Prev" and "IsPathStart" functions.  <a href="classoperations__research_1_1PathWithPreviousNodesOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PermutationIndexComparisonByArcHead.html">PermutationIndexComparisonByArcHead</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PriorityQueueWithRestrictedPush.html">PriorityQueueWithRestrictedPush</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specific but efficient priority queue implementation.  <a href="classoperations__research_1_1PriorityQueueWithRestrictedPush.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PropagationBaseObject.html">PropagationBaseObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classoperations__research_1_1PropagationBaseObject.html" title="The PropagationBaseObject is a subclass of BaseObject that is also friend to the Solver class.">PropagationBaseObject</a> is a subclass of <a class="el" href="classoperations__research_1_1BaseObject.html" title="Useful Search and Modeling Objects.">BaseObject</a> that is also friend to the <a class="el" href="classoperations__research_1_1Solver.html" title="Solver Class.">Solver</a> class.  <a href="classoperations__research_1_1PropagationBaseObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PropagationMonitor.html">PropagationMonitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">-------&mdash; <a class="el" href="classoperations__research_1_1PropagationMonitor.html" title="-------— PropagationMonitor -------—">PropagationMonitor</a> -------&mdash;  <a href="classoperations__research_1_1PropagationMonitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PruningHamiltonianSolver.html">PruningHamiltonianSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RegularLimit.html">RegularLimit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Regular Limit --&mdash;  <a href="classoperations__research_1_1RegularLimit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RelocateExpensiveChain.html">RelocateExpensiveChain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1RelocateExpensiveChain.html" title="--— RelocateExpensiveChain --— Operator which relocates the most expensive subchains (given a cost ca...">RelocateExpensiveChain</a> --&mdash; Operator which relocates the most expensive subchains (given a cost callback) in a path to a different position.  <a href="classoperations__research_1_1RelocateExpensiveChain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RelocateSubtrip.html">RelocateSubtrip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to move subtrips after an insertion node.  <a href="classoperations__research_1_1RelocateSubtrip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Rev.html">Rev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds reversibility to a POD type.  <a href="classoperations__research_1_1Rev.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RevArray.html">RevArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reversible array of POD types.  <a href="classoperations__research_1_1RevArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RevBitMatrix.html">RevBitMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix version of the <a class="el" href="classoperations__research_1_1RevBitSet.html" title="This class represents a reversible bitset.">RevBitSet</a> class.  <a href="classoperations__research_1_1RevBitMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RevBitSet.html">RevBitSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a reversible bitset.  <a href="classoperations__research_1_1RevBitSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RevGrowingArray.html">RevGrowingArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a reversible growing array.  <a href="classoperations__research_1_1RevGrowingArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RevImmutableMultiMap.html">RevImmutableMultiMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Immutable Multi Map --&mdash;  <a href="classoperations__research_1_1RevImmutableMultiMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RevIntSet.html">RevIntSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1RevIntSet.html" title="--— RevIntSet --—">RevIntSet</a> --&mdash;  <a href="classoperations__research_1_1RevIntSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RevPartialSequence.html">RevPartialSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1RevPartialSequence.html" title="--— RevPartialSequence --—">RevPartialSequence</a> --&mdash;  <a href="classoperations__research_1_1RevPartialSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RevSwitch.html">RevSwitch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reversible switch that can switch once from false to true.  <a href="classoperations__research_1_1RevSwitch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RoutingModelParameters.html">RoutingModelParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RoutingSearchParameters.html">RoutingSearchParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RoutingSearchParameters__LocalSearchNeighborhoodOperators.html">RoutingSearchParameters_LocalSearchNeighborhoodOperators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SearchLimit.html">SearchLimit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">-------&mdash; Search Limits -------&mdash;  <a href="classoperations__research_1_1SearchLimit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SearchLog.html">SearchLog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">-------&mdash; Search Log ------&mdash;  <a href="classoperations__research_1_1SearchLog.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SearchMonitor.html">SearchMonitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A search monitor is a simple set of callbacks to monitor all search events.  <a href="classoperations__research_1_1SearchMonitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SequenceVar.html">SequenceVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1SequenceVar.html" title="--— SequenceVar --—">SequenceVar</a> --&mdash;  <a href="classoperations__research_1_1SequenceVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SequenceVarElement.html">SequenceVarElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1SequenceVarElement.html" title="--— SequenceVarElement --—">SequenceVarElement</a> --&mdash;  <a href="classoperations__research_1_1SequenceVarElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SequenceVarLocalSearchHandler.html">SequenceVarLocalSearchHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SequenceVarLocalSearchOperator.html">SequenceVarLocalSearchOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Set.html">Set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SetRangeIterator.html">SetRangeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator for sets of increasing corresponding values that have the same cardinality.  <a href="classoperations__research_1_1SetRangeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SetRangeWithCardinality.html">SetRangeWithCardinality</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SimpleMaxFlow.html">SimpleMaxFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple and efficient max-cost flow interface.  <a href="classoperations__research_1_1SimpleMaxFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SimpleMinCostFlow.html">SimpleMinCostFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple and efficient min-cost flow interface.  <a href="classoperations__research_1_1SimpleMinCostFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SimpleRevFIFO.html">SimpleRevFIFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; utility classes --&mdash;  <a href="classoperations__research_1_1SimpleRevFIFO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SmallRevBitSet.html">SmallRevBitSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a small reversible bitset (size &lt;= 64).  <a href="classoperations__research_1_1SmallRevBitSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SolutionCollector.html">SolutionCollector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">-------&mdash; Solution Collectors -------&mdash;  <a href="classoperations__research_1_1SolutionCollector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SolutionPool.html">SolutionPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1SolutionPool.html" title="--— SolutionPool --—">SolutionPool</a> --&mdash;  <a href="classoperations__research_1_1SolutionPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Solver.html">Solver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classoperations__research_1_1Solver.html" title="Solver Class.">Solver</a> Class.  <a href="classoperations__research_1_1Solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html">SortedDisjointIntervalList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a sorted list of disjoint, closed intervals.  <a href="classoperations__research_1_1SortedDisjointIntervalList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1StarGraphBase.html">StarGraphBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SwapIndexPairOperator.html">SwapIndexPairOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator which iterates through each alternative of a set of pairs.  <a href="classoperations__research_1_1SwapIndexPairOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SymmetryBreaker.html">SymmetryBreaker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symmetry breaker is an object that will visit a decision and create the 'symmetrical' decision in return.  <a href="classoperations__research_1_1SymmetryBreaker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1TailArrayManager.html">TailArrayManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1UnsortedNullableRevBitset.html">UnsortedNullableRevBitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a reversible bitset.  <a href="classoperations__research_1_1UnsortedNullableRevBitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1VarLocalSearchOperator.html">VarLocalSearchOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Base operator class for operators manipulating variables --&mdash;  <a href="classoperations__research_1_1VarLocalSearchOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad91551404d4eeb115402e25f8ac599b8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classoperations__research_1_1VarLocalSearchOperator.html">VarLocalSearchOperator</a>&lt; <a class="el" href="classoperations__research_1_1SequenceVar.html">SequenceVar</a>, std::vector&lt; int &gt;, <a class="el" href="classoperations__research_1_1SequenceVarLocalSearchHandler.html">SequenceVarLocalSearchHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad91551404d4eeb115402e25f8ac599b8">SequenceVarLocalSearchOperatorTemplate</a></td></tr>
<tr class="separator:ad91551404d4eeb115402e25f8ac599b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e66c7b62d7c023af6f08912fdc3f9c"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; int64(int64)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a40e66c7b62d7c023af6f08912fdc3f9c">RoutingTransitCallback1</a></td></tr>
<tr class="separator:a40e66c7b62d7c023af6f08912fdc3f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7851f8d6518e3180b9d9f0ec69826e7"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; int64(int64, int64)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ae7851f8d6518e3180b9d9f0ec69826e7">RoutingTransitCallback2</a></td></tr>
<tr class="separator:ae7851f8d6518e3180b9d9f0ec69826e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30af988d402f0f3d36640575ca87153c"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; std::vector&lt; int64 &gt;, std::vector&lt; int64 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a30af988d402f0f3d36640575ca87153c">RoutingIndexPair</a></td></tr>
<tr class="memdesc:a30af988d402f0f3d36640575ca87153c"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOTE(user): keep the "&gt; &gt;" for SWIG.  <a href="#a30af988d402f0f3d36640575ca87153c">More...</a><br /></td></tr>
<tr class="separator:a30af988d402f0f3d36640575ca87153c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114ea14886b902c9cf9b988c4ef12672"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="namespaceoperations__research.html#a30af988d402f0f3d36640575ca87153c">RoutingIndexPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a114ea14886b902c9cf9b988c4ef12672">RoutingIndexPairs</a></td></tr>
<tr class="separator:a114ea14886b902c9cf9b988c4ef12672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e629e35bfa311b31dd7f5065eb834bb"><td class="memItemLeft" align="right" valign="top">typedef int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a></td></tr>
<tr class="memdesc:a0e629e35bfa311b31dd7f5065eb834bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard instantiation of <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html" title="A forward-star-only graph representation for greater efficiency in those algorithms that don&#39;t need r...">ForwardEbertGraph</a> (named 'ForwardStarGraph') of <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> (named 'StarGraph'); and relevant type shortcuts.  <a href="#a0e629e35bfa311b31dd7f5065eb834bb">More...</a><br /></td></tr>
<tr class="separator:a0e629e35bfa311b31dd7f5065eb834bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d858394c5eed1fa21edc3da47047c1"><td class="memItemLeft" align="right" valign="top">typedef int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a></td></tr>
<tr class="separator:a31d858394c5eed1fa21edc3da47047c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5841ff601ab08548afb15c45b2245de7"><td class="memItemLeft" align="right" valign="top">typedef int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a5841ff601ab08548afb15c45b2245de7">FlowQuantity</a></td></tr>
<tr class="separator:a5841ff601ab08548afb15c45b2245de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7950685633ee869aa9471b2ec5fbcfa"><td class="memItemLeft" align="right" valign="top">typedef int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa7950685633ee869aa9471b2ec5fbcfa">CostValue</a></td></tr>
<tr class="separator:aa7950685633ee869aa9471b2ec5fbcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39f15b318a3cba17b1e60e6da51c0d4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classoperations__research_1_1EbertGraph.html">EbertGraph</a>&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>, <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ae39f15b318a3cba17b1e60e6da51c0d4">StarGraph</a></td></tr>
<tr class="separator:ae39f15b318a3cba17b1e60e6da51c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652af62fa5f211aa0c54d7994ca1c504"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html">ForwardEbertGraph</a>&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>, <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a652af62fa5f211aa0c54d7994ca1c504">ForwardStarGraph</a></td></tr>
<tr class="separator:a652af62fa5f211aa0c54d7994ca1c504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7440a08c859325694df19d4d4aee95c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classoperations__research_1_1ForwardStaticGraph.html">ForwardStaticGraph</a>&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>, <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ac7440a08c859325694df19d4d4aee95c">ForwardStarStaticGraph</a></td></tr>
<tr class="separator:ac7440a08c859325694df19d4d4aee95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389e5320fb5bcd0fb99d894488f9820b"><td class="memItemLeft" align="right" valign="top">typedef ZVector&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a389e5320fb5bcd0fb99d894488f9820b">NodeIndexArray</a></td></tr>
<tr class="separator:a389e5320fb5bcd0fb99d894488f9820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79bf252fa6483cd33cbf95170353fb0"><td class="memItemLeft" align="right" valign="top">typedef ZVector&lt; <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa79bf252fa6483cd33cbf95170353fb0">ArcIndexArray</a></td></tr>
<tr class="separator:aa79bf252fa6483cd33cbf95170353fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4fc0319cb4e28ec175fc9163775a6e"><td class="memItemLeft" align="right" valign="top">typedef ZVector&lt; <a class="el" href="namespaceoperations__research.html#a5841ff601ab08548afb15c45b2245de7">FlowQuantity</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a7d4fc0319cb4e28ec175fc9163775a6e">QuantityArray</a></td></tr>
<tr class="separator:a7d4fc0319cb4e28ec175fc9163775a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdee62ecefa0520e530c18a55b083e6d"><td class="memItemLeft" align="right" valign="top">typedef ZVector&lt; <a class="el" href="namespaceoperations__research.html#aa7950685633ee869aa9471b2ec5fbcfa">CostValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#afdee62ecefa0520e530c18a55b083e6d">CostArray</a></td></tr>
<tr class="separator:afdee62ecefa0520e530c18a55b083e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09767b3634289e432c3ce1d7c649666a"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a09767b3634289e432c3ce1d7c649666a">PathNodeIndex</a></td></tr>
<tr class="separator:a09767b3634289e432c3ce1d7c649666a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a744e7cc90d56b2c503520ee1f97fc1db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a744e7cc90d56b2c503520ee1f97fc1db">VarTypes</a> { <br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a744e7cc90d56b2c503520ee1f97fc1dbab4f91414920a046da6b20cd63a2796e6">UNSPECIFIED</a>, 
<a class="el" href="namespaceoperations__research.html#a744e7cc90d56b2c503520ee1f97fc1dba035478726d2dcd2fb9ac77afb5c759cc">DOMAIN_INT_VAR</a>, 
<a class="el" href="namespaceoperations__research.html#a744e7cc90d56b2c503520ee1f97fc1dba79122eee2a14a98d575b0b9ac73b0e42">BOOLEAN_VAR</a>, 
<a class="el" href="namespaceoperations__research.html#a744e7cc90d56b2c503520ee1f97fc1dbad9de5a1ac157ce63c698777275b17787">CONST_VAR</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a744e7cc90d56b2c503520ee1f97fc1dba0cc8439ff5d71bb0c4c981cd04b73d55">VAR_ADD_CST</a>, 
<a class="el" href="namespaceoperations__research.html#a744e7cc90d56b2c503520ee1f97fc1dbaa77c2e49834d223253421d9e3d69c51c">VAR_TIMES_CST</a>, 
<a class="el" href="namespaceoperations__research.html#a744e7cc90d56b2c503520ee1f97fc1dba93697c551d06ce8d37be776116f23f66">CST_SUB_VAR</a>, 
<a class="el" href="namespaceoperations__research.html#a744e7cc90d56b2c503520ee1f97fc1dba9558ccbf57e24d3ddde9bfbf2835e4fe">OPP_VAR</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a744e7cc90d56b2c503520ee1f97fc1dba93b00759c703fe20d9d8a5a75268a69d">TRACE_VAR</a>
<br />
 }</td></tr>
<tr class="memdesc:a744e7cc90d56b2c503520ee1f97fc1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum is used internally to do dynamic typing on subclasses of integer variables.  <a href="namespaceoperations__research.html#a744e7cc90d56b2c503520ee1f97fc1db">More...</a><br /></td></tr>
<tr class="separator:a744e7cc90d56b2c503520ee1f97fc1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d89e69d073dc3036a6de24710b416f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#af2d89e69d073dc3036a6de24710b416f">CliqueResponse</a> { <a class="el" href="namespaceoperations__research.html#af2d89e69d073dc3036a6de24710b416fa2f453cfe638e57e27bb0c9512436111e">CliqueResponse::CONTINUE</a>, 
<a class="el" href="namespaceoperations__research.html#af2d89e69d073dc3036a6de24710b416fa615a46af313786fc4e349f34118be111">CliqueResponse::STOP</a>
 }</td></tr>
<tr class="memdesc:af2d89e69d073dc3036a6de24710b416f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible return values of the callback for reporting cliques.  <a href="namespaceoperations__research.html#af2d89e69d073dc3036a6de24710b416f">More...</a><br /></td></tr>
<tr class="separator:af2d89e69d073dc3036a6de24710b416f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708cf34b342e7d2ed89a3b73dbec4eae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a708cf34b342e7d2ed89a3b73dbec4eae">BronKerboschAlgorithmStatus</a> { <a class="el" href="namespaceoperations__research.html#a708cf34b342e7d2ed89a3b73dbec4eaea8f7afecbc8fbc4cd0f50a57d1172482e">BronKerboschAlgorithmStatus::COMPLETED</a>, 
<a class="el" href="namespaceoperations__research.html#a708cf34b342e7d2ed89a3b73dbec4eaea658f2cadfdf09b6046246e9314f7cd43">BronKerboschAlgorithmStatus::INTERRUPTED</a>
 }</td></tr>
<tr class="memdesc:a708cf34b342e7d2ed89a3b73dbec4eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status value returned by BronKerboschAlgorithm::Run and BronKerboschAlgorithm::RunIterations.  <a href="namespaceoperations__research.html#a708cf34b342e7d2ed89a3b73dbec4eae">More...</a><br /></td></tr>
<tr class="separator:a708cf34b342e7d2ed89a3b73dbec4eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab567c87506c164323ce22036cf4c362c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362c">FirstSolutionStrategy_Value</a> { <br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362cad02e019c28342793688466400afd032d">FirstSolutionStrategy_Value_UNSET</a> = 0, 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca6c8e1e7a2859125316fe07082a2da868">FirstSolutionStrategy_Value_AUTOMATIC</a> = 15, 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca4c1d8ec510011789f52267efc7d34bb7">FirstSolutionStrategy_Value_PATH_CHEAPEST_ARC</a> = 3, 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362cae133e7145564aa475a81741a6240e901">FirstSolutionStrategy_Value_PATH_MOST_CONSTRAINED_ARC</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca6d0f4bf298a2b6e6462feb7035d2c5de">FirstSolutionStrategy_Value_EVALUATOR_STRATEGY</a> = 5, 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca2acc1235ef1e7bec84c9a60b010400b7">FirstSolutionStrategy_Value_SAVINGS</a> = 10, 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca83fd39655867e51be481faa09fbea164">FirstSolutionStrategy_Value_SWEEP</a> = 11, 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca8a09bb6c57bf531f6674ea171b011791">FirstSolutionStrategy_Value_CHRISTOFIDES</a> = 13, 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca0c4ad672038428a0f3b3b7f6c92d8840">FirstSolutionStrategy_Value_ALL_UNPERFORMED</a> = 6, 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362cad0735ef20259782cea2046f90c39bda8">FirstSolutionStrategy_Value_BEST_INSERTION</a> = 7, 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362cabba644bd336acdb33aef7257f5bfa536">FirstSolutionStrategy_Value_PARALLEL_CHEAPEST_INSERTION</a> = 8, 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca8580f408e6e4af5373e4dd081d59d767">FirstSolutionStrategy_Value_SEQUENTIAL_CHEAPEST_INSERTION</a> = 14, 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca348e92318608b985248e17102d016cdd">FirstSolutionStrategy_Value_LOCAL_CHEAPEST_INSERTION</a> = 9, 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca9a63d38a1eed11971089af926145f83e">FirstSolutionStrategy_Value_GLOBAL_CHEAPEST_ARC</a> = 1, 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca451e468bc86902552aa9b987f66f5875">FirstSolutionStrategy_Value_LOCAL_CHEAPEST_ARC</a> = 2, 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca9c097f678b4aaaa6b10df89dc4d4802e">FirstSolutionStrategy_Value_FIRST_UNBOUND_MIN_VALUE</a> = 12, 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca8cdfd32facff4a66e180fab80f3fb711">FirstSolutionStrategy_Value_FirstSolutionStrategy_Value_INT_MIN_SENTINEL_DO_NOT_USE_</a> = std::numeric_limits&lt;::google::protobuf::int32&gt;::min(), 
<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362cae584dc12821c9b7171986c986b6c7462">FirstSolutionStrategy_Value_FirstSolutionStrategy_Value_INT_MAX_SENTINEL_DO_NOT_USE_</a> = std::numeric_limits&lt;::google::protobuf::int32&gt;::max()
<br />
 }</td></tr>
<tr class="separator:ab567c87506c164323ce22036cf4c362c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ad216f076775131996dbfd897ace77"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77">LocalSearchMetaheuristic_Value</a> { <br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77ab1177884bf5c3fda2cac819cca8279ec">LocalSearchMetaheuristic_Value_UNSET</a> = 0, 
<a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77a883a6e25cd8984a9e4e06636823f7201">LocalSearchMetaheuristic_Value_AUTOMATIC</a> = 6, 
<a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77a844fc936bb493f6a5d592b28302ea2f1">LocalSearchMetaheuristic_Value_GREEDY_DESCENT</a> = 1, 
<a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77a2909a10cd525473780b35aaa3c4f4eda">LocalSearchMetaheuristic_Value_GUIDED_LOCAL_SEARCH</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77a0d373c31dbec1678db8b9e50ae63327f">LocalSearchMetaheuristic_Value_SIMULATED_ANNEALING</a> = 3, 
<a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77a63e13a565cf5daf981c1b565912b3b0f">LocalSearchMetaheuristic_Value_TABU_SEARCH</a> = 4, 
<a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77a300fe37f649b909a810935825778b77c">LocalSearchMetaheuristic_Value_GENERIC_TABU_SEARCH</a> = 5, 
<a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77a0783003ef2622becdab73be7bfb66e03">LocalSearchMetaheuristic_Value_LocalSearchMetaheuristic_Value_INT_MIN_SENTINEL_DO_NOT_USE_</a> = std::numeric_limits&lt;::google::protobuf::int32&gt;::min(), 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77a719d13ec837e44b8b25b0f3315346594">LocalSearchMetaheuristic_Value_LocalSearchMetaheuristic_Value_INT_MAX_SENTINEL_DO_NOT_USE_</a> = std::numeric_limits&lt;::google::protobuf::int32&gt;::max()
<br />
 }</td></tr>
<tr class="separator:a96ad216f076775131996dbfd897ace77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab042145a1da0eaafbe215ded57dfe85f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85f">MPSolverCommonParameters_LPAlgorithmValues</a> { <a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85fa2218d316cfcac5a88342c95b188f3fda">MPSolverCommonParameters_LPAlgorithmValues_LP_ALGO_UNSPECIFIED</a> = 0, 
<a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85fa129c4c6d32bf9aed2414939cb02ff99a">MPSolverCommonParameters_LPAlgorithmValues_LP_ALGO_DUAL</a> = 1, 
<a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85fa53de34dc95fb67212e335f19dc210516">MPSolverCommonParameters_LPAlgorithmValues_LP_ALGO_PRIMAL</a> = 2, 
<a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85fa89ff8ffa01928d5993a1414705eecd15">MPSolverCommonParameters_LPAlgorithmValues_LP_ALGO_BARRIER</a> = 3
 }</td></tr>
<tr class="separator:ab042145a1da0eaafbe215ded57dfe85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66408fd9c4c05711631d208dce3118f5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5">MPModelRequest_SolverType</a> { <br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5a6fab373696058c6e9f279de4a8446411">MPModelRequest_SolverType_GLOP_LINEAR_PROGRAMMING</a> = 2, 
<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5a0969851c637668f95c10ddb1ade866a7">MPModelRequest_SolverType_CLP_LINEAR_PROGRAMMING</a> = 0, 
<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5aa32d84461e16e800e3f996d6347a304d">MPModelRequest_SolverType_GLPK_LINEAR_PROGRAMMING</a> = 1, 
<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5a3af34f198d539e787263f9eded0ce0cd">MPModelRequest_SolverType_GUROBI_LINEAR_PROGRAMMING</a> = 6, 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5a4bdeae4b1af8d2cd4aab225db4fc0407">MPModelRequest_SolverType_CPLEX_LINEAR_PROGRAMMING</a> = 10, 
<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5ac25c4844cbdf1e4d7c7efc11f1f8ebf4">MPModelRequest_SolverType_SCIP_MIXED_INTEGER_PROGRAMMING</a> = 3, 
<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5af60a0830addaf4cf00bc59459fa6647e">MPModelRequest_SolverType_GLPK_MIXED_INTEGER_PROGRAMMING</a> = 4, 
<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5a0e93bcd472e7a9296ff02058ed60f8d1">MPModelRequest_SolverType_CBC_MIXED_INTEGER_PROGRAMMING</a> = 5, 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5ac8beb7f7b026823a6bc2e4e87f546da6">MPModelRequest_SolverType_GUROBI_MIXED_INTEGER_PROGRAMMING</a> = 7, 
<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5a26762918189367f5e171d0e226084d82">MPModelRequest_SolverType_CPLEX_MIXED_INTEGER_PROGRAMMING</a> = 11, 
<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5a67639f2cd42e1197b5ad69a004c93ba3">MPModelRequest_SolverType_BOP_INTEGER_PROGRAMMING</a> = 12, 
<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5ac0fedb2082db5e7c96da01b4149c318e">MPModelRequest_SolverType_SAT_INTEGER_PROGRAMMING</a> = 14, 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5abe010aed8c1b29c5a0fd9ac262ce791f">MPModelRequest_SolverType_KNAPSACK_MIXED_INTEGER_PROGRAMMING</a> = 13
<br />
 }</td></tr>
<tr class="separator:a66408fd9c4c05711631d208dce3118f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d0df17eb5fb24fcdd0a134178cde56"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56">MPSolverResponseStatus</a> { <br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56ac95cb5be9e36b31647dd28910ac6cae4">MPSOLVER_OPTIMAL</a> = 0, 
<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56ac7d90afd0518be8cd6433ecad656a83b">MPSOLVER_FEASIBLE</a> = 1, 
<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56a0da2dbf49d011970a770d42141819d0a">MPSOLVER_INFEASIBLE</a> = 2, 
<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56ad73de4a0f9908a4c0d11246ecccf32b6">MPSOLVER_UNBOUNDED</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56ac77789af50586fb2f81915dd1cb790b6">MPSOLVER_ABNORMAL</a> = 4, 
<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56a667b6a5ed42c91ea81fa67c59cb3badb">MPSOLVER_NOT_SOLVED</a> = 6, 
<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56a97ee5aaa7f57f286d4a821dd6e57523f">MPSOLVER_MODEL_IS_VALID</a> = 97, 
<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56a84ea2a63b24de389aac6aa33b1203cd4">MPSOLVER_UNKNOWN_STATUS</a> = 99, 
<br />
&#160;&#160;<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56a6ae83516a798f1675e1b4daf0d8ea6b1">MPSOLVER_MODEL_INVALID</a> = 5, 
<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56a0f9da70b2f2b1304313c3a2a5f4876b3">MPSOLVER_MODEL_INVALID_SOLUTION_HINT</a> = 84, 
<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56ab90169f8480eca12c963af5ce50d36aa">MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS</a> = 85, 
<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56afa008125099beaab382c42682be6bbf9">MPSOLVER_SOLVER_TYPE_UNAVAILABLE</a> = 7
<br />
 }</td></tr>
<tr class="separator:a51d0df17eb5fb24fcdd0a134178cde56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a316abccdfa41512564d84365ea8f0ead"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a316abccdfa41512564d84365ea8f0ead">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const s)</td></tr>
<tr class="separator:a316abccdfa41512564d84365ea8f0ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009f247167f32509baf749083e4bc984"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a009f247167f32509baf749083e4bc984">Zero</a> ()</td></tr>
<tr class="memdesc:a009f247167f32509baf749083e4bc984"><td class="mdescLeft">&#160;</td><td class="mdescRight">-------&mdash; Misc -------&mdash;  <a href="#a009f247167f32509baf749083e4bc984">More...</a><br /></td></tr>
<tr class="separator:a009f247167f32509baf749083e4bc984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96bb5a28dd9c1ccc864b1587e8e1a98"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa96bb5a28dd9c1ccc864b1587e8e1a98">One</a> ()</td></tr>
<tr class="memdesc:aa96bb5a28dd9c1ccc864b1587e8e1a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns 1.  <a href="#aa96bb5a28dd9c1ccc864b1587e8e1a98">More...</a><br /></td></tr>
<tr class="separator:aa96bb5a28dd9c1ccc864b1587e8e1a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991f7a823d83b455d6b1a45141cb9ce9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a991f7a823d83b455d6b1a45141cb9ce9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classoperations__research_1_1BaseObject.html">BaseObject</a> *o)</td></tr>
<tr class="separator:a991f7a823d83b455d6b1a45141cb9ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f44b10aa7fc7b6e85b72e7f0c96cc1f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a4f44b10aa7fc7b6e85b72e7f0c96cc1f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classoperations__research_1_1Assignment.html">Assignment</a> &amp;assignment)</td></tr>
<tr class="separator:a4f44b10aa7fc7b6e85b72e7f0c96cc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2bf322fab4e2319a23ad22acf8ccf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aea2bf322fab4e2319a23ad22acf8ccf8">SetAssignmentFromAssignment</a> (<a class="el" href="classoperations__research_1_1Assignment.html">Assignment</a> *target_assignment, const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;target_vars, const <a class="el" href="classoperations__research_1_1Assignment.html">Assignment</a> *source_assignment, const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;source_vars)</td></tr>
<tr class="memdesc:aea2bf322fab4e2319a23ad22acf8ccf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a "source_assignment", clears the "target_assignment" and adds all IntVars in "target_vars", with the values of the variables set according to the corresponding values of "source_vars" in "source_assignment".  <a href="#aea2bf322fab4e2319a23ad22acf8ccf8">More...</a><br /></td></tr>
<tr class="separator:aea2bf322fab4e2319a23ad22acf8ccf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cf3e1336ec61275bdd2ae853d38406"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a64cf3e1336ec61275bdd2ae853d38406">Hash1</a> (uint64 value)</td></tr>
<tr class="memdesc:a64cf3e1336ec61275bdd2ae853d38406"><td class="mdescLeft">&#160;</td><td class="mdescRight">-------&mdash; Reversible Hash Table -------&mdash;  <a href="#a64cf3e1336ec61275bdd2ae853d38406">More...</a><br /></td></tr>
<tr class="separator:a64cf3e1336ec61275bdd2ae853d38406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89995e46facfc1db291ce75658dd0a5"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab89995e46facfc1db291ce75658dd0a5">Hash1</a> (uint32 value)</td></tr>
<tr class="separator:ab89995e46facfc1db291ce75658dd0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc54730764156f1fb717e99b71ba5d4"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#acfc54730764156f1fb717e99b71ba5d4">Hash1</a> (int64 value)</td></tr>
<tr class="separator:acfc54730764156f1fb717e99b71ba5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a9c1ccf298ae110decc3b9d285dc16"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a65a9c1ccf298ae110decc3b9d285dc16">Hash1</a> (int value)</td></tr>
<tr class="separator:a65a9c1ccf298ae110decc3b9d285dc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca754fad158b92d7f678b5d354d8927"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a3ca754fad158b92d7f678b5d354d8927">Hash1</a> (void *const ptr)</td></tr>
<tr class="separator:a3ca754fad158b92d7f678b5d354d8927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec42cb0a7c3079eb8f0406914077d633"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aec42cb0a7c3079eb8f0406914077d633"><td class="memTemplItemLeft" align="right" valign="top">uint64&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aec42cb0a7c3079eb8f0406914077d633">Hash1</a> (const std::vector&lt; T * &gt; &amp;ptrs)</td></tr>
<tr class="separator:aec42cb0a7c3079eb8f0406914077d633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ba31780fce352d4bba600e6e8eacad"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ac2ba31780fce352d4bba600e6e8eacad">Hash1</a> (const std::vector&lt; int64 &gt; &amp;ptrs)</td></tr>
<tr class="separator:ac2ba31780fce352d4bba600e6e8eacad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ea0ef5b46465c3793333ce9821f15f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a85ea0ef5b46465c3793333ce9821f15f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1LocalSearchOperator.html">LocalSearchOperator</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a85ea0ef5b46465c3793333ce9821f15f">MakeLocalSearchOperator</a> (<a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *<a class="el" href="routing_8h.html#a5f32c22c620c811754ba7b6f977db864">solver</a>, const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;vars, const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;secondary_vars, std::function&lt; int(int64)&gt; start_empty_path_class)</td></tr>
<tr class="memdesc:a85ea0ef5b46465c3793333ce9821f15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Operator Factories ---&mdash;  <a href="#a85ea0ef5b46465c3793333ce9821f15f">More...</a><br /></td></tr>
<tr class="separator:a85ea0ef5b46465c3793333ce9821f15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12527c82ffc8b31c5d8dc836c366d624"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a12527c82ffc8b31c5d8dc836c366d624"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a12527c82ffc8b31c5d8dc836c366d624">IsArrayConstant</a> (const std::vector&lt; T &gt; &amp;values, const T &amp;value)</td></tr>
<tr class="memdesc:a12527c82ffc8b31c5d8dc836c366d624"><td class="mdescLeft">&#160;</td><td class="mdescRight">-------&mdash; Helpers -------&mdash;  <a href="#a12527c82ffc8b31c5d8dc836c366d624">More...</a><br /></td></tr>
<tr class="separator:a12527c82ffc8b31c5d8dc836c366d624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4525e71a6b05d97c868f0832750a60"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3f4525e71a6b05d97c868f0832750a60"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a3f4525e71a6b05d97c868f0832750a60">IsArrayBoolean</a> (const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:a3f4525e71a6b05d97c868f0832750a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e4f71c4c79e0b4ec00c4e715a7c298"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae3e4f71c4c79e0b4ec00c4e715a7c298"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ae3e4f71c4c79e0b4ec00c4e715a7c298">AreAllOnes</a> (const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:ae3e4f71c4c79e0b4ec00c4e715a7c298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ae787392a8dd8a499eb55ac0916aa4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab0ae787392a8dd8a499eb55ac0916aa4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab0ae787392a8dd8a499eb55ac0916aa4">AreAllNull</a> (const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:ab0ae787392a8dd8a499eb55ac0916aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aea406979285a28c91fd1ee8115af74"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3aea406979285a28c91fd1ee8115af74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a3aea406979285a28c91fd1ee8115af74">AreAllGreaterOrEqual</a> (const std::vector&lt; T &gt; &amp;values, const T &amp;value)</td></tr>
<tr class="separator:a3aea406979285a28c91fd1ee8115af74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f08cfbb35e2b8b1eb76f79caea924a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a15f08cfbb35e2b8b1eb76f79caea924a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a15f08cfbb35e2b8b1eb76f79caea924a">AreAllLessOrEqual</a> (const std::vector&lt; T &gt; &amp;values, const T &amp;value)</td></tr>
<tr class="separator:a15f08cfbb35e2b8b1eb76f79caea924a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62b402f767cda48eb67ef8b50397f8f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab62b402f767cda48eb67ef8b50397f8f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab62b402f767cda48eb67ef8b50397f8f">AreAllPositive</a> (const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:ab62b402f767cda48eb67ef8b50397f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38972723946490ea4df4e34298d8805d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a38972723946490ea4df4e34298d8805d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a38972723946490ea4df4e34298d8805d">AreAllNegative</a> (const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:a38972723946490ea4df4e34298d8805d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de09f9134b976e5ba64751ac0f4440b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3de09f9134b976e5ba64751ac0f4440b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a3de09f9134b976e5ba64751ac0f4440b">AreAllStrictlyPositive</a> (const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:a3de09f9134b976e5ba64751ac0f4440b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8351829c324863ddda52e201df4f9f84"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8351829c324863ddda52e201df4f9f84"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a8351829c324863ddda52e201df4f9f84">AreAllStrictlyNegative</a> (const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:a8351829c324863ddda52e201df4f9f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafac7375c23337f25821aa6f86ca627c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aafac7375c23337f25821aa6f86ca627c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aafac7375c23337f25821aa6f86ca627c">IsIncreasingContiguous</a> (const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:aafac7375c23337f25821aa6f86ca627c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d434774c07815a25ffaa7adb343c19e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3d434774c07815a25ffaa7adb343c19e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a3d434774c07815a25ffaa7adb343c19e">IsIncreasing</a> (const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:a3d434774c07815a25ffaa7adb343c19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2aea6c68fe502389c9264b971b2f85"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adf2aea6c68fe502389c9264b971b2f85"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#adf2aea6c68fe502389c9264b971b2f85">IsArrayInRange</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;vars, T range_min, T range_max)</td></tr>
<tr class="memdesc:adf2aea6c68fe502389c9264b971b2f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; On integer variable vector --&mdash;  <a href="#adf2aea6c68fe502389c9264b971b2f85">More...</a><br /></td></tr>
<tr class="separator:adf2aea6c68fe502389c9264b971b2f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c7a8bfc6877606e512d3279549f44d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ae4c7a8bfc6877606e512d3279549f44d">AreAllBound</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;vars)</td></tr>
<tr class="separator:ae4c7a8bfc6877606e512d3279549f44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abde7313cef64d25202a18f07481fc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a7abde7313cef64d25202a18f07481fc3">AreAllBooleans</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;vars)</td></tr>
<tr class="separator:a7abde7313cef64d25202a18f07481fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54470bffc3ea32cc37d0222e5dbb62a6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a54470bffc3ea32cc37d0222e5dbb62a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a54470bffc3ea32cc37d0222e5dbb62a6">AreAllBoundOrNull</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;vars, const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a54470bffc3ea32cc37d0222e5dbb62a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all the variables are assigned to a single value, or if their corresponding value is null.  <a href="#a54470bffc3ea32cc37d0222e5dbb62a6">More...</a><br /></td></tr>
<tr class="separator:a54470bffc3ea32cc37d0222e5dbb62a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7028ce8b481be8cb6fca7a6925d41aa7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a7028ce8b481be8cb6fca7a6925d41aa7">AreAllBoundTo</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;vars, int64 value)</td></tr>
<tr class="memdesc:a7028ce8b481be8cb6fca7a6925d41aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all variables are assigned to 'value'.  <a href="#a7028ce8b481be8cb6fca7a6925d41aa7">More...</a><br /></td></tr>
<tr class="separator:a7028ce8b481be8cb6fca7a6925d41aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc42d1bcfe023d3ac6f59471b75d853c"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#abc42d1bcfe023d3ac6f59471b75d853c">MaxVarArray</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;vars)</td></tr>
<tr class="separator:abc42d1bcfe023d3ac6f59471b75d853c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1932027ef8bc1689d725a1c597867b"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a5c1932027ef8bc1689d725a1c597867b">MinVarArray</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;vars)</td></tr>
<tr class="separator:a5c1932027ef8bc1689d725a1c597867b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6662a100d8715747870beb9721bb304b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a6662a100d8715747870beb9721bb304b">FillValues</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;vars, std::vector&lt; int64 &gt; *const values)</td></tr>
<tr class="separator:a6662a100d8715747870beb9721bb304b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dabfa452b4264887ef76c75edf3765"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a60dabfa452b4264887ef76c75edf3765">PosIntDivUp</a> (int64 e, int64 v)</td></tr>
<tr class="memdesc:a60dabfa452b4264887ef76c75edf3765"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Arithmetic operations --&mdash;  <a href="#a60dabfa452b4264887ef76c75edf3765">More...</a><br /></td></tr>
<tr class="separator:a60dabfa452b4264887ef76c75edf3765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942ba2898a44303790c91e761b8f4630"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a942ba2898a44303790c91e761b8f4630">PosIntDivDown</a> (int64 e, int64 v)</td></tr>
<tr class="separator:a942ba2898a44303790c91e761b8f4630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4e1b406f0e56c83283747b038df88a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aad4e1b406f0e56c83283747b038df88a">ToInt64Vector</a> (const std::vector&lt; int &gt; &amp;input)</td></tr>
<tr class="memdesc:aad4e1b406f0e56c83283747b038df88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; Vector of integer manipulations --&mdash;  <a href="#aad4e1b406f0e56c83283747b038df88a">More...</a><br /></td></tr>
<tr class="separator:aad4e1b406f0e56c83283747b038df88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39a6c4d8ba890ec5150ea91a7aad643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1RoutingModelParameters.html">RoutingModelParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ae39a6c4d8ba890ec5150ea91a7aad643">BuildModelParametersFromFlags</a> ()</td></tr>
<tr class="memdesc:ae39a6c4d8ba890ec5150ea91a7aad643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds routing search parameters from flags.  <a href="#ae39a6c4d8ba890ec5150ea91a7aad643">More...</a><br /></td></tr>
<tr class="separator:ae39a6c4d8ba890ec5150ea91a7aad643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95da1d3a46432afd40024f79279a48b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1RoutingSearchParameters.html">RoutingSearchParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a95da1d3a46432afd40024f79279a48b2">BuildSearchParametersFromFlags</a> ()</td></tr>
<tr class="memdesc:a95da1d3a46432afd40024f79279a48b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds routing search parameters from flags.  <a href="#a95da1d3a46432afd40024f79279a48b2">More...</a><br /></td></tr>
<tr class="separator:a95da1d3a46432afd40024f79279a48b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f03e5ed2f65164d62fc5f039441596d"><td class="memItemLeft" align="right" valign="top">*RoutingModel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a2f03e5ed2f65164d62fc5f039441596d">model</a> (manager)</td></tr>
<tr class="separator:a2f03e5ed2f65164d62fc5f039441596d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891fd91407acbbeb1c47d22be7991b3f"><td class="memItemLeft" align="right" valign="top">use manager&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a891fd91407acbbeb1c47d22be7991b3f">NodeToIndex</a> (node)' whenever '<a class="el" href="namespaceoperations__research.html#a2f03e5ed2f65164d62fc5f039441596d">model</a>' requires a variable *index. */class RoutingIndexManager</td></tr>
<tr class="separator:a891fd91407acbbeb1c47d22be7991b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa388c8707db255ae7742c04046bdd613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1RoutingModelParameters.html">RoutingModelParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa388c8707db255ae7742c04046bdd613">DefaultRoutingModelParameters</a> ()</td></tr>
<tr class="separator:aa388c8707db255ae7742c04046bdd613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcac4a11f1e4d36ceb47f7251461487d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1RoutingSearchParameters.html">RoutingSearchParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#adcac4a11f1e4d36ceb47f7251461487d">DefaultRoutingSearchParameters</a> ()</td></tr>
<tr class="separator:adcac4a11f1e4d36ceb47f7251461487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e060e8ee4ea901dc4df260b3385eac"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ae2e060e8ee4ea901dc4df260b3385eac">FindErrorInRoutingSearchParameters</a> (const <a class="el" href="classoperations__research_1_1RoutingSearchParameters.html">RoutingSearchParameters</a> &amp;search_parameters)</td></tr>
<tr class="memdesc:ae2e060e8ee4ea901dc4df260b3385eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an empty std::string if the routing search parameters are valid, and a non-empty, human readable error description if they're not.  <a href="#ae2e060e8ee4ea901dc4df260b3385eac">More...</a><br /></td></tr>
<tr class="separator:ae2e060e8ee4ea901dc4df260b3385eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fee47a5359613bc7f8df356595c7ff0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a8fee47a5359613bc7f8df356595c7ff0">DEFINE_INT_TYPE</a> (RoutingNodeIndex, int)</td></tr>
<tr class="memdesc:a8fee47a5359613bc7f8df356595c7ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defining common types used in the routing library outside the main RoutingModel class has several purposes: 1) It allows some small libraries to avoid a dependency on routing.  <a href="#a8fee47a5359613bc7f8df356595c7ff0">More...</a><br /></td></tr>
<tr class="separator:a8fee47a5359613bc7f8df356595c7ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9196adb7aa76d8e60cd4c0c6687c0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#afa9196adb7aa76d8e60cd4c0c6687c0d">DEFINE_INT_TYPE</a> (RoutingCostClassIndex, int)</td></tr>
<tr class="separator:afa9196adb7aa76d8e60cd4c0c6687c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d98b6fb94b9cdabfaca3d9f3c9632e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a3d98b6fb94b9cdabfaca3d9f3c9632e9">DEFINE_INT_TYPE</a> (RoutingDimensionIndex, int)</td></tr>
<tr class="separator:a3d98b6fb94b9cdabfaca3d9f3c9632e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edd1d7c020633019991b13d14b4b15b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a1edd1d7c020633019991b13d14b4b15b">DEFINE_INT_TYPE</a> (RoutingDisjunctionIndex, int)</td></tr>
<tr class="separator:a1edd1d7c020633019991b13d14b4b15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff19b78b3d56ff95c23727ca4ff64ea7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aff19b78b3d56ff95c23727ca4ff64ea7">DEFINE_INT_TYPE</a> (RoutingVehicleClassIndex, int)</td></tr>
<tr class="separator:aff19b78b3d56ff95c23727ca4ff64ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509097448ff5705cf3e64d889362bdec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a509097448ff5705cf3e64d889362bdec">FindCliques</a> (std::function&lt; bool(int, int)&gt; graph, int node_count, std::function&lt; bool(const std::vector&lt; int &gt; &amp;)&gt; callback)</td></tr>
<tr class="memdesc:a509097448ff5705cf3e64d889362bdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all maximal cliques, even of size 1, in the graph described by the graph callback.  <a href="#a509097448ff5705cf3e64d889362bdec">More...</a><br /></td></tr>
<tr class="separator:a509097448ff5705cf3e64d889362bdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4b5a6c0e4019314f288e3f4307c114"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#afe4b5a6c0e4019314f288e3f4307c114">CoverArcsByCliques</a> (std::function&lt; bool(int, int)&gt; graph, int node_count, std::function&lt; bool(const std::vector&lt; int &gt; &amp;)&gt; callback)</td></tr>
<tr class="memdesc:afe4b5a6c0e4019314f288e3f4307c114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Covers the maximum number of arcs of the graph with cliques.  <a href="#afe4b5a6c0e4019314f288e3f4307c114">More...</a><br /></td></tr>
<tr class="separator:afe4b5a6c0e4019314f288e3f4307c114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb53c505b8fd29ceb3abdcc7dfd809ce"><td class="memTemplParams" colspan="2">template&lt;typename GraphType &gt; </td></tr>
<tr class="memitem:acb53c505b8fd29ceb3abdcc7dfd809ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#acb53c505b8fd29ceb3abdcc7dfd809ce">BuildLineGraph</a> (const GraphType &amp;graph, GraphType *const line_graph)</td></tr>
<tr class="memdesc:acb53c505b8fd29ceb3abdcc7dfd809ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a directed line graph for 'graph' (see "directed line graph" in <a href="http://en.wikipedia.org/wiki/Line_graph">http://en.wikipedia.org/wiki/Line_graph</a>).  <a href="#acb53c505b8fd29ceb3abdcc7dfd809ce">More...</a><br /></td></tr>
<tr class="separator:acb53c505b8fd29ceb3abdcc7dfd809ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cf773de0cae72d0c44efe5b8f4bb89"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ab1cf773de0cae72d0c44efe5b8f4bb89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab1cf773de0cae72d0c44efe5b8f4bb89">IsEulerianGraph</a> (const Graph &amp;graph)</td></tr>
<tr class="memdesc:ab1cf773de0cae72d0c44efe5b8f4bb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a graph is Eulerian, aka all its nodes are of even degree.  <a href="#ab1cf773de0cae72d0c44efe5b8f4bb89">More...</a><br /></td></tr>
<tr class="separator:ab1cf773de0cae72d0c44efe5b8f4bb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b312dd19c90b2af099e6f159869f7ee"><td class="memTemplParams" colspan="2">template&lt;typename NodeIndex , typename Graph &gt; </td></tr>
<tr class="memitem:a6b312dd19c90b2af099e6f159869f7ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a6b312dd19c90b2af099e6f159869f7ee">IsSemiEulerianGraph</a> (const Graph &amp;graph, std::vector&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> &gt; *odd_nodes)</td></tr>
<tr class="memdesc:a6b312dd19c90b2af099e6f159869f7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a graph is Semi-Eulerian, aka at most two of its nodes are of odd degree.  <a href="#a6b312dd19c90b2af099e6f159869f7ee">More...</a><br /></td></tr>
<tr class="separator:a6b312dd19c90b2af099e6f159869f7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743d8c9d6f64531bdeb7bbf18023e9d4"><td class="memTemplParams" colspan="2">template&lt;typename NodeIndex , typename Graph &gt; </td></tr>
<tr class="memitem:a743d8c9d6f64531bdeb7bbf18023e9d4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a743d8c9d6f64531bdeb7bbf18023e9d4">BuildEulerianPathFromNode</a> (const Graph &amp;graph, <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> root)</td></tr>
<tr class="memdesc:a743d8c9d6f64531bdeb7bbf18023e9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an Eulerian path/trail on an undirected graph starting from node root.  <a href="#a743d8c9d6f64531bdeb7bbf18023e9d4">More...</a><br /></td></tr>
<tr class="separator:a743d8c9d6f64531bdeb7bbf18023e9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63055860fc53f8eed56d23d2571c180"><td class="memTemplParams" colspan="2">template&lt;typename NodeIndex , typename Graph &gt; </td></tr>
<tr class="memitem:aa63055860fc53f8eed56d23d2571c180"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa63055860fc53f8eed56d23d2571c180">BuildEulerianTourFromNode</a> (const Graph &amp;graph, <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> root)</td></tr>
<tr class="memdesc:aa63055860fc53f8eed56d23d2571c180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an Eulerian tour/circuit/cycle starting and ending at node root on an undirected graph.  <a href="#aa63055860fc53f8eed56d23d2571c180">More...</a><br /></td></tr>
<tr class="separator:aa63055860fc53f8eed56d23d2571c180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034666fe63ca105b735272974006362a"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a034666fe63ca105b735272974006362a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Graph::NodeIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a034666fe63ca105b735272974006362a">BuildEulerianTour</a> (const Graph &amp;graph)</td></tr>
<tr class="memdesc:a034666fe63ca105b735272974006362a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but without specifying a start/end root node (node 0 is taken as default root).  <a href="#a034666fe63ca105b735272974006362a">More...</a><br /></td></tr>
<tr class="separator:a034666fe63ca105b735272974006362a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b170b2d03863c465331e67b21f0c33"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a49b170b2d03863c465331e67b21f0c33"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Graph::NodeIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a49b170b2d03863c465331e67b21f0c33">BuildEulerianPath</a> (const Graph &amp;graph)</td></tr>
<tr class="memdesc:a49b170b2d03863c465331e67b21f0c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an Eulerian path/trail on an undirected graph.  <a href="#a49b170b2d03863c465331e67b21f0c33">More...</a><br /></td></tr>
<tr class="separator:a49b170b2d03863c465331e67b21f0c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715b0dbb9f0903ab629b8c6da1b35b45"><td class="memTemplParams" colspan="2">template&lt;typename CostType , typename CostFunction &gt; </td></tr>
<tr class="memitem:a715b0dbb9f0903ab629b8c6da1b35b45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html">HamiltonianPathSolver</a>&lt; CostType, CostFunction &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a715b0dbb9f0903ab629b8c6da1b35b45">MakeHamiltonianPathSolver</a> (int num_nodes, CostFunction cost)</td></tr>
<tr class="memdesc:a715b0dbb9f0903ab629b8c6da1b35b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to simplify building a <a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html">HamiltonianPathSolver</a> from a functor.  <a href="#a715b0dbb9f0903ab629b8c6da1b35b45">More...</a><br /></td></tr>
<tr class="separator:a715b0dbb9f0903ab629b8c6da1b35b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ab79ee21ffd8dece0996e37f9faa7a"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a00ab79ee21ffd8dece0996e37f9faa7a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Graph::ArcIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a00ab79ee21ffd8dece0996e37f9faa7a">BuildKruskalMinimumSpanningTreeFromSortedArcs</a> (const Graph &amp;graph, const std::vector&lt; typename Graph::ArcIndex &gt; &amp;sorted_arcs)</td></tr>
<tr class="memdesc:a00ab79ee21ffd8dece0996e37f9faa7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Kruskal's mininumum spanning tree algorithm (c.f.  <a href="#a00ab79ee21ffd8dece0996e37f9faa7a">More...</a><br /></td></tr>
<tr class="separator:a00ab79ee21ffd8dece0996e37f9faa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa565a47a059ef32ef1aec39768e4ec98"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename ArcComparator &gt; </td></tr>
<tr class="memitem:aa565a47a059ef32ef1aec39768e4ec98"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Graph::ArcIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa565a47a059ef32ef1aec39768e4ec98">BuildKruskalMinimumSpanningTree</a> (const Graph &amp;graph, const ArcComparator &amp;arc_comparator)</td></tr>
<tr class="memdesc:aa565a47a059ef32ef1aec39768e4ec98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version taking an arc comparator to sort graph arcs.  <a href="#aa565a47a059ef32ef1aec39768e4ec98">More...</a><br /></td></tr>
<tr class="separator:aa565a47a059ef32ef1aec39768e4ec98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a2f4c26fd60cd0fa98257b571c974f"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename ArcValue &gt; </td></tr>
<tr class="memitem:a33a2f4c26fd60cd0fa98257b571c974f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Graph::ArcIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a33a2f4c26fd60cd0fa98257b571c974f">BuildPrimMinimumSpanningTree</a> (const Graph &amp;graph, const ArcValue &amp;arc_value)</td></tr>
<tr class="memdesc:a33a2f4c26fd60cd0fa98257b571c974f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Prim's mininumum spanning tree algorithm (c.f.  <a href="#a33a2f4c26fd60cd0fa98257b571c974f">More...</a><br /></td></tr>
<tr class="separator:a33a2f4c26fd60cd0fa98257b571c974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e6a83fcbd689abf5b3078b0236f9f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a53e6a83fcbd689abf5b3078b0236f9f1">DijkstraShortestPath</a> (int node_count, int start_node, int end_node, std::function&lt; int64(int, int)&gt; graph, int64 disconnected_distance, std::vector&lt; int &gt; *<a class="el" href="routing_8h.html#a0f38add802397fef1f57b7d90ccd5aef">nodes</a>)</td></tr>
<tr class="memdesc:a53e6a83fcbd689abf5b3078b0236f9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dijsktra Shortest path with callback based description of the graph.  <a href="#a53e6a83fcbd689abf5b3078b0236f9f1">More...</a><br /></td></tr>
<tr class="separator:a53e6a83fcbd689abf5b3078b0236f9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56bae19a2298c3163af96ca7f8b89b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad56bae19a2298c3163af96ca7f8b89b1">StableDijkstraShortestPath</a> (int node_count, int start_node, int end_node, std::function&lt; int64(int, int)&gt; graph, int64 disconnected_distance, std::vector&lt; int &gt; *<a class="el" href="routing_8h.html#a0f38add802397fef1f57b7d90ccd5aef">nodes</a>)</td></tr>
<tr class="memdesc:ad56bae19a2298c3163af96ca7f8b89b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable version of the Dijsktra Shortest path with callback based description of the graph.  <a href="#ad56bae19a2298c3163af96ca7f8b89b1">More...</a><br /></td></tr>
<tr class="separator:ad56bae19a2298c3163af96ca7f8b89b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bfec6ea714171fbff2d8b791d0d286"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad5bfec6ea714171fbff2d8b791d0d286">BellmanFordShortestPath</a> (int node_count, int start_node, int end_node, std::function&lt; int64(int, int)&gt; graph, int64 disconnected_distance, std::vector&lt; int &gt; *<a class="el" href="routing_8h.html#a0f38add802397fef1f57b7d90ccd5aef">nodes</a>)</td></tr>
<tr class="memdesc:ad5bfec6ea714171fbff2d8b791d0d286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bellman-Ford Shortest path with callback-based description of the graph.  <a href="#ad5bfec6ea714171fbff2d8b791d0d286">More...</a><br /></td></tr>
<tr class="separator:ad5bfec6ea714171fbff2d8b791d0d286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff272be25bcf9641218c05c59ec1a4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#acff272be25bcf9641218c05c59ec1a4e">AStarShortestPath</a> (int node_count, int start_node, int end_node, std::function&lt; int64(int, int)&gt; graph, std::function&lt; int64(int)&gt; heuristic, int64 disconnected_distance, std::vector&lt; int &gt; *<a class="el" href="routing_8h.html#a0f38add802397fef1f57b7d90ccd5aef">nodes</a>)</td></tr>
<tr class="memdesc:acff272be25bcf9641218c05c59ec1a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A* Shortest path with function based description of the graph.  <a href="#acff272be25bcf9641218c05c59ec1a4e">More...</a><br /></td></tr>
<tr class="separator:acff272be25bcf9641218c05c59ec1a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f9b83239285f5fdfcac1b8e8b4f162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a97f9b83239285f5fdfcac1b8e8b4f162">operator+</a> (<a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> lhs, const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:a97f9b83239285f5fdfcac1b8e8b4f162"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOTE(user): in the ops below, the non-"const LinearExpr&amp;" are intentional.  <a href="#a97f9b83239285f5fdfcac1b8e8b4f162">More...</a><br /></td></tr>
<tr class="separator:a97f9b83239285f5fdfcac1b8e8b4f162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515cdaf4f9c4000bb3482a0c450e23c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a515cdaf4f9c4000bb3482a0c450e23c3">operator-</a> (<a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> lhs, const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;rhs)</td></tr>
<tr class="separator:a515cdaf4f9c4000bb3482a0c450e23c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741104fe08089fe3520676487f7a685d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a741104fe08089fe3520676487f7a685d">operator *</a> (<a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> lhs, double rhs)</td></tr>
<tr class="separator:a741104fe08089fe3520676487f7a685d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebdd7f40e90df8dc7d557b6e26da942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#abebdd7f40e90df8dc7d557b6e26da942">operator/</a> (<a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> lhs, double rhs)</td></tr>
<tr class="separator:abebdd7f40e90df8dc7d557b6e26da942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99590470c6ad2d59331b6fcc56609877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a99590470c6ad2d59331b6fcc56609877">operator *</a> (double lhs, <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> rhs)</td></tr>
<tr class="separator:a99590470c6ad2d59331b6fcc56609877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1fa20f9c9faf7027c0b16f97139e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a6d1fa20f9c9faf7027c0b16f97139e80">operator&lt;=</a> (const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;lhs, const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;rhs)</td></tr>
<tr class="separator:a6d1fa20f9c9faf7027c0b16f97139e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08146f196bd9c3f492ee108732449ced"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a08146f196bd9c3f492ee108732449ced">operator==</a> (const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;lhs, const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;rhs)</td></tr>
<tr class="separator:a08146f196bd9c3f492ee108732449ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4052f92af6a7fbb1d45e17befcb68e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ac4052f92af6a7fbb1d45e17befcb68e0">operator&gt;=</a> (const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;lhs, const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;rhs)</td></tr>
<tr class="separator:ac4052f92af6a7fbb1d45e17befcb68e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689d3552f87e89456c0c9a43847c964a"><td class="memItemLeft" align="right" valign="top">util::StatusOr&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a689d3552f87e89456c0c9a43847c964a">ExportModelAsLpFormat</a> (const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;<a class="el" href="namespaceoperations__research.html#a2f03e5ed2f65164d62fc5f039441596d">model</a>, const <a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a> &amp;options=<a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a>())</td></tr>
<tr class="memdesc:a689d3552f87e89456c0c9a43847c964a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the current model (variables, constraints, objective) as a std::string encoded in the so-called "CPLEX LP file format" as generated by SCIP.  <a href="#a689d3552f87e89456c0c9a43847c964a">More...</a><br /></td></tr>
<tr class="separator:a689d3552f87e89456c0c9a43847c964a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef684073daca7460490db8d881f886e0"><td class="memItemLeft" align="right" valign="top">util::StatusOr&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aef684073daca7460490db8d881f886e0">ExportModelAsMpsFormat</a> (const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;<a class="el" href="namespaceoperations__research.html#a2f03e5ed2f65164d62fc5f039441596d">model</a>, const <a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a> &amp;options=<a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a>())</td></tr>
<tr class="memdesc:aef684073daca7460490db8d881f886e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the current model (variables, constraints, objective) as a std::string encoded in MPS file format, using the "free" MPS format.  <a href="#aef684073daca7460490db8d881f886e0">More...</a><br /></td></tr>
<tr class="separator:aef684073daca7460490db8d881f886e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d319c19b685fe608fe013b573081351"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a4d319c19b685fe608fe013b573081351">ExportModelAsLpFormatReturnString</a> (const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;input_model, const <a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a> &amp;options=<a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a>())</td></tr>
<tr class="separator:a4d319c19b685fe608fe013b573081351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37abd61c0d982af79257814b6d3a733e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a37abd61c0d982af79257814b6d3a733e">ExportModelAsMpsFormatReturnString</a> (const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;input_model, const <a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a> &amp;options=<a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a>())</td></tr>
<tr class="separator:a37abd61c0d982af79257814b6d3a733e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a27bb74d09b7ba6ea0e97bb572d2755"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a7a27bb74d09b7ba6ea0e97bb572d2755">FindErrorInMPModelProto</a> (const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;<a class="el" href="namespaceoperations__research.html#a2f03e5ed2f65164d62fc5f039441596d">model</a>)</td></tr>
<tr class="memdesc:a7a27bb74d09b7ba6ea0e97bb572d2755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an empty std::string iff the model is valid and not trivially infeasible.  <a href="#a7a27bb74d09b7ba6ea0e97bb572d2755">More...</a><br /></td></tr>
<tr class="separator:a7a27bb74d09b7ba6ea0e97bb572d2755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ee4d82cf625670cdc1f52197454654"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ae4ee4d82cf625670cdc1f52197454654">FindFeasibilityErrorInSolutionHint</a> (const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;<a class="el" href="namespaceoperations__research.html#a2f03e5ed2f65164d62fc5f039441596d">model</a>, double tolerance)</td></tr>
<tr class="memdesc:ae4ee4d82cf625670cdc1f52197454654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an empty std::string if the solution hint given in the model is a feasible solution.  <a href="#ae4ee4d82cf625670cdc1f52197454654">More...</a><br /></td></tr>
<tr class="separator:ae4ee4d82cf625670cdc1f52197454654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c341d9214d5d46014089435ba0e26d3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a5c341d9214d5d46014089435ba0e26d3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structoperations__research_1_1ClosedInterval.html">ClosedInterval</a> &amp;interval)</td></tr>
<tr class="separator:a5c341d9214d5d46014089435ba0e26d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa301d39d2a9271daf8c65e779635335"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aaa301d39d2a9271daf8c65e779635335">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; <a class="el" href="structoperations__research_1_1ClosedInterval.html">ClosedInterval</a> &gt; &amp;intervals)</td></tr>
<tr class="separator:aaa301d39d2a9271daf8c65e779635335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c23924c4b61ed5c531424a6f18bde1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab8c23924c4b61ed5c531424a6f18bde1">IntervalsAreSortedAndNonAdjacent</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1ClosedInterval.html">ClosedInterval</a> &gt; intervals)</td></tr>
<tr class="memdesc:ab8c23924c4b61ed5c531424a6f18bde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff we have:  <a href="#ab8c23924c4b61ed5c531424a6f18bde1">More...</a><br /></td></tr>
<tr class="separator:ab8c23924c4b61ed5c531424a6f18bde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebf3070a940da6bf678953a66584e76"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#abebf3070a940da6bf678953a66584e76">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;domain)</td></tr>
<tr class="separator:abebf3070a940da6bf678953a66584e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fb428ce4826abddd79ff391cfc1c51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ac8fb428ce4826abddd79ff391cfc1c51">FirstSolutionStrategy_Value_IsValid</a> (int value)</td></tr>
<tr class="separator:ac8fb428ce4826abddd79ff391cfc1c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3c2af7d77d5e7f76f9a3d8fb1edf0f"><td class="memItemLeft" align="right" valign="top">const ::google::protobuf::EnumDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a3c3c2af7d77d5e7f76f9a3d8fb1edf0f">FirstSolutionStrategy_Value_descriptor</a> ()</td></tr>
<tr class="separator:a3c3c2af7d77d5e7f76f9a3d8fb1edf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed24a4c7f867bbe1173faf422387c57"><td class="memItemLeft" align="right" valign="top">const ::std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aaed24a4c7f867bbe1173faf422387c57">FirstSolutionStrategy_Value_Name</a> (<a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362c">FirstSolutionStrategy_Value</a> value)</td></tr>
<tr class="separator:aaed24a4c7f867bbe1173faf422387c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1acf7e4aff76fb0cc1659d91bdb5a62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad1acf7e4aff76fb0cc1659d91bdb5a62">FirstSolutionStrategy_Value_Parse</a> (const ::std::string &amp;name, <a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362c">FirstSolutionStrategy_Value</a> *value)</td></tr>
<tr class="separator:ad1acf7e4aff76fb0cc1659d91bdb5a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed46fa1bbfbc75c04bd66f5055ddb3c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aed46fa1bbfbc75c04bd66f5055ddb3c1">LocalSearchMetaheuristic_Value_IsValid</a> (int value)</td></tr>
<tr class="separator:aed46fa1bbfbc75c04bd66f5055ddb3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5142d10acce3d076acf89506752dba5f"><td class="memItemLeft" align="right" valign="top">const ::google::protobuf::EnumDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a5142d10acce3d076acf89506752dba5f">LocalSearchMetaheuristic_Value_descriptor</a> ()</td></tr>
<tr class="separator:a5142d10acce3d076acf89506752dba5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade04d594c17cc2436976da614fa0a2f7"><td class="memItemLeft" align="right" valign="top">const ::std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ade04d594c17cc2436976da614fa0a2f7">LocalSearchMetaheuristic_Value_Name</a> (<a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77">LocalSearchMetaheuristic_Value</a> value)</td></tr>
<tr class="separator:ade04d594c17cc2436976da614fa0a2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7c14051a98f40a1782646965401ca7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a8e7c14051a98f40a1782646965401ca7">LocalSearchMetaheuristic_Value_Parse</a> (const ::std::string &amp;name, <a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77">LocalSearchMetaheuristic_Value</a> *value)</td></tr>
<tr class="separator:a8e7c14051a98f40a1782646965401ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ee5c7a9f799696432b082fd4835232"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab3ee5c7a9f799696432b082fd4835232">MPSolverCommonParameters_LPAlgorithmValues_IsValid</a> (int value)</td></tr>
<tr class="separator:ab3ee5c7a9f799696432b082fd4835232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976efc8cb83ba6997aa984b3c106da17"><td class="memItemLeft" align="right" valign="top">const ::google::protobuf::EnumDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a976efc8cb83ba6997aa984b3c106da17">MPSolverCommonParameters_LPAlgorithmValues_descriptor</a> ()</td></tr>
<tr class="separator:a976efc8cb83ba6997aa984b3c106da17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317f48b6b35697bf02ead22157c91c52"><td class="memItemLeft" align="right" valign="top">const ::std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a317f48b6b35697bf02ead22157c91c52">MPSolverCommonParameters_LPAlgorithmValues_Name</a> (<a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85f">MPSolverCommonParameters_LPAlgorithmValues</a> value)</td></tr>
<tr class="separator:a317f48b6b35697bf02ead22157c91c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b888d39ca1974f8485911aa6434144"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ac2b888d39ca1974f8485911aa6434144">MPSolverCommonParameters_LPAlgorithmValues_Parse</a> (const ::std::string &amp;name, <a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85f">MPSolverCommonParameters_LPAlgorithmValues</a> *value)</td></tr>
<tr class="separator:ac2b888d39ca1974f8485911aa6434144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26c438ab5f1b232d7eced80a2780ca0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad26c438ab5f1b232d7eced80a2780ca0">MPModelRequest_SolverType_IsValid</a> (int value)</td></tr>
<tr class="separator:ad26c438ab5f1b232d7eced80a2780ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fea38c7df3ab9583e34b82878e255c"><td class="memItemLeft" align="right" valign="top">const ::google::protobuf::EnumDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa3fea38c7df3ab9583e34b82878e255c">MPModelRequest_SolverType_descriptor</a> ()</td></tr>
<tr class="separator:aa3fea38c7df3ab9583e34b82878e255c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d017a27f2b89bb55910d1fceb31c64"><td class="memItemLeft" align="right" valign="top">const ::std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad1d017a27f2b89bb55910d1fceb31c64">MPModelRequest_SolverType_Name</a> (<a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5">MPModelRequest_SolverType</a> value)</td></tr>
<tr class="separator:ad1d017a27f2b89bb55910d1fceb31c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ee3de18b0c41c98df4de7f38c3543"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a028ee3de18b0c41c98df4de7f38c3543">MPModelRequest_SolverType_Parse</a> (const ::std::string &amp;name, <a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5">MPModelRequest_SolverType</a> *value)</td></tr>
<tr class="separator:a028ee3de18b0c41c98df4de7f38c3543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a295b0760db498bc4fa9479bb8c2329"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a7a295b0760db498bc4fa9479bb8c2329">MPSolverResponseStatus_IsValid</a> (int value)</td></tr>
<tr class="separator:a7a295b0760db498bc4fa9479bb8c2329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472faf18ff58cd6640b7b3bf6336d9b6"><td class="memItemLeft" align="right" valign="top">const ::google::protobuf::EnumDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a472faf18ff58cd6640b7b3bf6336d9b6">MPSolverResponseStatus_descriptor</a> ()</td></tr>
<tr class="separator:a472faf18ff58cd6640b7b3bf6336d9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1225873debe2bc2cb173d365f06ca615"><td class="memItemLeft" align="right" valign="top">const ::std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a1225873debe2bc2cb173d365f06ca615">MPSolverResponseStatus_Name</a> (<a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56">MPSolverResponseStatus</a> value)</td></tr>
<tr class="separator:a1225873debe2bc2cb173d365f06ca615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415f14aa6c054ed47d050bd15e725f52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a415f14aa6c054ed47d050bd15e725f52">MPSolverResponseStatus_Parse</a> (const ::std::string &amp;name, <a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56">MPSolverResponseStatus</a> *value)</td></tr>
<tr class="separator:a415f14aa6c054ed47d050bd15e725f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3ea6af6581e6922832918c97753146a7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3ea6af6581e6922832918c97753146a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a3ea6af6581e6922832918c97753146a7">MakeConstraintDemon0</a> (<a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const s, T *const ct, void(T::*method)(), const std::string &amp;name)</td></tr>
<tr class="separator:a3ea6af6581e6922832918c97753146a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0953b50b08320d1109c678555137f1db"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a0953b50b08320d1109c678555137f1db"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a0953b50b08320d1109c678555137f1db">ParameterDebugString</a> (P param)</td></tr>
<tr class="separator:a0953b50b08320d1109c678555137f1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2f93547af434566184b7dee7039c93"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a3c2f93547af434566184b7dee7039c93"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a3c2f93547af434566184b7dee7039c93">ParameterDebugString</a> (P *param)</td></tr>
<tr class="memdesc:a3c2f93547af434566184b7dee7039c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support limited to pointers to classes which define DebugString().  <a href="#a3c2f93547af434566184b7dee7039c93">More...</a><br /></td></tr>
<tr class="separator:a3c2f93547af434566184b7dee7039c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb750da00c784e5ffd1763fd3ce88f7"><td class="memTemplParams" colspan="2">template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a4fb750da00c784e5ffd1763fd3ce88f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a4fb750da00c784e5ffd1763fd3ce88f7">MakeConstraintDemon1</a> (<a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const s, T *const ct, void(T::*method)(P), const std::string &amp;name, P param1)</td></tr>
<tr class="separator:a4fb750da00c784e5ffd1763fd3ce88f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da629cafe75f958924e1684ac2b0eff"><td class="memTemplParams" colspan="2">template&lt;class T , class P , class Q &gt; </td></tr>
<tr class="memitem:a4da629cafe75f958924e1684ac2b0eff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a4da629cafe75f958924e1684ac2b0eff">MakeConstraintDemon2</a> (<a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const s, T *const ct, void(T::*method)(P, Q), const std::string &amp;name, P param1, Q param2)</td></tr>
<tr class="separator:a4da629cafe75f958924e1684ac2b0eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdca98f14c02e004ab5e19d2c3985667"><td class="memTemplParams" colspan="2">template&lt;class T , class P , class Q , class R &gt; </td></tr>
<tr class="memitem:abdca98f14c02e004ab5e19d2c3985667"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#abdca98f14c02e004ab5e19d2c3985667">MakeConstraintDemon3</a> (<a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const s, T *const ct, void(T::*method)(P, Q, R), const std::string &amp;name, P param1, Q param2, R param3)</td></tr>
<tr class="separator:abdca98f14c02e004ab5e19d2c3985667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a82110ba1f45aa29ffc933102880dbd82"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a82110ba1f45aa29ffc933102880dbd82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a82110ba1f45aa29ffc933102880dbd82">MakeDelayedConstraintDemon0</a> (<a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const s, T *const ct, void(T::*method)(), const std::string &amp;name)</td></tr>
<tr class="separator:a82110ba1f45aa29ffc933102880dbd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f4a7dbafd8e00a36b892a82e44445f"><td class="memTemplParams" colspan="2">template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a11f4a7dbafd8e00a36b892a82e44445f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a11f4a7dbafd8e00a36b892a82e44445f">MakeDelayedConstraintDemon1</a> (<a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const s, T *const ct, void(T::*method)(P), const std::string &amp;name, P param1)</td></tr>
<tr class="separator:a11f4a7dbafd8e00a36b892a82e44445f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b8113bf656aa61493c9459508ed953"><td class="memTemplParams" colspan="2">template&lt;class T , class P , class Q &gt; </td></tr>
<tr class="memitem:a29b8113bf656aa61493c9459508ed953"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a29b8113bf656aa61493c9459508ed953">MakeDelayedConstraintDemon2</a> (<a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const s, T *const ct, void(T::*method)(P, Q), const std::string &amp;name, P param1, Q param2)</td></tr>
<tr class="separator:a29b8113bf656aa61493c9459508ed953"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a144750b8ec3f03decd898cc08c6b2894"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a144750b8ec3f03decd898cc08c6b2894">starts_ends</a></td></tr>
<tr class="separator:a144750b8ec3f03decd898cc08c6b2894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86181cc5dff70e9ce3bfa1f8393cb6a"><td class="memItemLeft" align="right" valign="top">**&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad86181cc5dff70e9ce3bfa1f8393cb6a">Then</a></td></tr>
<tr class="separator:ad86181cc5dff70e9ce3bfa1f8393cb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88484804c6e66958d00fb3f1b0821b82"><td class="memItemLeft" align="right" valign="top">FirstSolutionStrategyDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a88484804c6e66958d00fb3f1b0821b82">_FirstSolutionStrategy_default_instance_</a></td></tr>
<tr class="separator:a88484804c6e66958d00fb3f1b0821b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e179c1aa71c3f208d4dfbd8a27bfdc3"><td class="memItemLeft" align="right" valign="top">LocalSearchMetaheuristicDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a5e179c1aa71c3f208d4dfbd8a27bfdc3">_LocalSearchMetaheuristic_default_instance_</a></td></tr>
<tr class="separator:a5e179c1aa71c3f208d4dfbd8a27bfdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aec91f2a6b9e10f98ded28a1df2925b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362c">FirstSolutionStrategy_Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a9aec91f2a6b9e10f98ded28a1df2925b">FirstSolutionStrategy_Value_Value_MIN</a> = <a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362cad02e019c28342793688466400afd032d">FirstSolutionStrategy_Value_UNSET</a></td></tr>
<tr class="separator:a9aec91f2a6b9e10f98ded28a1df2925b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999203a7a00dc983c437624201cdbce2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362c">FirstSolutionStrategy_Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a999203a7a00dc983c437624201cdbce2">FirstSolutionStrategy_Value_Value_MAX</a> = <a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca6c8e1e7a2859125316fe07082a2da868">FirstSolutionStrategy_Value_AUTOMATIC</a></td></tr>
<tr class="separator:a999203a7a00dc983c437624201cdbce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8e1305d7b00c52172281a44baad6c2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a9e8e1305d7b00c52172281a44baad6c2">FirstSolutionStrategy_Value_Value_ARRAYSIZE</a> = <a class="el" href="namespaceoperations__research.html#a999203a7a00dc983c437624201cdbce2">FirstSolutionStrategy_Value_Value_MAX</a> + 1</td></tr>
<tr class="separator:a9e8e1305d7b00c52172281a44baad6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3713cc7fe59ec4df14e26ac0310cf0e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77">LocalSearchMetaheuristic_Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a3713cc7fe59ec4df14e26ac0310cf0e5">LocalSearchMetaheuristic_Value_Value_MIN</a> = <a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77ab1177884bf5c3fda2cac819cca8279ec">LocalSearchMetaheuristic_Value_UNSET</a></td></tr>
<tr class="separator:a3713cc7fe59ec4df14e26ac0310cf0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aef277165b7aacec371daebe466690"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77">LocalSearchMetaheuristic_Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a86aef277165b7aacec371daebe466690">LocalSearchMetaheuristic_Value_Value_MAX</a> = <a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77a883a6e25cd8984a9e4e06636823f7201">LocalSearchMetaheuristic_Value_AUTOMATIC</a></td></tr>
<tr class="separator:a86aef277165b7aacec371daebe466690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd8517c34ce555a83981c8cc3a00d3c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a4fd8517c34ce555a83981c8cc3a00d3c">LocalSearchMetaheuristic_Value_Value_ARRAYSIZE</a> = <a class="el" href="namespaceoperations__research.html#a86aef277165b7aacec371daebe466690">LocalSearchMetaheuristic_Value_Value_MAX</a> + 1</td></tr>
<tr class="separator:a4fd8517c34ce555a83981c8cc3a00d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a853384e4e580582b670a57018029d"><td class="memItemLeft" align="right" valign="top">RoutingModelParametersDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ae3a853384e4e580582b670a57018029d">_RoutingModelParameters_default_instance_</a></td></tr>
<tr class="separator:ae3a853384e4e580582b670a57018029d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601e1a7c230fbf44503db528b20e30ca"><td class="memItemLeft" align="right" valign="top">RoutingSearchParametersDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a601e1a7c230fbf44503db528b20e30ca">_RoutingSearchParameters_default_instance_</a></td></tr>
<tr class="separator:a601e1a7c230fbf44503db528b20e30ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595bafdd2ca0348c23f2c03da8ef2468"><td class="memItemLeft" align="right" valign="top">RoutingSearchParameters_LocalSearchNeighborhoodOperatorsDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a595bafdd2ca0348c23f2c03da8ef2468">_RoutingSearchParameters_LocalSearchNeighborhoodOperators_default_instance_</a></td></tr>
<tr class="separator:a595bafdd2ca0348c23f2c03da8ef2468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d06964c51cd718a2a5c620c3289f7e"><td class="memItemLeft" align="right" valign="top">MPConstraintProtoDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a11d06964c51cd718a2a5c620c3289f7e">_MPConstraintProto_default_instance_</a></td></tr>
<tr class="separator:a11d06964c51cd718a2a5c620c3289f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18f88184af1e6b0197a98cf0485803f"><td class="memItemLeft" align="right" valign="top">MPGeneralConstraintProtoDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab18f88184af1e6b0197a98cf0485803f">_MPGeneralConstraintProto_default_instance_</a></td></tr>
<tr class="separator:ab18f88184af1e6b0197a98cf0485803f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa4d06ad0beb392a3144747d83fcc2c"><td class="memItemLeft" align="right" valign="top">MPIndicatorConstraintDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a1fa4d06ad0beb392a3144747d83fcc2c">_MPIndicatorConstraint_default_instance_</a></td></tr>
<tr class="separator:a1fa4d06ad0beb392a3144747d83fcc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa214723b84fc52d727efc5067df690e2"><td class="memItemLeft" align="right" valign="top">MPModelProtoDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa214723b84fc52d727efc5067df690e2">_MPModelProto_default_instance_</a></td></tr>
<tr class="separator:aa214723b84fc52d727efc5067df690e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5557bc052354d9b956a609d0698281d5"><td class="memItemLeft" align="right" valign="top">MPModelRequestDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a5557bc052354d9b956a609d0698281d5">_MPModelRequest_default_instance_</a></td></tr>
<tr class="separator:a5557bc052354d9b956a609d0698281d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c99a96a8b2fcf4ab6890a4717c92da5"><td class="memItemLeft" align="right" valign="top">MPSolutionResponseDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a9c99a96a8b2fcf4ab6890a4717c92da5">_MPSolutionResponse_default_instance_</a></td></tr>
<tr class="separator:a9c99a96a8b2fcf4ab6890a4717c92da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ece0f2b42b6eaf443223377343e1966"><td class="memItemLeft" align="right" valign="top">MPSolverCommonParametersDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a7ece0f2b42b6eaf443223377343e1966">_MPSolverCommonParameters_default_instance_</a></td></tr>
<tr class="separator:a7ece0f2b42b6eaf443223377343e1966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dce953fd737d51dcb003b93452b3b6"><td class="memItemLeft" align="right" valign="top">MPVariableProtoDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#af3dce953fd737d51dcb003b93452b3b6">_MPVariableProto_default_instance_</a></td></tr>
<tr class="separator:af3dce953fd737d51dcb003b93452b3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd6483b24c303a0fbf9ab49846d370c"><td class="memItemLeft" align="right" valign="top">OptionalDoubleDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a5fd6483b24c303a0fbf9ab49846d370c">_OptionalDouble_default_instance_</a></td></tr>
<tr class="separator:a5fd6483b24c303a0fbf9ab49846d370c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92dae0b80b47779fc1de1bf9e7df9dd"><td class="memItemLeft" align="right" valign="top">PartialVariableAssignmentDefaultTypeInternal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ac92dae0b80b47779fc1de1bf9e7df9dd">_PartialVariableAssignment_default_instance_</a></td></tr>
<tr class="separator:ac92dae0b80b47779fc1de1bf9e7df9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4803399c53b73b9ae985751803d01a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85f">MPSolverCommonParameters_LPAlgorithmValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a1e4803399c53b73b9ae985751803d01a">MPSolverCommonParameters_LPAlgorithmValues_LPAlgorithmValues_MIN</a> = <a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85fa2218d316cfcac5a88342c95b188f3fda">MPSolverCommonParameters_LPAlgorithmValues_LP_ALGO_UNSPECIFIED</a></td></tr>
<tr class="separator:a1e4803399c53b73b9ae985751803d01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35686dabc230ba01c79fb8fd0f457e40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85f">MPSolverCommonParameters_LPAlgorithmValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a35686dabc230ba01c79fb8fd0f457e40">MPSolverCommonParameters_LPAlgorithmValues_LPAlgorithmValues_MAX</a> = <a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85fa89ff8ffa01928d5993a1414705eecd15">MPSolverCommonParameters_LPAlgorithmValues_LP_ALGO_BARRIER</a></td></tr>
<tr class="separator:a35686dabc230ba01c79fb8fd0f457e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc5431b0bd4640975c7f6502e8013d9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a5dc5431b0bd4640975c7f6502e8013d9">MPSolverCommonParameters_LPAlgorithmValues_LPAlgorithmValues_ARRAYSIZE</a> = <a class="el" href="namespaceoperations__research.html#a35686dabc230ba01c79fb8fd0f457e40">MPSolverCommonParameters_LPAlgorithmValues_LPAlgorithmValues_MAX</a> + 1</td></tr>
<tr class="separator:a5dc5431b0bd4640975c7f6502e8013d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e0cbbffcf3c459144e44b3f00dc2bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5">MPModelRequest_SolverType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a33e0cbbffcf3c459144e44b3f00dc2bf">MPModelRequest_SolverType_SolverType_MIN</a> = <a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5a0969851c637668f95c10ddb1ade866a7">MPModelRequest_SolverType_CLP_LINEAR_PROGRAMMING</a></td></tr>
<tr class="separator:a33e0cbbffcf3c459144e44b3f00dc2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955948242965463248545e1785583654"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5">MPModelRequest_SolverType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a955948242965463248545e1785583654">MPModelRequest_SolverType_SolverType_MAX</a> = <a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5ac0fedb2082db5e7c96da01b4149c318e">MPModelRequest_SolverType_SAT_INTEGER_PROGRAMMING</a></td></tr>
<tr class="separator:a955948242965463248545e1785583654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6eb74cbdb5037acc1fb265d11616274"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ae6eb74cbdb5037acc1fb265d11616274">MPModelRequest_SolverType_SolverType_ARRAYSIZE</a> = <a class="el" href="namespaceoperations__research.html#a955948242965463248545e1785583654">MPModelRequest_SolverType_SolverType_MAX</a> + 1</td></tr>
<tr class="separator:ae6eb74cbdb5037acc1fb265d11616274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5325d95fb273624f43bf2741836834"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56">MPSolverResponseStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aaf5325d95fb273624f43bf2741836834">MPSolverResponseStatus_MIN</a> = <a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56ac95cb5be9e36b31647dd28910ac6cae4">MPSOLVER_OPTIMAL</a></td></tr>
<tr class="separator:aaf5325d95fb273624f43bf2741836834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f022bd33162332383c5f70e4821498"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56">MPSolverResponseStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a92f022bd33162332383c5f70e4821498">MPSolverResponseStatus_MAX</a> = <a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56a84ea2a63b24de389aac6aa33b1203cd4">MPSOLVER_UNKNOWN_STATUS</a></td></tr>
<tr class="separator:a92f022bd33162332383c5f70e4821498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04af4e3a977e967ddd2f2db792ac2ad7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a04af4e3a977e967ddd2f2db792ac2ad7">MPSolverResponseStatus_ARRAYSIZE</a> = <a class="el" href="namespaceoperations__research.html#a92f022bd33162332383c5f70e4821498">MPSolverResponseStatus_MAX</a> + 1</td></tr>
<tr class="separator:a04af4e3a977e967ddd2f2db792ac2ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. </p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. <a class="el" href="classoperations__research_1_1ChristofidesPathSolver.html">ChristofidesPathSolver</a> computes an approximate solution to the Traveling Salesman Problen using the Christofides algorithm (c.f. <a href="https://en.wikipedia.org/wiki/Christofides_algorithm">https://en.wikipedia.org/wiki/Christofides_algorithm</a>). </p><dl class="section note"><dt>Note</dt><dd>the algorithm guarantees finding a solution within 3/2 of the optimum. Its complexity is O(n^2 * log(n)) where n is the number of nodes.</dd></dl>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Maximal clique algorithms, based on the Bron-Kerbosch algorithm. See <a href="http://en.wikipedia.org/wiki/Bron-Kerbosch_algorithm">http://en.wikipedia.org/wiki/Bron-Kerbosch_algorithm</a> and C. Bron and J. Kerbosch, Joep, "Algorithm 457: finding all cliques of an
undirected graph", CACM 16 (9): 575-577, 1973. <a href="http://dl.acm.org/citation.cfm?id=362367&bnc=1">http://dl.acm.org/citation.cfm?id=362367&amp;bnc=1</a>.</p>
<p>Keywords: undirected graph, clique, clique cover, Bron, Kerbosch.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Graph connectivity algorithm for undirected graphs. Memory consumption: O(n) where m is the number of arcs and n the number of nodes. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000050">Todo:</a></b></dt><dd><p class="startdd">(user): add depth-first-search based connectivity for directed graphs. </p>
<p class="enddd">(user): add depth-first-search based biconnectivity for directed graphs. </p>
</dd></dl>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. A few variations on a theme of the "star" graph representation by Ebert, as described in J. Ebert, "A versatile data structure for
edge-oriented graph algorithms." Communications of the ACM 30(6):513-519 (June 1987). <a href="http://portal.acm.org/citation.cfm?id=214769">http://portal.acm.org/citation.cfm?id=214769</a></p>
<p>In this file there are three representations that have much in common. The general one, called simply <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a>, contains both forward- and backward-star representations. The other, called <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html" title="A forward-star-only graph representation for greater efficiency in those algorithms that don&#39;t need r...">ForwardEbertGraph</a>, contains only the forward-star representation of the graph, and is appropriate for applications where the reverse arcs are not needed.</p>
<p>The point of including all the representations in this one file is to capitalize, where possible, on the commonalities among them, and those commonalities are mostly factored out into base classes as described below. Despite the commonalities, however, each of the three representations presents a somewhat different interface because of their different underlying semantics. A quintessential example is that the AddArc() method, very natural for the <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> representation, cannot exist for an inherently static representation like <a class="el" href="classoperations__research_1_1ForwardStaticGraph.html">ForwardStaticGraph</a>.</p>
<p>Many clients are expected to use the interfaces to the graph objects directly, but some clients are parameterized by graph type and need a consistent interface for their underlying graph objects. For such clients, a small library of class templates is provided to give a consistent interface to clients where the underlying graph interfaces differ. Examples are the AnnotatedGraphBuildManager&lt;&gt; template, which provides a uniform interface for building the various types of graphs; and the TailArrayManager&lt;&gt; template, which provides a uniform interface for applications that need to map from arc indices to arc tail nodes, accounting for the fact that such a mapping has to be requested explicitly from the <a class="el" href="classoperations__research_1_1ForwardStaticGraph.html">ForwardStaticGraph</a> and ForwardStarGraph representations.</p>
<p>There are two base class templates, <a class="el" href="classoperations__research_1_1StarGraphBase.html">StarGraphBase</a>, and <a class="el" href="classoperations__research_1_1EbertGraphBase.html" title="A template for the base class that holds the functionality that exists in common between the EbertGra...">EbertGraphBase</a>; their purpose is to hold methods and data structures that are in common among their descendants. Only classes that are leaves in the following hierarchy tree are eligible for free-standing instantiation and use by clients. The parentheses around <a class="el" href="classoperations__research_1_1StarGraphBase.html">StarGraphBase</a> and <a class="el" href="classoperations__research_1_1EbertGraphBase.html" title="A template for the base class that holds the functionality that exists in common between the EbertGra...">EbertGraphBase</a> indicate that they should not normally be instantiated by clients: </p><div class="fragment"><div class="line">               (StarGraphBase)                       |</div><div class="line">                 /         \                         |</div><div class="line">                /           \                        |</div><div class="line">               /             \                       |</div><div class="line">              /               \                      |</div><div class="line">     (EbertGraphBase)     ForwardStaticGraph         |</div><div class="line">      /            \                                 |</div><div class="line">     /              \                                |</div><div class="line">EbertGraph     ForwardEbertGraph                     |</div></div><!-- fragment --><p> In the general <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> case, the graph is represented with three arrays. Let n be the number of nodes and m be the number of arcs. Let i be an integer in [0..m-1], denoting the index of an arc.</p><ul>
<li>head_[i] contains the end-node of arc i,</li>
<li>head_[-i-1] contains the start-node of arc i. <dl class="section note"><dt>Note</dt><dd>in two's-complement arithmetic, -i-1 = ~i. Consequently:</dd></dl>
</li>
<li>head_[~i] contains the end-node of the arc reverse to arc i,</li>
<li>head_[i] contains the start-node of the arc reverse to arc i. <dl class="section note"><dt>Note</dt><dd>if arc (u, v) is defined, then the data structure also stores (v, u). Arc ~i thus denotes the arc reverse to arc i. This is what makes this representation useful for undirected graphs and for implementing algorithms like bidirectional shortest paths. Also note that the representation handles multi-graphs. If several arcs going from node u to node v are added to the graph, they will be handled as separate arcs.</dd></dl>
Now, for an integer u in [0..n-1] denoting the index of a node:</li>
<li>first_incident_arc_[u] denotes the first arc in the adjacency list of u.</li>
<li>going from an arc i, the adjacency list can be traversed using j = next_adjacent_arc_[i].</li>
</ul>
<p>The <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> implementation has the following benefits:</p><ul>
<li>It is able to handle both directed or undirected graphs.</li>
<li>Being based on indices, it is easily serializable. Only the contents of the head_ array need to be stored. Even so, serialization is currently not implemented.</li>
<li>The node indices and arc indices can be stored in 32 bits, while still allowing to go a bit further than the 4-gigabyte limitation (48 gigabytes for a pure graph, without capacities or costs.)</li>
<li>The representation can be recomputed if edges have been loaded from</li>
<li>The representation can be recomputed if edges have been loaded from external memory or if edges have been re-ordered.</li>
<li>The memory consumption is: 2 * m * sizeof(NodeIndexType)<ul>
<li>2 * m * sizeof(ArcIndexType)</li>
<li>n * sizeof(ArcIndexType) plus a small constant.</li>
</ul>
</li>
</ul>
<p>The <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> implementation differs from the implementation described in [Ebert 1987] in the following respects:</p><ul>
<li>arcs are represented using an (i, ~i) approach, whereas Ebert used (i, -i). Indices for direct arcs thus start at 0, in a fashion that is compatible with the index numbering in C and C++. Note that we also tested a (2*i, 2*i+1) storage pattern, which did not show any speed benefit, and made the use of the API much more difficult.</li>
<li>because of this, the 'nil' values for nodes and arcs are not 0, as Ebert first described. The value for the 'nil' node is set to -1, while the value for the 'nil' arc is set to the smallest integer representable with ArcIndexSize bytes.</li>
<li>it is possible to add arcs to the graph, with AddArc, in a much simpler way than described by Ebert.</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000052">Todo:</a></b></dt><dd>(user) although it is already possible, using the GroupForwardArcsByFunctor method, to group all the outgoing (resp. incoming) arcs of a node, the iterator logic could still be improved to allow traversing the outgoing (resp. incoming) arcs in O(out_degree(node)) (resp. O(in_degree(node))) instead of O(degree(node)).</dd></dl>
</li>
</ul>
<p>The <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html" title="A forward-star-only graph representation for greater efficiency in those algorithms that don&#39;t need r...">ForwardEbertGraph</a> representation is like the <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> case described above, with the following modifications:</p><ul>
<li>The part of the head_[] array with negative indices is absent. In its place is a pointer tail_ which, if assigned, points to an array of tail nodes indexed by (nonnegative) arc index. In typical usage tail_ is NULL and the memory for the tail nodes need not be allocated.</li>
<li>The array of arc tails can be allocated as needed and populated from the adjacency lists of the graph.</li>
<li>Representing only the forward star of each node implies that the graph cannot be serialized directly nor rebuilt from scratch from just the head_ array. Rebuilding from scratch requires constructing the array of arc tails from the adjacency lists first, and serialization can be done either by first constructing the array of arc tails from the adjacency lists, or by serializing directly from the adjacency lists.</li>
<li>The memory consumption is: m * sizeof(NodeIndexType)<ul>
<li>m * sizeof(ArcIndexType)</li>
<li>n * sizeof(ArcIndexType) plus a small constant when the array of arc tails is absent. Allocating the arc tail array adds another m * sizeof(NodeIndexType).</li>
</ul>
</li>
</ul>
<p>The <a class="el" href="classoperations__research_1_1ForwardStaticGraph.html">ForwardStaticGraph</a> representation is restricted yet farther than <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html" title="A forward-star-only graph representation for greater efficiency in those algorithms that don&#39;t need r...">ForwardEbertGraph</a>, with the benefit that it provides higher performance to those applications that can use it.</p><ul>
<li>As with <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html" title="A forward-star-only graph representation for greater efficiency in those algorithms that don&#39;t need r...">ForwardEbertGraph</a>, the presence of the array of arc tails is optional.</li>
<li>The outgoing adjacency list for each node is stored in a contiguous segment of the head_[] array, obviating the next_adjacent_arc_ structure entirely and ensuring good locality of reference for applications that iterate over outgoing adjacency lists.</li>
<li>The memory consumption is: m * sizeof(NodeIndexType)<ul>
<li>n * sizeof(ArcIndexType) plus a small constant when the array of arc tails is absent. Allocating the arc tail array adds another m * sizeof(NodeIndexType).</li>
</ul>
</li>
</ul>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Utility to build Eulerian paths and tours on a graph. For more information, see <a href="https://en.wikipedia.org/wiki/Eulerian_path">https://en.wikipedia.org/wiki/Eulerian_path</a>. As of 10/2015, only undirected graphs are supported.</p>
<p>Usage:</p><ul>
<li>Building an Eulerian tour on a ReverseArcListGraph: ReverseArcListGraph&lt;int, int&gt; graph; ///&lt; Fill graph std::vector&lt;int&gt; tour = BuildEulerianTour(graph);</li>
<li>Building an Eulerian path on a ReverseArcListGraph: ReverseArcListGraph&lt;int, int&gt; graph; ///&lt; Fill graph std::vector&lt;int&gt; tour = BuildEulerianPath(graph);</li>
</ul>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Temporary utility class needed as long as we have two slightly different graph interface: The one in <a class="el" href="ebert__graph_8h.html">ebert_graph.h</a> and the one in <a class="el" href="graph_8h.html">graph.h</a></p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Solves the Shortest Hamiltonian Path Problem using a complete algorithm. The algorithm was first described in M. Held, R.M. Karp, A dynamic programming approach to sequencing problems, J. SIAM 10 (1962) 196-210</p>
<p>The Shortest Hamiltonian Path Problem (SHPP) is similar to the Traveling Salesperson Problem (TSP). You have to visit all the cities, starting from a given one and you do not need to return to your starting point. With the TSP, you can start anywhere, but you have to return to your start location.</p>
<p>By complete we mean that the algorithm guarantees to compute the optimal solution. The algorithm uses dynamic programming. Its time complexity is O(n^2 * 2^(n-1)), where n is the number of nodes to be visited, and '^' denotes exponentiation. Its space complexity is O(n * 2 ^ (n - 1)).</p>
<dl class="section note"><dt>Note</dt><dd>the naive implementation of the SHPP exploring all permutations without memorizing intermediate results would have a complexity of (n - 1)! (factorial of (n - 1) ), which is much higher than n^2 * 2^(n-1). To convince oneself of this, just use Stirling's formula: n! ~ sqrt(2 * pi * n)*( n / exp(1)) ^ n. Because of these complexity figures, the algorithm is not practical for problems with more than 20 nodes.</dd></dl>
<p>Here is how the algorithm works: Let us denote the nodes to be visited by their indices 0 .. n - 1 Let us pick 0 as the starting node. Let d(i,j) denote the distance (or cost) from i to j. f(S, j) where S is a set of nodes and j is a node in S is defined as follows: f(S, j) = min (i in S \ {j}, f(S \ {j}, i) + cost(i, j)) (j is an element of S) </p><dl class="section note"><dt>Note</dt><dd>this formulation, from the original Held-Karp paper is a bit different, but equivalent to the one used in Caseau and Laburthe, Solving Small TSPs with Constraints, 1997, ICLP f(S, j) = min (i in S, f(S \ {i}, i) + cost(i, j)) (j is not an element of S)</dd></dl>
<p>The advantage of the Held and Karp formulation is that it enables:</p><ul>
<li>to build the dynamic programming lattice layer by layer starting from the subsets with cardinality 1, and increasing the cardinality.</li>
<li>to traverse the dynamic programming lattice using sequential memory accesses, making the algorithm cache-friendly, and faster, despite the large amount of computation needed to get the position when f(S, j) is stored.</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000070">Todo:</a></b></dt><dd>(user): implement pruning procedures on top of the Held-Karp algorithm.</dd></dl>
</li>
</ul>
<p>The set S can be represented by an integer where bit i corresponds to element i in the set. In the following S denotes the integer corresponding to set S.</p>
<p>The dynamic programming iteration is implemented in the method Solve. The optimal value of the Hamiltonian path starting at 0 is given by min (i in S, f(2 ^ n - 1, i)) The optimal value of the Traveling Salesman tour is given by f(2 ^ n, 0). (There is actually no need to duplicate the first node, as all the paths are computed from node 0.)</p>
<p>To implement dynamic programming, we store the preceding results of computing f(S,j) in an array M[Offset(S,j)]. See the comments about <a class="el" href="classoperations__research_1_1LatticeMemoryManager.html#a5369cd69622c4264ffcf11a2d5006ecd" title="Returns the base offset in memory for f(s, node), with node contained in s.">LatticeMemoryManager::BaseOffset()</a> to see how this is computed.</p>
<p>Keywords: Traveling Salesman, Hamiltonian Path, Dynamic Programming, Held, Karp.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. An implementation of a push-relabel algorithm for the max flow problem.</p>
<p>In the following, we consider a graph G = (V,E,s,t) where V denotes the set of nodes (vertices) in the graph, E denotes the set of arcs (edges). s and t denote distinguished nodes in G called source and target. n = <code>V</code> denotes the number of nodes in the graph, and m = <code>E</code> denotes the number of arcs in the graph.</p>
<p>Each arc (v,w) is associated a capacity c(v,w).</p>
<p>A flow is a function from E to R such that:</p>
<p>a) f(v,w) &lt;= c(v,w) for all (v,w) in E (capacity constraint.)</p>
<p>b) f(v,w) = -f(w,v) for all (v,w) in E (flow antisymmetry constraint.)</p>
<p>c) sum on v f(v,w) = 0 (flow conservation.)</p>
<p>The goal of this algorithm is to find the maximum flow from s to t, i.e. for example to maximize sum v f(s,v).</p>
<p>The starting reference for this class of algorithms is: A.V. Goldberg and R.E. Tarjan. A new approach to the maximum flow problem. ACM Symposium on Theory of Computing, pp. 136-146. <a href="http://portal.acm.org/citation.cfm?id=12144">http://portal.acm.org/citation.cfm?id=12144</a>.</p>
<p>The basic idea of the algorithm is to handle preflows instead of flows, and to refine preflows until a maximum flow is obtained. A preflow is like a flow, except that the inflow can be larger than the outflow. If it is the case at a given node v, it is said that there is an excess at node v, and inflow = outflow + excess.</p>
<p>More formally, a preflow is a function f such that:</p>
<p>1) f(v,w) &lt;= c(v,w) for all (v,w) in E (capacity constraint). c(v,w) is a value representing the maximum capacity for arc (v,w).</p>
<p>2) f(v,w) = -f(w,v) for all (v,w) in E (flow antisymmetry constraint)</p>
<p>3) excess(v) = sum on u f(u,v) &gt;= 0 is the excess at node v, the algebraic sum of all the incoming preflows at this node.</p>
<p>Each node has an associated "height", in addition to its excess. The height of the source is defined to be equal to n, and cannot change. The height of the target is defined to be zero, and cannot change either. The height of all the other nodes is initialized at zero and is updated during the algorithm (see below). For those who want to know the details, the height of a node, corresponds to a reduced cost, and this enables one to prove that the algorithm actually computes the max flow. Note that the height of a node can be initialized to the distance to the target node in terms of number of nodes. This has not been tried in this implementation.</p>
<p>A node v is said to be <em>active</em> if excess(v) &gt; 0.</p>
<p>In this case the following operations can be applied to it:</p>
<ul>
<li>if there are <em>admissible</em> incident arcs, i.e. arcs which are not saturated, and whose head's height is lower than the height of the active node considered, a PushFlow operation can be applied. It consists in sending as much flow as both the excess at the node and the capacity of the arc permit.</li>
<li>if there are no admissible arcs, the active node considered is relabeled, i.e. its height is increased to 1 + the minimum height of its neighboring nodes on admissible arcs. This is implemented in Discharge, which itself calls PushFlow and Relabel.</li>
</ul>
<p>Before running Discharge, it is necessary to initialize the algorithm with a preflow. This is done in InitializePreflow, which saturates all the arcs leaving the source node, and sets the excess at the heads of those arcs accordingly.</p>
<p>The algorithm terminates when there are no remaining active nodes, i.e. all the excesses at all nodes are equal to zero. In this case, a maximum flow is obtained.</p>
<p>The complexity of this algorithm depends amongst other things on the choice of the next active node. It has been shown, for example in: L. Tuncel, "On the Complexity of Preflow-Push Algorithms for Maximum-Flow
Problems", Algorithmica 11(4): 353-359 (1994). and J. Cheriyan and K. Mehlhorn, "An analysis of the highest-level selection rule
in the preflow-push max-flow algorithm", Information processing letters, 69(5):239-242 (1999). <a href="http://www.math.uwaterloo.ca/~jcheriya/PS_files/me3.0.ps">http://www.math.uwaterloo.ca/~jcheriya/PS_files/me3.0.ps</a></p>
<p>...that choosing the active node with the highest level yields a complexity of O(n^2 * sqrt(m)).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000085">Todo:</a></b></dt><dd>(user): implement the above active node choice rule.</dd></dl>
<p>This has been validated experimentally in: R.K. Ahuja, M. Kodialam, A.K. Mishra, and J.B. Orlin, "Computational
Investigations of Maximum Flow Algorithms", EJOR 97:509-542(1997). <a href="http://jorlin.scripts.mit.edu/docs/publications/58-comput%20investigations%20of.pdf">http://jorlin.scripts.mit.edu/docs/publications/58-comput%20investigations%20of.pdf</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000086">Todo:</a></b></dt><dd>(user): an alternative would be to evaluate: A.V. Goldberg, "The Partial Augment-Relabel Algorithm for the Maximum Flow Problem.” In Proceedings of Algorithms ESA, LNCS 5193:466-477, Springer 2008. <a href="http://www.springerlink.com/index/5535k2j1mt646338.pdf">http://www.springerlink.com/index/5535k2j1mt646338.pdf</a></dd></dl>
<p>An interesting general reference on network flows is: R. K. Ahuja, T. L. Magnanti, J. B. Orlin, "Network Flows: Theory, Algorithms,
and Applications," Prentice Hall, 1993, ISBN: 978-0136175490, <a href="http://www.amazon.com/dp/013617549X">http://www.amazon.com/dp/013617549X</a></p>
<p>Keywords: Push-relabel, max-flow, network, graph, Goldberg, Tarjan, Dinic, Dinitz.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. An implementation of a cost-scaling push-relabel algorithm for the min-cost flow problem.</p>
<p>In the following, we consider a graph G = (V,E) where V denotes the set of nodes (vertices) in the graph, E denotes the set of arcs (edges). n = <code>V</code> denotes the number of nodes in the graph, and m = <code>E</code> denotes the number of arcs in the graph.</p>
<p>With each arc (v,w) is associated a nonnegative capacity u(v,w) (where 'u' stands for "upper bound") and a unit cost c(v,w). With each node v is associated a quantity named supply(v), which represents a supply of fluid (if &gt;0) or a demand (if &lt;0). Furthermore, no fluid is created in the graph so sum_{v in V} supply(v) = 0.</p>
<p>A flow is a function from E to R such that: a) f(v,w) &lt;= u(v,w) for all (v,w) in E (capacity constraint). b) f(v,w) = -f(w,v) for all (v,w) in E (flow antisymmetry constraint). c) sum on v f(v,w) + supply(w) = 0 (flow conservation).</p>
<p>The cost of a flow is sum on (v,w) in E ( f(v,w) * c(v,w) ) [Note: It can be confusing to beginners that the cost is actually double the amount that it might seem at first because of flow antisymmetry.]</p>
<p>The problem to solve: find a flow of minimum cost such that all the fluid flows from the supply nodes to the demand nodes.</p>
<p>The principles behind this algorithm are the following: 1/ handle pseudo-flows instead of flows and refine pseudo-flows until an epsilon-optimal minimum-cost flow is obtained, 2/ deal with epsilon-optimal pseudo-flows.</p>
<p>1/ A pseudo-flow is like a flow, except that a node's outflow minus its inflow can be different from its supply. If it is the case at a given node v, it is said that there is an excess (or deficit) at node v. A deficit is denoted by a negative excess and inflow = outflow + excess. (Look at <a class="el" href="max__flow_8h.html">ortools/graph/max_flow.h</a> to see that the definition of preflow is more restrictive than the one for pseudo-flow in that a preflow only allows non-negative excesses, i.e., no deficit.) More formally, a pseudo-flow is a function f such that: a) f(v,w) &lt;= u(v,w) for all (v,w) in E (capacity constraint). b) f(v,w) = -f(w,v) for all (v,w) in E (flow antisymmetry constraint).</p>
<p>For each v in E, we also define the excess at node v, the algebraic sum of all the incoming preflows at this node, added together with the supply at v. excess(v) = sum on u f(u,v) + supply(v)</p>
<p>The goal of the algorithm is to obtain excess(v) = 0 for all v in V, while consuming capacity on some arcs, at the lowest possible cost.</p>
<p>2/ Internally to the algorithm and its analysis (but invisibly to the client), each node has an associated "price" (or potential), in addition to its excess. It is formally a function from E to R (the set of real numbers.). For a given price function p, the reduced cost of an arc (v,w) is: c_p(v,w) = c(v,w) + p(v) - p(w) (c(v,w) is the cost of arc (v,w).) For those familiar with linear programming, the price function can be viewed as a set of dual variables.</p>
<p>For a constant epsilon &gt;= 0, a pseudo-flow f is said to be epsilon-optimal with respect to a price function p if for every residual arc (v,w) in E, c_p(v,w) &gt;= -epsilon.</p>
<p>A flow f is optimal if and only if there exists a price function p such that no arc is admissible with respect to f and p.</p>
<p>If the arc costs are integers, and epsilon &lt; 1/n, any epsilon-optimal flow is optimal. The integer cost case is handled by multiplying all the arc costs and the initial value of epsilon by (n+1). When epsilon reaches 1, and the solution is epsilon-optimal, it means: for all residual arc (v,w) in E, (n+1) * c_p(v,w) &gt;= -1, thus c_p(v,w) &gt;= -1/(n+1) &gt;= 1/n, and the solution is optimal.</p>
<p>A node v is said to be <em>active</em> if excess(v) &gt; 0. In this case the following operations can be applied to it:</p><ul>
<li>if there are <em>admissible</em> incident arcs, i.e. arcs which are not saturated, and whose reduced costs are negative, a PushFlow operation can be applied. It consists in sending as much flow as both the excess at the node and the capacity of the arc permit.</li>
<li>if there are no admissible arcs, the active node considered is relabeled, This is implemented in Discharge, which itself calls PushFlow and Relabel.</li>
</ul>
<p>Discharge itself is called by Refine. Refine first saturates all the admissible arcs, then builds a stack of active nodes. It then applies Discharge for each active node, possibly adding new ones in the process, until no nodes are active. In that case an epsilon-optimal flow is obtained.</p>
<p>Optimize iteratively calls Refine, while epsilon &gt; 1, and divides epsilon by alpha (set by default to 5) before each iteration.</p>
<p>The algorithm starts with epsilon = C, where C is the maximum absolute value of the arc costs. In the integer case which we are dealing with, since all costs are multiplied by (n+1), the initial value of epsilon is (n+1)*C. The algorithm terminates when epsilon = 1, and Refine() has been called. In this case, a minimum-cost flow is obtained.</p>
<p>The complexity of the algorithm is O(n^2*m*log(n*C)) where C is the value of the largest arc cost in the graph.</p>
<p>IMPORTANT: The algorithm is not able to detect the infeasibility of a problem (i.e., when a bottleneck in the network prohibits sending all the supplies.) Worse, it could in some cases loop forever. This is why feasibility checking is enabled by default (FLAGS_min_cost_flow_check_feasibility=true.) Feasibility checking is implemented using a max-flow, which has a much lower complexity. The impact on performance is negligible, while the risk of being caught in an endless loop is removed. Note that using the feasibility checker roughly doubles the memory consumption.</p>
<p>The starting reference for this class of algorithms is: A.V. Goldberg and R.E. Tarjan, "Finding Minimum-Cost Circulations by
Successive Approximation." Mathematics of Operations Research, Vol. 15, 1990:430-466. <a href="http://portal.acm.org/citation.cfm?id=92225">http://portal.acm.org/citation.cfm?id=92225</a></p>
<p>Implementation issues are tackled in: A.V. Goldberg, "An Efficient Implementation of a Scaling Minimum-Cost Flow
Algorithm," Journal of Algorithms, (1997) 22:1-29 <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.258">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.258</a></p>
<p>A.V. Goldberg and M. Kharitonov, "On Implementing Scaling Push-Relabel
Algorithms for the Minimum-Cost Flow Problem", Network flows and matching: First DIMACS implementation challenge, DIMACS Series in Discrete Mathematics and Theoretical Computer Science, (1993) 12:157-198. <a href="ftp://dimacs.rutgers.edu/pub/netflow/submit/papers/Goldberg-mincost/scalmin.ps">ftp://dimacs.rutgers.edu/pub/netflow/submit/papers/Goldberg-mincost/scalmin.ps</a> and in: ﻿U. Bunnagel, B. Korte, and J. Vygen. “Efficient implementation of the Goldberg-Tarjan minimum-cost flow algorithm.” Optimization Methods and Software (1998) vol. 10, no. 2:157-174. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.84.9897">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.84.9897</a></p>
<p>We have tried as much as possible in this implementation to keep the notations and namings of the papers cited above, except for 'demand' or 'balance' which have been replaced by 'supply', with the according sign changes to better accommodate with the API of the rest of our tools. A demand is denoted by a negative supply.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000093">Todo:</a></b></dt><dd>(user): See whether the following can bring any improvements on real-life problems. R.K. Ahuja, A.V. Goldberg, J.B. Orlin, and R.E. Tarjan, "Finding minimum-cost
flows by double scaling," Mathematical Programming, (1992) 53:243-266. <a href="http://www.springerlink.com/index/gu7404218u6kt166.pdf">http://www.springerlink.com/index/gu7404218u6kt166.pdf</a></dd></dl>
<p>An interesting general reference on network flows is: R. K. Ahuja, T. L. Magnanti, J. B. Orlin, "Network Flows: Theory, Algorithms,
and Applications," Prentice Hall, 1993, ISBN: 978-0136175490, <a href="http://www.amazon.com/dp/013617549X">http://www.amazon.com/dp/013617549X</a></p>
<p>Keywords: Push-relabel, min-cost flow, network, graph, Goldberg, Tarjan, Dinic, Dinitz.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This file contains various shortest paths utilities.</p>
<p>Keywords: directed graph, cheapest path, shortest path, Dijkstra, spp.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This file implements a wrapper around the CP-SAT model proto.</p>
<p>Here is a minimal example that shows how to create a model, solve it, and print out the solution.</p>
<p>CpModelBuilder cp_model; <a class="el" href="classoperations__research_1_1Domain.html" title="We call &quot;domain&quot; any subset of Int64 = [kint64min, kint64max].">Domain</a> all_animals(0, 20); <a class="el" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a> rabbits = cp_model.NewIntVar(all_animals).WithName("rabbits"); <a class="el" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a> pheasants = cp_model.NewIntVar(all_animals).WithName("pheasants");</p>
<p>cp_model.AddEquality(LinearExpr::Sum({rabbits, pheasants}), 20); cp_model.AddEquality(LinearExpr::ScalProd({rabbits, pheasants}, {4, 2}), 56);</p>
<p>const CpSolverResponse response = Solve(cp_model); if (response.status() == CpSolverStatus::FEASIBLE) { LOG(INFO) &lt;&lt; SolutionIntegerValue(response, rabbits) &lt;&lt; " rabbits, and " &lt;&lt; SolutionIntegerValue(response, pheasants) &lt;&lt; " pheasants."; } </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a31d858394c5eed1fa21edc3da47047c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d858394c5eed1fa21edc3da47047c1">&#9670;&nbsp;</a></span>ArcIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32 <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">operations_research::ArcIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00201">201</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="aa79bf252fa6483cd33cbf95170353fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79bf252fa6483cd33cbf95170353fb0">&#9670;&nbsp;</a></span>ArcIndexArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ZVector&lt;<a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a>&gt; <a class="el" href="namespaceoperations__research.html#aa79bf252fa6483cd33cbf95170353fb0">operations_research::ArcIndexArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00208">208</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="afdee62ecefa0520e530c18a55b083e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdee62ecefa0520e530c18a55b083e6d">&#9670;&nbsp;</a></span>CostArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ZVector&lt;<a class="el" href="namespaceoperations__research.html#aa7950685633ee869aa9471b2ec5fbcfa">CostValue</a>&gt; <a class="el" href="namespaceoperations__research.html#afdee62ecefa0520e530c18a55b083e6d">operations_research::CostArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00210">210</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="aa7950685633ee869aa9471b2ec5fbcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7950685633ee869aa9471b2ec5fbcfa">&#9670;&nbsp;</a></span>CostValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64 <a class="el" href="namespaceoperations__research.html#aa7950685633ee869aa9471b2ec5fbcfa">operations_research::CostValue</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00203">203</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="a5841ff601ab08548afb15c45b2245de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5841ff601ab08548afb15c45b2245de7">&#9670;&nbsp;</a></span>FlowQuantity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64 <a class="el" href="namespaceoperations__research.html#a5841ff601ab08548afb15c45b2245de7">operations_research::FlowQuantity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00202">202</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="a652af62fa5f211aa0c54d7994ca1c504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652af62fa5f211aa0c54d7994ca1c504">&#9670;&nbsp;</a></span>ForwardStarGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html">ForwardEbertGraph</a>&lt;<a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>, <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a>&gt; <a class="el" href="namespaceoperations__research.html#a652af62fa5f211aa0c54d7994ca1c504">operations_research::ForwardStarGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00205">205</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="ac7440a08c859325694df19d4d4aee95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7440a08c859325694df19d4d4aee95c">&#9670;&nbsp;</a></span>ForwardStarStaticGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classoperations__research_1_1ForwardStaticGraph.html">ForwardStaticGraph</a>&lt;<a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>, <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a>&gt; <a class="el" href="namespaceoperations__research.html#ac7440a08c859325694df19d4d4aee95c">operations_research::ForwardStarStaticGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00206">206</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="a0e629e35bfa311b31dd7f5065eb834bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e629e35bfa311b31dd7f5065eb834bb">&#9670;&nbsp;</a></span>NodeIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32 <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">operations_research::NodeIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard instantiation of <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html" title="A forward-star-only graph representation for greater efficiency in those algorithms that don&#39;t need r...">ForwardEbertGraph</a> (named 'ForwardStarGraph') of <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> (named 'StarGraph'); and relevant type shortcuts. </p>
<p>Unless their use cases prevent them from doing so, users are encouraged to use StarGraph or ForwardStarGraph according to whether or not they require reverse arcs to be represented explicitly. Along with either graph representation, the other type shortcuts here will often come in handy. </p>

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00192">192</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="a389e5320fb5bcd0fb99d894488f9820b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389e5320fb5bcd0fb99d894488f9820b">&#9670;&nbsp;</a></span>NodeIndexArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ZVector&lt;<a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>&gt; <a class="el" href="namespaceoperations__research.html#a389e5320fb5bcd0fb99d894488f9820b">operations_research::NodeIndexArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00207">207</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="a09767b3634289e432c3ce1d7c649666a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09767b3634289e432c3ce1d7c649666a">&#9670;&nbsp;</a></span>PathNodeIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="namespaceoperations__research.html#a09767b3634289e432c3ce1d7c649666a">operations_research::PathNodeIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hamiltonian__path_8h_source.html#l00450">450</a> of file <a class="el" href="hamiltonian__path_8h_source.html">hamiltonian_path.h</a>.</p>

</div>
</div>
<a id="a7d4fc0319cb4e28ec175fc9163775a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4fc0319cb4e28ec175fc9163775a6e">&#9670;&nbsp;</a></span>QuantityArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ZVector&lt;<a class="el" href="namespaceoperations__research.html#a5841ff601ab08548afb15c45b2245de7">FlowQuantity</a>&gt; <a class="el" href="namespaceoperations__research.html#a7d4fc0319cb4e28ec175fc9163775a6e">operations_research::QuantityArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00209">209</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="a30af988d402f0f3d36640575ca87153c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30af988d402f0f3d36640575ca87153c">&#9670;&nbsp;</a></span>RoutingIndexPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;std::vector&lt;int64&gt;, std::vector&lt;int64&gt; &gt; <a class="el" href="namespaceoperations__research.html#a30af988d402f0f3d36640575ca87153c">operations_research::RoutingIndexPair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NOTE(user): keep the "&gt; &gt;" for SWIG. </p>

<p class="definition">Definition at line <a class="el" href="routing__types_8h_source.html#l00044">44</a> of file <a class="el" href="routing__types_8h_source.html">routing_types.h</a>.</p>

</div>
</div>
<a id="a114ea14886b902c9cf9b988c4ef12672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114ea14886b902c9cf9b988c4ef12672">&#9670;&nbsp;</a></span>RoutingIndexPairs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespaceoperations__research.html#a30af988d402f0f3d36640575ca87153c">RoutingIndexPair</a>&gt; <a class="el" href="namespaceoperations__research.html#a114ea14886b902c9cf9b988c4ef12672">operations_research::RoutingIndexPairs</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__types_8h_source.html#l00045">45</a> of file <a class="el" href="routing__types_8h_source.html">routing_types.h</a>.</p>

</div>
</div>
<a id="a40e66c7b62d7c023af6f08912fdc3f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e66c7b62d7c023af6f08912fdc3f9c">&#9670;&nbsp;</a></span>RoutingTransitCallback1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;int64(int64)&gt; <a class="el" href="namespaceoperations__research.html#a40e66c7b62d7c023af6f08912fdc3f9c">operations_research::RoutingTransitCallback1</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__types_8h_source.html#l00041">41</a> of file <a class="el" href="routing__types_8h_source.html">routing_types.h</a>.</p>

</div>
</div>
<a id="ae7851f8d6518e3180b9d9f0ec69826e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7851f8d6518e3180b9d9f0ec69826e7">&#9670;&nbsp;</a></span>RoutingTransitCallback2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;int64(int64, int64)&gt; <a class="el" href="namespaceoperations__research.html#ae7851f8d6518e3180b9d9f0ec69826e7">operations_research::RoutingTransitCallback2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__types_8h_source.html#l00042">42</a> of file <a class="el" href="routing__types_8h_source.html">routing_types.h</a>.</p>

</div>
</div>
<a id="ad91551404d4eeb115402e25f8ac599b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91551404d4eeb115402e25f8ac599b8">&#9670;&nbsp;</a></span>SequenceVarLocalSearchOperatorTemplate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classoperations__research_1_1VarLocalSearchOperator.html">VarLocalSearchOperator</a>&lt;<a class="el" href="classoperations__research_1_1SequenceVar.html">SequenceVar</a>, std::vector&lt;int&gt;, <a class="el" href="classoperations__research_1_1SequenceVarLocalSearchHandler.html">SequenceVarLocalSearchHandler</a>&gt; <a class="el" href="namespaceoperations__research.html#ad91551404d4eeb115402e25f8ac599b8">operations_research::SequenceVarLocalSearchOperatorTemplate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l01107">1107</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="ae39f15b318a3cba17b1e60e6da51c0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39f15b318a3cba17b1e60e6da51c0d4">&#9670;&nbsp;</a></span>StarGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classoperations__research_1_1EbertGraph.html">EbertGraph</a>&lt;<a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>, <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a>&gt; <a class="el" href="namespaceoperations__research.html#ae39f15b318a3cba17b1e60e6da51c0d4">operations_research::StarGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00204">204</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a708cf34b342e7d2ed89a3b73dbec4eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708cf34b342e7d2ed89a3b73dbec4eae">&#9670;&nbsp;</a></span>BronKerboschAlgorithmStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceoperations__research.html#a708cf34b342e7d2ed89a3b73dbec4eae">operations_research::BronKerboschAlgorithmStatus</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The status value returned by <a class="el" href="classoperations__research_1_1BronKerboschAlgorithm.html#a6dcb077f31531cc17c94da3364b6f099" title="Runs the Bron-Kerbosch algorithm for kint64max iterations.">BronKerboschAlgorithm::Run</a> and <a class="el" href="classoperations__research_1_1BronKerboschAlgorithm.html#a14b12a4c5ea291009f47c1a98c458f81" title="Runs at most &#39;max_num_iterations&#39; iterations of the Bron-Kerbosch algorithm.">BronKerboschAlgorithm::RunIterations</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a708cf34b342e7d2ed89a3b73dbec4eaea8f7afecbc8fbc4cd0f50a57d1172482e"></a>COMPLETED&#160;</td><td class="fielddoc"><p>The algorithm has enumerated all maximal cliques. </p>
</td></tr>
<tr><td class="fieldname"><a id="a708cf34b342e7d2ed89a3b73dbec4eaea658f2cadfdf09b6046246e9314f7cd43"></a>INTERRUPTED&#160;</td><td class="fielddoc"><p>The search algorithm was interrupted either because it reached the iteration limit or because the clique callback returned <a class="el" href="namespaceoperations__research.html#af2d89e69d073dc3036a6de24710b416fa615a46af313786fc4e349f34118be111" title="The algorithm will stop the search immediately.">CliqueResponse::STOP</a>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="cliques_8h_source.html#l00068">68</a> of file <a class="el" href="cliques_8h_source.html">cliques.h</a>.</p>

</div>
</div>
<a id="af2d89e69d073dc3036a6de24710b416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d89e69d073dc3036a6de24710b416f">&#9670;&nbsp;</a></span>CliqueResponse</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceoperations__research.html#af2d89e69d073dc3036a6de24710b416f">operations_research::CliqueResponse</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Possible return values of the callback for reporting cliques. </p>
<p>The returned value determines whether the algorithm will continue the search. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af2d89e69d073dc3036a6de24710b416fa2f453cfe638e57e27bb0c9512436111e"></a>CONTINUE&#160;</td><td class="fielddoc"><p>The algorithm will continue searching for other maximal cliques. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2d89e69d073dc3036a6de24710b416fa615a46af313786fc4e349f34118be111"></a>STOP&#160;</td><td class="fielddoc"><p>The algorithm will stop the search immediately. </p>
<p>The search can be resumed by calling <a class="el" href="classoperations__research_1_1BronKerboschAlgorithm.html#a6dcb077f31531cc17c94da3364b6f099" title="Runs the Bron-Kerbosch algorithm for kint64max iterations.">BronKerboschAlgorithm::Run</a> (resp. RunIterations) again. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="cliques_8h_source.html#l00058">58</a> of file <a class="el" href="cliques_8h_source.html">cliques.h</a>.</p>

</div>
</div>
<a id="ab567c87506c164323ce22036cf4c362c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab567c87506c164323ce22036cf4c362c">&#9670;&nbsp;</a></span>FirstSolutionStrategy_Value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362c">operations_research::FirstSolutionStrategy_Value</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362cad02e019c28342793688466400afd032d"></a>FirstSolutionStrategy_Value_UNSET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca6c8e1e7a2859125316fe07082a2da868"></a>FirstSolutionStrategy_Value_AUTOMATIC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca4c1d8ec510011789f52267efc7d34bb7"></a>FirstSolutionStrategy_Value_PATH_CHEAPEST_ARC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362cae133e7145564aa475a81741a6240e901"></a>FirstSolutionStrategy_Value_PATH_MOST_CONSTRAINED_ARC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca6d0f4bf298a2b6e6462feb7035d2c5de"></a>FirstSolutionStrategy_Value_EVALUATOR_STRATEGY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca2acc1235ef1e7bec84c9a60b010400b7"></a>FirstSolutionStrategy_Value_SAVINGS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca83fd39655867e51be481faa09fbea164"></a>FirstSolutionStrategy_Value_SWEEP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca8a09bb6c57bf531f6674ea171b011791"></a>FirstSolutionStrategy_Value_CHRISTOFIDES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca0c4ad672038428a0f3b3b7f6c92d8840"></a>FirstSolutionStrategy_Value_ALL_UNPERFORMED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362cad0735ef20259782cea2046f90c39bda8"></a>FirstSolutionStrategy_Value_BEST_INSERTION&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362cabba644bd336acdb33aef7257f5bfa536"></a>FirstSolutionStrategy_Value_PARALLEL_CHEAPEST_INSERTION&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca8580f408e6e4af5373e4dd081d59d767"></a>FirstSolutionStrategy_Value_SEQUENTIAL_CHEAPEST_INSERTION&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca348e92318608b985248e17102d016cdd"></a>FirstSolutionStrategy_Value_LOCAL_CHEAPEST_INSERTION&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca9a63d38a1eed11971089af926145f83e"></a>FirstSolutionStrategy_Value_GLOBAL_CHEAPEST_ARC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca451e468bc86902552aa9b987f66f5875"></a>FirstSolutionStrategy_Value_LOCAL_CHEAPEST_ARC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca9c097f678b4aaaa6b10df89dc4d4802e"></a>FirstSolutionStrategy_Value_FIRST_UNBOUND_MIN_VALUE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362ca8cdfd32facff4a66e180fab80f3fb711"></a>FirstSolutionStrategy_Value_FirstSolutionStrategy_Value_INT_MIN_SENTINEL_DO_NOT_USE_&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab567c87506c164323ce22036cf4c362cae584dc12821c9b7171986c986b6c7462"></a>FirstSolutionStrategy_Value_FirstSolutionStrategy_Value_INT_MAX_SENTINEL_DO_NOT_USE_&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="routing__enums_8pb_8h_source.html#l00068">68</a> of file <a class="el" href="routing__enums_8pb_8h_source.html">routing_enums.pb.h</a>.</p>

</div>
</div>
<a id="a96ad216f076775131996dbfd897ace77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ad216f076775131996dbfd897ace77">&#9670;&nbsp;</a></span>LocalSearchMetaheuristic_Value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77">operations_research::LocalSearchMetaheuristic_Value</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a96ad216f076775131996dbfd897ace77ab1177884bf5c3fda2cac819cca8279ec"></a>LocalSearchMetaheuristic_Value_UNSET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a96ad216f076775131996dbfd897ace77a883a6e25cd8984a9e4e06636823f7201"></a>LocalSearchMetaheuristic_Value_AUTOMATIC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a96ad216f076775131996dbfd897ace77a844fc936bb493f6a5d592b28302ea2f1"></a>LocalSearchMetaheuristic_Value_GREEDY_DESCENT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a96ad216f076775131996dbfd897ace77a2909a10cd525473780b35aaa3c4f4eda"></a>LocalSearchMetaheuristic_Value_GUIDED_LOCAL_SEARCH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a96ad216f076775131996dbfd897ace77a0d373c31dbec1678db8b9e50ae63327f"></a>LocalSearchMetaheuristic_Value_SIMULATED_ANNEALING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a96ad216f076775131996dbfd897ace77a63e13a565cf5daf981c1b565912b3b0f"></a>LocalSearchMetaheuristic_Value_TABU_SEARCH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a96ad216f076775131996dbfd897ace77a300fe37f649b909a810935825778b77c"></a>LocalSearchMetaheuristic_Value_GENERIC_TABU_SEARCH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a96ad216f076775131996dbfd897ace77a0783003ef2622becdab73be7bfb66e03"></a>LocalSearchMetaheuristic_Value_LocalSearchMetaheuristic_Value_INT_MIN_SENTINEL_DO_NOT_USE_&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a96ad216f076775131996dbfd897ace77a719d13ec837e44b8b25b0f3315346594"></a>LocalSearchMetaheuristic_Value_LocalSearchMetaheuristic_Value_INT_MAX_SENTINEL_DO_NOT_USE_&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="routing__enums_8pb_8h_source.html#l00103">103</a> of file <a class="el" href="routing__enums_8pb_8h_source.html">routing_enums.pb.h</a>.</p>

</div>
</div>
<a id="a66408fd9c4c05711631d208dce3118f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66408fd9c4c05711631d208dce3118f5">&#9670;&nbsp;</a></span>MPModelRequest_SolverType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5">operations_research::MPModelRequest_SolverType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5a6fab373696058c6e9f279de4a8446411"></a>MPModelRequest_SolverType_GLOP_LINEAR_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5a0969851c637668f95c10ddb1ade866a7"></a>MPModelRequest_SolverType_CLP_LINEAR_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5aa32d84461e16e800e3f996d6347a304d"></a>MPModelRequest_SolverType_GLPK_LINEAR_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5a3af34f198d539e787263f9eded0ce0cd"></a>MPModelRequest_SolverType_GUROBI_LINEAR_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5a4bdeae4b1af8d2cd4aab225db4fc0407"></a>MPModelRequest_SolverType_CPLEX_LINEAR_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5ac25c4844cbdf1e4d7c7efc11f1f8ebf4"></a>MPModelRequest_SolverType_SCIP_MIXED_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5af60a0830addaf4cf00bc59459fa6647e"></a>MPModelRequest_SolverType_GLPK_MIXED_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5a0e93bcd472e7a9296ff02058ed60f8d1"></a>MPModelRequest_SolverType_CBC_MIXED_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5ac8beb7f7b026823a6bc2e4e87f546da6"></a>MPModelRequest_SolverType_GUROBI_MIXED_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5a26762918189367f5e171d0e226084d82"></a>MPModelRequest_SolverType_CPLEX_MIXED_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5a67639f2cd42e1197b5ad69a004c93ba3"></a>MPModelRequest_SolverType_BOP_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5ac0fedb2082db5e7c96da01b4149c318e"></a>MPModelRequest_SolverType_SAT_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a66408fd9c4c05711631d208dce3118f5abe010aed8c1b29c5a0fd9ac262ce791f"></a>MPModelRequest_SolverType_KNAPSACK_MIXED_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00122">122</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="ab042145a1da0eaafbe215ded57dfe85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab042145a1da0eaafbe215ded57dfe85f">&#9670;&nbsp;</a></span>MPSolverCommonParameters_LPAlgorithmValues</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85f">operations_research::MPSolverCommonParameters_LPAlgorithmValues</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab042145a1da0eaafbe215ded57dfe85fa2218d316cfcac5a88342c95b188f3fda"></a>MPSolverCommonParameters_LPAlgorithmValues_LP_ALGO_UNSPECIFIED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab042145a1da0eaafbe215ded57dfe85fa129c4c6d32bf9aed2414939cb02ff99a"></a>MPSolverCommonParameters_LPAlgorithmValues_LP_ALGO_DUAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab042145a1da0eaafbe215ded57dfe85fa53de34dc95fb67212e335f19dc210516"></a>MPSolverCommonParameters_LPAlgorithmValues_LP_ALGO_PRIMAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab042145a1da0eaafbe215ded57dfe85fa89ff8ffa01928d5993a1414705eecd15"></a>MPSolverCommonParameters_LPAlgorithmValues_LP_ALGO_BARRIER&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00101">101</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a51d0df17eb5fb24fcdd0a134178cde56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d0df17eb5fb24fcdd0a134178cde56">&#9670;&nbsp;</a></span>MPSolverResponseStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56">operations_research::MPSolverResponseStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a51d0df17eb5fb24fcdd0a134178cde56ac95cb5be9e36b31647dd28910ac6cae4"></a>MPSOLVER_OPTIMAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a51d0df17eb5fb24fcdd0a134178cde56ac7d90afd0518be8cd6433ecad656a83b"></a>MPSOLVER_FEASIBLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a51d0df17eb5fb24fcdd0a134178cde56a0da2dbf49d011970a770d42141819d0a"></a>MPSOLVER_INFEASIBLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a51d0df17eb5fb24fcdd0a134178cde56ad73de4a0f9908a4c0d11246ecccf32b6"></a>MPSOLVER_UNBOUNDED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a51d0df17eb5fb24fcdd0a134178cde56ac77789af50586fb2f81915dd1cb790b6"></a>MPSOLVER_ABNORMAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a51d0df17eb5fb24fcdd0a134178cde56a667b6a5ed42c91ea81fa67c59cb3badb"></a>MPSOLVER_NOT_SOLVED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a51d0df17eb5fb24fcdd0a134178cde56a97ee5aaa7f57f286d4a821dd6e57523f"></a>MPSOLVER_MODEL_IS_VALID&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a51d0df17eb5fb24fcdd0a134178cde56a84ea2a63b24de389aac6aa33b1203cd4"></a>MPSOLVER_UNKNOWN_STATUS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a51d0df17eb5fb24fcdd0a134178cde56a6ae83516a798f1675e1b4daf0d8ea6b1"></a>MPSOLVER_MODEL_INVALID&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a51d0df17eb5fb24fcdd0a134178cde56a0f9da70b2f2b1304313c3a2a5f4876b3"></a>MPSOLVER_MODEL_INVALID_SOLUTION_HINT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a51d0df17eb5fb24fcdd0a134178cde56ab90169f8480eca12c963af5ce50d36aa"></a>MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a51d0df17eb5fb24fcdd0a134178cde56afa008125099beaab382c42682be6bbf9"></a>MPSOLVER_SOLVER_TYPE_UNAVAILABLE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00152">152</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a744e7cc90d56b2c503520ee1f97fc1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744e7cc90d56b2c503520ee1f97fc1db">&#9670;&nbsp;</a></span>VarTypes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceoperations__research.html#a744e7cc90d56b2c503520ee1f97fc1db">operations_research::VarTypes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enum is used internally to do dynamic typing on subclasses of integer variables. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a744e7cc90d56b2c503520ee1f97fc1dbab4f91414920a046da6b20cd63a2796e6"></a>UNSPECIFIED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a744e7cc90d56b2c503520ee1f97fc1dba035478726d2dcd2fb9ac77afb5c759cc"></a>DOMAIN_INT_VAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a744e7cc90d56b2c503520ee1f97fc1dba79122eee2a14a98d575b0b9ac73b0e42"></a>BOOLEAN_VAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a744e7cc90d56b2c503520ee1f97fc1dbad9de5a1ac157ce63c698777275b17787"></a>CONST_VAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a744e7cc90d56b2c503520ee1f97fc1dba0cc8439ff5d71bb0c4c981cd04b73d55"></a>VAR_ADD_CST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a744e7cc90d56b2c503520ee1f97fc1dbaa77c2e49834d223253421d9e3d69c51c"></a>VAR_TIMES_CST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a744e7cc90d56b2c503520ee1f97fc1dba93697c551d06ce8d37be776116f23f66"></a>CST_SUB_VAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a744e7cc90d56b2c503520ee1f97fc1dba9558ccbf57e24d3ddde9bfbf2835e4fe"></a>OPP_VAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a744e7cc90d56b2c503520ee1f97fc1dba93b00759c703fe20d9d8a5a75268a69d"></a>TRACE_VAR&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00123">123</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7abde7313cef64d25202a18f07481fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abde7313cef64d25202a18f07481fc3">&#9670;&nbsp;</a></span>AreAllBooleans()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AreAllBooleans </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02739">2739</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="ae4c7a8bfc6877606e512d3279549f44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c7a8bfc6877606e512d3279549f44d">&#9670;&nbsp;</a></span>AreAllBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AreAllBound </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02730">2730</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a54470bffc3ea32cc37d0222e5dbb62a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54470bffc3ea32cc37d0222e5dbb62a6">&#9670;&nbsp;</a></span>AreAllBoundOrNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AreAllBoundOrNull </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if all the variables are assigned to a single value, or if their corresponding value is null. </p>

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02746">2746</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a7028ce8b481be8cb6fca7a6925d41aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7028ce8b481be8cb6fca7a6925d41aa7">&#9670;&nbsp;</a></span>AreAllBoundTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AreAllBoundTo </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all variables are assigned to 'value'. </p>

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02757">2757</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a3aea406979285a28c91fd1ee8115af74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aea406979285a28c91fd1ee8115af74">&#9670;&nbsp;</a></span>AreAllGreaterOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AreAllGreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02658">2658</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a15f08cfbb35e2b8b1eb76f79caea924a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f08cfbb35e2b8b1eb76f79caea924a">&#9670;&nbsp;</a></span>AreAllLessOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AreAllLessOrEqual </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02668">2668</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a38972723946490ea4df4e34298d8805d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38972723946490ea4df4e34298d8805d">&#9670;&nbsp;</a></span>AreAllNegative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AreAllNegative </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02683">2683</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="ab0ae787392a8dd8a499eb55ac0916aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ae787392a8dd8a499eb55ac0916aa4">&#9670;&nbsp;</a></span>AreAllNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AreAllNull </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02653">2653</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="ae3e4f71c4c79e0b4ec00c4e715a7c298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e4f71c4c79e0b4ec00c4e715a7c298">&#9670;&nbsp;</a></span>AreAllOnes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AreAllOnes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02648">2648</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="ab62b402f767cda48eb67ef8b50397f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62b402f767cda48eb67ef8b50397f8f">&#9670;&nbsp;</a></span>AreAllPositive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AreAllPositive </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02678">2678</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a8351829c324863ddda52e201df4f9f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8351829c324863ddda52e201df4f9f84">&#9670;&nbsp;</a></span>AreAllStrictlyNegative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AreAllStrictlyNegative </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02693">2693</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a3de09f9134b976e5ba64751ac0f4440b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de09f9134b976e5ba64751ac0f4440b">&#9670;&nbsp;</a></span>AreAllStrictlyPositive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AreAllStrictlyPositive </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02688">2688</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="acff272be25bcf9641218c05c59ec1a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff272be25bcf9641218c05c59ec1a4e">&#9670;&nbsp;</a></span>AStarShortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AStarShortestPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64(int, int)&gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64(int)&gt;&#160;</td>
          <td class="paramname"><em>heuristic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>disconnected_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A* Shortest path with function based description of the graph. </p>
<p>The graph function returns the distance between two nodes, a distance of 'disconnected_distance' indicates no arcs between these two nodes. Additionally, the heuristic callback returns a an approximate distance between the node and the target, which guides the search. If the heuristic is admissible (ie. never overestimates cost), the A* algorithm returns an optimal solution. This function returns true if 'start_node' and 'end_node' are connected, false otherwise. </p>

</div>
</div>
<a id="ad5bfec6ea714171fbff2d8b791d0d286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bfec6ea714171fbff2d8b791d0d286">&#9670;&nbsp;</a></span>BellmanFordShortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::BellmanFordShortestPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64(int, int)&gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>disconnected_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bellman-Ford Shortest path with callback-based description of the graph. </p>
<p>The callback returns the distance between two nodes, a distance of 'disconnected_distance' indicates no arcs between these two nodes. Ownership of the callback is taken by the function that will delete it in the end. This function returns true if 'start_node' and 'end_node' are connected, false otherwise. If true, it will fill the 'nodes' vector with the sequence of nodes on the shortest path between 'start_node' and 'end_node'. </p>

</div>
</div>
<a id="a49b170b2d03863c465331e67b21f0c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b170b2d03863c465331e67b21f0c33">&#9670;&nbsp;</a></span>BuildEulerianPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Graph::NodeIndex&gt; operations_research::BuildEulerianPath </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an Eulerian path/trail on an undirected graph. </p>
<p>This function works only on Reverse graphs (cf. <a class="el" href="graph_8h.html">ortools/graph/graph.h</a>). Returns an empty tour if a tour cannot be built. As of 10/2015, assumes the graph is connected. </p>

<p class="definition">Definition at line <a class="el" href="eulerian__path_8h_source.html#l00138">138</a> of file <a class="el" href="eulerian__path_8h_source.html">eulerian_path.h</a>.</p>

</div>
</div>
<a id="a743d8c9d6f64531bdeb7bbf18023e9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743d8c9d6f64531bdeb7bbf18023e9d4">&#9670;&nbsp;</a></span>BuildEulerianPathFromNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeIndex , typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>&gt; operations_research::BuildEulerianPathFromNode </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an Eulerian path/trail on an undirected graph starting from node root. </p>
<p>Supposes the graph is connected and is eulerian or semi-eulerian. This is an implementation of Hierholzer's algorithm. If m is the number of edges in the graph and n the number of nodes, time and memory complexity is O(n + m). </p>

<p class="definition">Definition at line <a class="el" href="eulerian__path_8h_source.html#l00074">74</a> of file <a class="el" href="eulerian__path_8h_source.html">eulerian_path.h</a>.</p>

</div>
</div>
<a id="a034666fe63ca105b735272974006362a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034666fe63ca105b735272974006362a">&#9670;&nbsp;</a></span>BuildEulerianTour()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Graph::NodeIndex&gt; operations_research::BuildEulerianTour </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above but without specifying a start/end root node (node 0 is taken as default root). </p>

<p class="definition">Definition at line <a class="el" href="eulerian__path_8h_source.html#l00128">128</a> of file <a class="el" href="eulerian__path_8h_source.html">eulerian_path.h</a>.</p>

</div>
</div>
<a id="aa63055860fc53f8eed56d23d2571c180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63055860fc53f8eed56d23d2571c180">&#9670;&nbsp;</a></span>BuildEulerianTourFromNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeIndex , typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>&gt; operations_research::BuildEulerianTourFromNode </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an Eulerian tour/circuit/cycle starting and ending at node root on an undirected graph. </p>
<p>This function works only on Reverse graphs (cf. <a class="el" href="graph_8h.html">ortools/graph/graph.h</a>). Returns an empty tour if either root is invalid or if a tour cannot be built. As of 10/2015, assumes the graph is connected. </p>

<p class="definition">Definition at line <a class="el" href="eulerian__path_8h_source.html#l00116">116</a> of file <a class="el" href="eulerian__path_8h_source.html">eulerian_path.h</a>.</p>

</div>
</div>
<a id="aa565a47a059ef32ef1aec39768e4ec98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa565a47a059ef32ef1aec39768e4ec98">&#9670;&nbsp;</a></span>BuildKruskalMinimumSpanningTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename ArcComparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Graph::ArcIndex&gt; operations_research::BuildKruskalMinimumSpanningTree </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArcComparator &amp;&#160;</td>
          <td class="paramname"><em>arc_comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version taking an arc comparator to sort graph arcs. </p>
<p>Usage: ListGraph&lt;int, int&gt; graph(...); const auto arc_cost = [&amp;graph](int arc) { return f(graph.Tail(arc), graph.Head(arc)); }; std::vector&lt;int&gt; mst = BuildKruskalMinimumSpanningTree( graph, [&amp;arc_cost](int a, int b) { return arc_cost(a) &lt; arc_cost(b); }); </p>

<p class="definition">Definition at line <a class="el" href="minimum__spanning__tree_8h_source.html#l00091">91</a> of file <a class="el" href="minimum__spanning__tree_8h_source.html">minimum_spanning_tree.h</a>.</p>

</div>
</div>
<a id="a00ab79ee21ffd8dece0996e37f9faa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ab79ee21ffd8dece0996e37f9faa7a">&#9670;&nbsp;</a></span>BuildKruskalMinimumSpanningTreeFromSortedArcs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Graph::ArcIndex&gt; operations_research::BuildKruskalMinimumSpanningTreeFromSortedArcs </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename Graph::ArcIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted_arcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of Kruskal's mininumum spanning tree algorithm (c.f. </p>
<p><a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">https://en.wikipedia.org/wiki/Kruskal%27s_algorithm</a>). Returns the index of the arcs appearing in the tree; will return a forest if the graph is disconnected. Nodes without any arcs will be ignored. Each arc of the graph is interpreted as an undirected arc. Complexity of the algorithm is O(E * log(E)) where E is the number of arcs in the graph. Memory usage is O(E * log(E)). </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000096">Todo:</a></b></dt><dd>(user): Add a global Minimum Spanning Tree API automatically switching between Prim and Kruskal depending on problem size.</dd></dl>
<p>Version taking sorted graph arcs. Allows somewhat incremental recomputation of minimum spanning trees as most of the processing time is spent sorting arcs. Usage: ListGraph&lt;int, int&gt; graph(...); std::vector&lt;int&gt; sorted_arcs = ...; std::vector&lt;int&gt; mst = BuildKruskalMinimumSpanningTreeFromSortedArcs( graph, sorted_arcs); </p>

<p class="definition">Definition at line <a class="el" href="minimum__spanning__tree_8h_source.html#l00050">50</a> of file <a class="el" href="minimum__spanning__tree_8h_source.html">minimum_spanning_tree.h</a>.</p>

</div>
</div>
<a id="acb53c505b8fd29ceb3abdcc7dfd809ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb53c505b8fd29ceb3abdcc7dfd809ce">&#9670;&nbsp;</a></span>BuildLineGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::BuildLineGraph </td>
          <td>(</td>
          <td class="paramtype">const GraphType &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphType *const&#160;</td>
          <td class="paramname"><em>line_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a directed line graph for 'graph' (see "directed line graph" in <a href="http://en.wikipedia.org/wiki/Line_graph">http://en.wikipedia.org/wiki/Line_graph</a>). </p>
<p>Arcs of the original graph become nodes and the new graph contains only nodes created from arcs in the original graph (we use the notation (a-&gt;b) for these new nodes); the index of the node (a-&gt;b) in the new graph is exactly the same as the index of the arc a-&gt;b in the original graph. An arc from node (a-&gt;b) to node (c-&gt;d) in the new graph is added if and only if b == c in the original graph. This method expects that 'line_graph' is an empty graph (it has no nodes and no arcs). Returns false on an error. </p>
<p>Sizing then filling. </p>

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l02088">2088</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="ae39a6c4d8ba890ec5150ea91a7aad643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39a6c4d8ba890ec5150ea91a7aad643">&#9670;&nbsp;</a></span>BuildModelParametersFromFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1RoutingModelParameters.html">RoutingModelParameters</a> operations_research::BuildModelParametersFromFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds routing search parameters from flags. </p>

</div>
</div>
<a id="a33a2f4c26fd60cd0fa98257b571c974f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a2f4c26fd60cd0fa98257b571c974f">&#9670;&nbsp;</a></span>BuildPrimMinimumSpanningTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename ArcValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Graph::ArcIndex&gt; operations_research::BuildPrimMinimumSpanningTree </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArcValue &amp;&#160;</td>
          <td class="paramname"><em>arc_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of Prim's mininumum spanning tree algorithm (c.f. </p>
<p><a href="https://en.wikipedia.org/wiki/Prim's_algorithm">https://en.wikipedia.org/wiki/Prim's_algorithm</a>) on undirected connected graphs. Returns the index of the arcs appearing in the tree. Complexity of the algorithm is O(E * log(V)) where E is the number of arcs in the graph, V is the number of vertices. Memory usage is O(V) + memory taken by the graph. Usage: ListGraph&lt;int, int&gt; graph(...); const auto arc_cost = [&amp;graph](int arc) -&gt; int64 { return f(graph.Tail(arc), graph.Head(arc)); }; std::vector&lt;int&gt; mst = BuildPrimMinimumSpanningTree(graph, arc_cost); </p>
<p>This struct represents entries in the adjustable priority queue which maintains active nodes (not added to the tree yet) in decreasing insertion cost order. AdjustablePriorityQueue requires the existence of the SetHeapIndex and GetHeapIndex methods. </p>

<p class="definition">Definition at line <a class="el" href="minimum__spanning__tree_8h_source.html#l00117">117</a> of file <a class="el" href="minimum__spanning__tree_8h_source.html">minimum_spanning_tree.h</a>.</p>

</div>
</div>
<a id="a95da1d3a46432afd40024f79279a48b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95da1d3a46432afd40024f79279a48b2">&#9670;&nbsp;</a></span>BuildSearchParametersFromFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1RoutingSearchParameters.html">RoutingSearchParameters</a> operations_research::BuildSearchParametersFromFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds routing search parameters from flags. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000043">Todo:</a></b></dt><dd>(user): Make this return a StatusOr, verifying that the flags describe a valid set of routing search parameters. </dd></dl>

</div>
</div>
<a id="afe4b5a6c0e4019314f288e3f4307c114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4b5a6c0e4019314f288e3f4307c114">&#9670;&nbsp;</a></span>CoverArcsByCliques()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::CoverArcsByCliques </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(int, int)&gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const std::vector&lt; int &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Covers the maximum number of arcs of the graph with cliques. </p>
<p>The graph is described by the graph callback. graph-&gt;Run(i, j) indicates if there is an arc between i and j. This function takes ownership of 'callback' and deletes it after it has run. It calls 'callback' upon each clique. It ignores cliques of size 1. </p>

</div>
</div>
<a id="aa388c8707db255ae7742c04046bdd613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa388c8707db255ae7742c04046bdd613">&#9670;&nbsp;</a></span>DefaultRoutingModelParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1RoutingModelParameters.html">RoutingModelParameters</a> operations_research::DefaultRoutingModelParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcac4a11f1e4d36ceb47f7251461487d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcac4a11f1e4d36ceb47f7251461487d">&#9670;&nbsp;</a></span>DefaultRoutingSearchParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1RoutingSearchParameters.html">RoutingSearchParameters</a> operations_research::DefaultRoutingSearchParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fee47a5359613bc7f8df356595c7ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fee47a5359613bc7f8df356595c7ff0">&#9670;&nbsp;</a></span>DEFINE_INT_TYPE() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::DEFINE_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">RoutingNodeIndex&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defining common types used in the routing library outside the main RoutingModel class has several purposes: 1) It allows some small libraries to avoid a dependency on routing. </p>
<p>{h,cc}, eg. <a class="el" href="routing__neighborhoods_8h.html">routing_neighborhoods.h</a>. 2) It allows an easier wrapping via SWIG, which can have issues with intra-class types.</p>
<p>Users that depend on routing.{h,cc} should just use the RoutingModel:: equivalent, eg. RoutingModel::NodeIndex. </p>

</div>
</div>
<a id="afa9196adb7aa76d8e60cd4c0c6687c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9196adb7aa76d8e60cd4c0c6687c0d">&#9670;&nbsp;</a></span>DEFINE_INT_TYPE() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::DEFINE_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">RoutingCostClassIndex&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d98b6fb94b9cdabfaca3d9f3c9632e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d98b6fb94b9cdabfaca3d9f3c9632e9">&#9670;&nbsp;</a></span>DEFINE_INT_TYPE() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::DEFINE_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">RoutingDimensionIndex&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1edd1d7c020633019991b13d14b4b15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edd1d7c020633019991b13d14b4b15b">&#9670;&nbsp;</a></span>DEFINE_INT_TYPE() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::DEFINE_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">RoutingDisjunctionIndex&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff19b78b3d56ff95c23727ca4ff64ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff19b78b3d56ff95c23727ca4ff64ea7">&#9670;&nbsp;</a></span>DEFINE_INT_TYPE() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::DEFINE_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">RoutingVehicleClassIndex&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53e6a83fcbd689abf5b3078b0236f9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e6a83fcbd689abf5b3078b0236f9f1">&#9670;&nbsp;</a></span>DijkstraShortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::DijkstraShortestPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64(int, int)&gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>disconnected_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dijsktra Shortest path with callback based description of the graph. </p>
<p>The callback returns the distance between two nodes, a distance of 'disconnected_distance' indicates no arcs between these two nodes. Ownership of the callback is taken by the function that will delete it in the end. This function returns true if 'start_node' and 'end_node' are connected, false otherwise. </p>

</div>
</div>
<a id="a689d3552f87e89456c0c9a43847c964a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689d3552f87e89456c0c9a43847c964a">&#9670;&nbsp;</a></span>ExportModelAsLpFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::StatusOr&lt;std::string&gt; operations_research::ExportModelAsLpFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the current model (variables, constraints, objective) as a std::string encoded in the so-called "CPLEX LP file format" as generated by SCIP. </p>
<p>The LP file format is easily readable by a human.</p>
<p>Returns false if some error has occurred during execution. The validity of names is automatically checked. If a variable name or a constraint name is invalid or non-existent, a new valid name is automatically generated.</p>
<p>If 'obfuscated' is true, the variable and constraint names of proto_ are not used. Variable and constraint names of the form "V12345" and "C12345" are used instead.</p>
<p>For more information about the different LP file formats: <a href="http://lpsolve.sourceforge.net/5.5/lp-format.htm">http://lpsolve.sourceforge.net/5.5/lp-format.htm</a> The following give a reasonable idea of the CPLEX LP file format: <a href="http://lpsolve.sourceforge.net/5.5/CPLEX-format.htm">http://lpsolve.sourceforge.net/5.5/CPLEX-format.htm</a> <a href="http://tinyurl.com/cplex-lp-format">http://tinyurl.com/cplex-lp-format</a> <a href="http://www.gurobi.com/documentation/5.1/reference-manual/node871">http://www.gurobi.com/documentation/5.1/reference-manual/node871</a> </p>

</div>
</div>
<a id="a4d319c19b685fe608fe013b573081351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d319c19b685fe608fe013b573081351">&#9670;&nbsp;</a></span>ExportModelAsLpFormatReturnString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::ExportModelAsLpFormatReturnString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;&#160;</td>
          <td class="paramname"><em>input_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="model__exporter__swig__helper_8h_source.html#l00024">24</a> of file <a class="el" href="model__exporter__swig__helper_8h_source.html">model_exporter_swig_helper.h</a>.</p>

</div>
</div>
<a id="aef684073daca7460490db8d881f886e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef684073daca7460490db8d881f886e0">&#9670;&nbsp;</a></span>ExportModelAsMpsFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::StatusOr&lt;std::string&gt; operations_research::ExportModelAsMpsFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the current model (variables, constraints, objective) as a std::string encoded in MPS file format, using the "free" MPS format. </p>
<p>Returns false if some error has occurred during execution. Models with maximization objectives trigger an error, because MPS can encode only minimization problems.</p>
<p>The validity of names is automatically checked. If a variable name or a constraint name is invalid or non-existent, a new valid name is automatically generated.</p>
<p>Name validity and obfuscation works exactly as in <a class="el" href="namespaceoperations__research.html#a689d3552f87e89456c0c9a43847c964a" title="Outputs the current model (variables, constraints, objective) as a std::string encoded in the so-call...">ExportModelAsLpFormat()</a>.</p>
<p>For more information about the MPS format: <a href="http://en.wikipedia.org/wiki/MPS_(format)">http://en.wikipedia.org/wiki/MPS_(format)</a> A close-to-original description coming from OSL: <a href="http://tinyurl.com/mps-format-by-osl">http://tinyurl.com/mps-format-by-osl</a> A recent description from CPLEX: <a href="http://tinyurl.com/mps-format-by-cplex">http://tinyurl.com/mps-format-by-cplex</a> CPLEX extensions: <a href="http://tinyurl.com/mps-extensions-by-cplex">http://tinyurl.com/mps-extensions-by-cplex</a> Gurobi's description: <a href="http://www.gurobi.com/documentation/5.1/reference-manual/node869">http://www.gurobi.com/documentation/5.1/reference-manual/node869</a> </p>

</div>
</div>
<a id="a37abd61c0d982af79257814b6d3a733e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37abd61c0d982af79257814b6d3a733e">&#9670;&nbsp;</a></span>ExportModelAsMpsFormatReturnString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::ExportModelAsMpsFormatReturnString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;&#160;</td>
          <td class="paramname"><em>input_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structoperations__research_1_1MPModelExportOptions.html">MPModelExportOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="model__exporter__swig__helper_8h_source.html#l00031">31</a> of file <a class="el" href="model__exporter__swig__helper_8h_source.html">model_exporter_swig_helper.h</a>.</p>

</div>
</div>
<a id="a6662a100d8715747870beb9721bb304b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6662a100d8715747870beb9721bb304b">&#9670;&nbsp;</a></span>FillValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::FillValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int64 &gt; *const&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02786">2786</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a509097448ff5705cf3e64d889362bdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509097448ff5705cf3e64d889362bdec">&#9670;&nbsp;</a></span>FindCliques()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::FindCliques </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(int, int)&gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const std::vector&lt; int &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all maximal cliques, even of size 1, in the graph described by the graph callback. </p>
<p>graph-&gt;Run(i, j) indicates if there is an arc between i and j. This function takes ownership of 'callback' and deletes it after it has run. If 'callback' returns true, then the search for cliques stops. </p>

</div>
</div>
<a id="a7a27bb74d09b7ba6ea0e97bb572d2755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a27bb74d09b7ba6ea0e97bb572d2755">&#9670;&nbsp;</a></span>FindErrorInMPModelProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::FindErrorInMPModelProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an empty std::string iff the model is valid and not trivially infeasible. </p>
<p>Otherwise, returns a description of the first error or trivial infeasibility encountered.</p>
<p>NOTE(user): the code of this method (and the client code too!) is considerably simplified by this std::string-based, simple API. If clients require it, we could add a formal error status enum. </p>

</div>
</div>
<a id="ae2e060e8ee4ea901dc4df260b3385eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e060e8ee4ea901dc4df260b3385eac">&#9670;&nbsp;</a></span>FindErrorInRoutingSearchParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::FindErrorInRoutingSearchParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1RoutingSearchParameters.html">RoutingSearchParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>search_parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an empty std::string if the routing search parameters are valid, and a non-empty, human readable error description if they're not. </p>

</div>
</div>
<a id="ae4ee4d82cf625670cdc1f52197454654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ee4d82cf625670cdc1f52197454654">&#9670;&nbsp;</a></span>FindFeasibilityErrorInSolutionHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::FindFeasibilityErrorInSolutionHint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an empty std::string if the solution hint given in the model is a feasible solution. </p>
<p>Otherwise, returns a description of the first reason for infeasibility.</p>
<p>This function can be useful for debugging/checking that the given solution hint is feasible when it is expected to be the case. The feasibility is checked up to the given tolerance using the ::operations_research::IsLowerWithinTolerance() function. </p>

</div>
</div>
<a id="a3c3c2af7d77d5e7f76f9a3d8fb1edf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3c2af7d77d5e7f76f9a3d8fb1edf0f">&#9670;&nbsp;</a></span>FirstSolutionStrategy_Value_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ::google::protobuf::EnumDescriptor* operations_research::FirstSolutionStrategy_Value_descriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8fb428ce4826abddd79ff391cfc1c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fb428ce4826abddd79ff391cfc1c51">&#9670;&nbsp;</a></span>FirstSolutionStrategy_Value_IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::FirstSolutionStrategy_Value_IsValid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaed24a4c7f867bbe1173faf422387c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed24a4c7f867bbe1173faf422387c57">&#9670;&nbsp;</a></span>FirstSolutionStrategy_Value_Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ::std::string&amp; operations_research::FirstSolutionStrategy_Value_Name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362c">FirstSolutionStrategy_Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__enums_8pb_8h_source.html#l00094">94</a> of file <a class="el" href="routing__enums_8pb_8h_source.html">routing_enums.pb.h</a>.</p>

</div>
</div>
<a id="ad1acf7e4aff76fb0cc1659d91bdb5a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1acf7e4aff76fb0cc1659d91bdb5a62">&#9670;&nbsp;</a></span>FirstSolutionStrategy_Value_Parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::FirstSolutionStrategy_Value_Parse </td>
          <td>(</td>
          <td class="paramtype">const ::std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362c">FirstSolutionStrategy_Value</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__enums_8pb_8h_source.html#l00098">98</a> of file <a class="el" href="routing__enums_8pb_8h_source.html">routing_enums.pb.h</a>.</p>

</div>
</div>
<a id="a64cf3e1336ec61275bdd2ae853d38406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cf3e1336ec61275bdd2ae853d38406">&#9670;&nbsp;</a></span>Hash1() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 operations_research::Hash1 </td>
          <td>(</td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>-------&mdash; Reversible Hash Table -------&mdash; </p>
<p>--&mdash; Hash functions --&mdash; </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo:</a></b></dt><dd>(user): use murmurhash.</dd></dl>

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00226">226</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="ab89995e46facfc1db291ce75658dd0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89995e46facfc1db291ce75658dd0a5">&#9670;&nbsp;</a></span>Hash1() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 operations_research::Hash1 </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00237">237</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="acfc54730764156f1fb717e99b71ba5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc54730764156f1fb717e99b71ba5d4">&#9670;&nbsp;</a></span>Hash1() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 operations_research::Hash1 </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00248">248</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a65a9c1ccf298ae110decc3b9d285dc16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a9c1ccf298ae110decc3b9d285dc16">&#9670;&nbsp;</a></span>Hash1() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 operations_research::Hash1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00250">250</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a3ca754fad158b92d7f678b5d354d8927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca754fad158b92d7f678b5d354d8927">&#9670;&nbsp;</a></span>Hash1() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 operations_research::Hash1 </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00252">252</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="aec42cb0a7c3079eb8f0406914077d633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec42cb0a7c3079eb8f0406914077d633">&#9670;&nbsp;</a></span>Hash1() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64 operations_research::Hash1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00261">261</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="ac2ba31780fce352d4bba600e6e8eacad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ba31780fce352d4bba600e6e8eacad">&#9670;&nbsp;</a></span>Hash1() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 operations_research::Hash1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int64 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00275">275</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="ab8c23924c4b61ed5c531424a6f18bde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c23924c4b61ed5c531424a6f18bde1">&#9670;&nbsp;</a></span>IntervalsAreSortedAndNonAdjacent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::IntervalsAreSortedAndNonAdjacent </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1ClosedInterval.html">ClosedInterval</a> &gt;&#160;</td>
          <td class="paramname"><em>intervals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff we have: </p>
<ul>
<li>The intervals appear in increasing order.</li>
<li>for all i: intervals[i].start &lt;= intervals[i].end</li>
<li>for all i but the last: intervals[i].end + 1 &lt; intervals[i+1].start </li>
</ul>

</div>
</div>
<a id="a3f4525e71a6b05d97c868f0832750a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4525e71a6b05d97c868f0832750a60">&#9670;&nbsp;</a></span>IsArrayBoolean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::IsArrayBoolean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02638">2638</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a12527c82ffc8b31c5d8dc836c366d624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12527c82ffc8b31c5d8dc836c366d624">&#9670;&nbsp;</a></span>IsArrayConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::IsArrayConstant </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>-------&mdash; Helpers -------&mdash; </p>
<p>--&mdash; On integer vectors --&mdash; </p>

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02628">2628</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="adf2aea6c68fe502389c9264b971b2f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2aea6c68fe502389c9264b971b2f85">&#9670;&nbsp;</a></span>IsArrayInRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::IsArrayInRange </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>range_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>range_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>--&mdash; On integer variable vector --&mdash; </p>

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02720">2720</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="ab1cf773de0cae72d0c44efe5b8f4bb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cf773de0cae72d0c44efe5b8f4bb89">&#9670;&nbsp;</a></span>IsEulerianGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::IsEulerianGraph </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a graph is Eulerian, aka all its nodes are of even degree. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000056">Todo:</a></b></dt><dd>(user): Check graph connectivity. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eulerian__path_8h_source.html#l00040">40</a> of file <a class="el" href="eulerian__path_8h_source.html">eulerian_path.h</a>.</p>

</div>
</div>
<a id="a3d434774c07815a25ffaa7adb343c19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d434774c07815a25ffaa7adb343c19e">&#9670;&nbsp;</a></span>IsIncreasing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::IsIncreasing </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02708">2708</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="aafac7375c23337f25821aa6f86ca627c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafac7375c23337f25821aa6f86ca627c">&#9670;&nbsp;</a></span>IsIncreasingContiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::IsIncreasingContiguous </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02698">2698</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a6b312dd19c90b2af099e6f159869f7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b312dd19c90b2af099e6f159869f7ee">&#9670;&nbsp;</a></span>IsSemiEulerianGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeIndex , typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::IsSemiEulerianGraph </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> &gt; *&#160;</td>
          <td class="paramname"><em>odd_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a graph is Semi-Eulerian, aka at most two of its nodes are of odd degree. </p>
<p>odd_nodes is filled with odd nodes of the graph. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000057">Todo:</a></b></dt><dd>(user): Check graph connectivity. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eulerian__path_8h_source.html#l00055">55</a> of file <a class="el" href="eulerian__path_8h_source.html">eulerian_path.h</a>.</p>

</div>
</div>
<a id="a5142d10acce3d076acf89506752dba5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5142d10acce3d076acf89506752dba5f">&#9670;&nbsp;</a></span>LocalSearchMetaheuristic_Value_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ::google::protobuf::EnumDescriptor* operations_research::LocalSearchMetaheuristic_Value_descriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed46fa1bbfbc75c04bd66f5055ddb3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed46fa1bbfbc75c04bd66f5055ddb3c1">&#9670;&nbsp;</a></span>LocalSearchMetaheuristic_Value_IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::LocalSearchMetaheuristic_Value_IsValid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade04d594c17cc2436976da614fa0a2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade04d594c17cc2436976da614fa0a2f7">&#9670;&nbsp;</a></span>LocalSearchMetaheuristic_Value_Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ::std::string&amp; operations_research::LocalSearchMetaheuristic_Value_Name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77">LocalSearchMetaheuristic_Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__enums_8pb_8h_source.html#l00120">120</a> of file <a class="el" href="routing__enums_8pb_8h_source.html">routing_enums.pb.h</a>.</p>

</div>
</div>
<a id="a8e7c14051a98f40a1782646965401ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7c14051a98f40a1782646965401ca7">&#9670;&nbsp;</a></span>LocalSearchMetaheuristic_Value_Parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::LocalSearchMetaheuristic_Value_Parse </td>
          <td>(</td>
          <td class="paramtype">const ::std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77">LocalSearchMetaheuristic_Value</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__enums_8pb_8h_source.html#l00124">124</a> of file <a class="el" href="routing__enums_8pb_8h_source.html">routing_enums.pb.h</a>.</p>

</div>
</div>
<a id="a3ea6af6581e6922832918c97753146a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea6af6581e6922832918c97753146a7">&#9670;&nbsp;</a></span>MakeConstraintDemon0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a>* operations_research::MakeConstraintDemon0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00538">538</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a4fb750da00c784e5ffd1763fd3ce88f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb750da00c784e5ffd1763fd3ce88f7">&#9670;&nbsp;</a></span>MakeConstraintDemon1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a>* operations_research::MakeConstraintDemon1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(P)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>param1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00579">579</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a4da629cafe75f958924e1684ac2b0eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da629cafe75f958924e1684ac2b0eff">&#9670;&nbsp;</a></span>MakeConstraintDemon2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a>* operations_research::MakeConstraintDemon2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(P, Q)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>param1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q&#160;</td>
          <td class="paramname"><em>param2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00618">618</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="abdca98f14c02e004ab5e19d2c3985667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdca98f14c02e004ab5e19d2c3985667">&#9670;&nbsp;</a></span>MakeConstraintDemon3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class Q , class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a>* operations_research::MakeConstraintDemon3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(P, Q, R)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>param1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>param3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00661">661</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a82110ba1f45aa29ffc933102880dbd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82110ba1f45aa29ffc933102880dbd82">&#9670;&nbsp;</a></span>MakeDelayedConstraintDemon0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a>* operations_research::MakeDelayedConstraintDemon0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00701">701</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a11f4a7dbafd8e00a36b892a82e44445f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f4a7dbafd8e00a36b892a82e44445f">&#9670;&nbsp;</a></span>MakeDelayedConstraintDemon1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a>* operations_research::MakeDelayedConstraintDemon1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(P)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>param1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00737">737</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a29b8113bf656aa61493c9459508ed953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b8113bf656aa61493c9459508ed953">&#9670;&nbsp;</a></span>MakeDelayedConstraintDemon2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P , class Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1Demon.html">Demon</a>* operations_research::MakeDelayedConstraintDemon2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(P, Q)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>param1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q&#160;</td>
          <td class="paramname"><em>param2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00781">781</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a715b0dbb9f0903ab629b8c6da1b35b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715b0dbb9f0903ab629b8c6da1b35b45">&#9670;&nbsp;</a></span>MakeHamiltonianPathSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CostType , typename CostFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html">HamiltonianPathSolver</a>&lt;CostType, CostFunction&gt; operations_research::MakeHamiltonianPathSolver </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CostFunction&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to simplify building a <a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html">HamiltonianPathSolver</a> from a functor. </p>

<p class="definition">Definition at line <a class="el" href="hamiltonian__path_8h_source.html#l00599">599</a> of file <a class="el" href="hamiltonian__path_8h_source.html">hamiltonian_path.h</a>.</p>

</div>
</div>
<a id="a85ea0ef5b46465c3793333ce9821f15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ea0ef5b46465c3793333ce9821f15f">&#9670;&nbsp;</a></span>MakeLocalSearchOperator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1LocalSearchOperator.html">LocalSearchOperator</a>* operations_research::MakeLocalSearchOperator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>secondary_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int(int64)&gt;&#160;</td>
          <td class="paramname"><em>start_empty_path_class</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>--&mdash; Operator Factories ---&mdash; </p>

</div>
</div>
<a id="abc42d1bcfe023d3ac6f59471b75d853c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc42d1bcfe023d3ac6f59471b75d853c">&#9670;&nbsp;</a></span>MaxVarArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64 operations_research::MaxVarArray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The std::max&lt;int64&gt; is needed for compilation on MSVC. </p>

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02766">2766</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a5c1932027ef8bc1689d725a1c597867b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1932027ef8bc1689d725a1c597867b">&#9670;&nbsp;</a></span>MinVarArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64 operations_research::MinVarArray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The std::min&lt;int64&gt; is needed for compilation on MSVC. </p>

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02776">2776</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a2f03e5ed2f65164d62fc5f039441596d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f03e5ed2f65164d62fc5f039441596d">&#9670;&nbsp;</a></span>model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* RoutingModel operations_research::model </td>
          <td>(</td>
          <td class="paramtype">manager&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3fea38c7df3ab9583e34b82878e255c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fea38c7df3ab9583e34b82878e255c">&#9670;&nbsp;</a></span>MPModelRequest_SolverType_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ::google::protobuf::EnumDescriptor* operations_research::MPModelRequest_SolverType_descriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad26c438ab5f1b232d7eced80a2780ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26c438ab5f1b232d7eced80a2780ca0">&#9670;&nbsp;</a></span>MPModelRequest_SolverType_IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPModelRequest_SolverType_IsValid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1d017a27f2b89bb55910d1fceb31c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d017a27f2b89bb55910d1fceb31c64">&#9670;&nbsp;</a></span>MPModelRequest_SolverType_Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ::std::string&amp; operations_research::MPModelRequest_SolverType_Name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5">MPModelRequest_SolverType</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00143">143</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a028ee3de18b0c41c98df4de7f38c3543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028ee3de18b0c41c98df4de7f38c3543">&#9670;&nbsp;</a></span>MPModelRequest_SolverType_Parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPModelRequest_SolverType_Parse </td>
          <td>(</td>
          <td class="paramtype">const ::std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5">MPModelRequest_SolverType</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00147">147</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a976efc8cb83ba6997aa984b3c106da17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976efc8cb83ba6997aa984b3c106da17">&#9670;&nbsp;</a></span>MPSolverCommonParameters_LPAlgorithmValues_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ::google::protobuf::EnumDescriptor* operations_research::MPSolverCommonParameters_LPAlgorithmValues_descriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3ee5c7a9f799696432b082fd4835232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ee5c7a9f799696432b082fd4835232">&#9670;&nbsp;</a></span>MPSolverCommonParameters_LPAlgorithmValues_IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPSolverCommonParameters_LPAlgorithmValues_IsValid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a317f48b6b35697bf02ead22157c91c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317f48b6b35697bf02ead22157c91c52">&#9670;&nbsp;</a></span>MPSolverCommonParameters_LPAlgorithmValues_Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ::std::string&amp; operations_research::MPSolverCommonParameters_LPAlgorithmValues_Name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85f">MPSolverCommonParameters_LPAlgorithmValues</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00113">113</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="ac2b888d39ca1974f8485911aa6434144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b888d39ca1974f8485911aa6434144">&#9670;&nbsp;</a></span>MPSolverCommonParameters_LPAlgorithmValues_Parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPSolverCommonParameters_LPAlgorithmValues_Parse </td>
          <td>(</td>
          <td class="paramtype">const ::std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85f">MPSolverCommonParameters_LPAlgorithmValues</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00117">117</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a472faf18ff58cd6640b7b3bf6336d9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472faf18ff58cd6640b7b3bf6336d9b6">&#9670;&nbsp;</a></span>MPSolverResponseStatus_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ::google::protobuf::EnumDescriptor* operations_research::MPSolverResponseStatus_descriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a295b0760db498bc4fa9479bb8c2329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a295b0760db498bc4fa9479bb8c2329">&#9670;&nbsp;</a></span>MPSolverResponseStatus_IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPSolverResponseStatus_IsValid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1225873debe2bc2cb173d365f06ca615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1225873debe2bc2cb173d365f06ca615">&#9670;&nbsp;</a></span>MPSolverResponseStatus_Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ::std::string&amp; operations_research::MPSolverResponseStatus_Name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56">MPSolverResponseStatus</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00172">172</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a415f14aa6c054ed47d050bd15e725f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415f14aa6c054ed47d050bd15e725f52">&#9670;&nbsp;</a></span>MPSolverResponseStatus_Parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPSolverResponseStatus_Parse </td>
          <td>(</td>
          <td class="paramtype">const ::std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56">MPSolverResponseStatus</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00176">176</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a891fd91407acbbeb1c47d22be7991b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891fd91407acbbeb1c47d22be7991b3f">&#9670;&nbsp;</a></span>NodeToIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">use manager operations_research::NodeToIndex </td>
          <td>(</td>
          <td class="paramtype">node&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a NodeIndex to variable index mapping for a problem containing 'num_nodes', 'num_vehicles' and the given starts and ends for each vehicle. If used, any start/end arrays have to have exactly 'num_vehicles' elements.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000044">Todo:</a></b></dt><dd>(user): Remove when removal of NodeIndex from RoutingModel is complete. </dd></dl>

<p class="definition">Definition at line <a class="el" href="routing__index__manager_8h_source.html#l00038">38</a> of file <a class="el" href="routing__index__manager_8h_source.html">routing_index_manager.h</a>.</p>

</div>
</div>
<a id="aa96bb5a28dd9c1ccc864b1587e8e1a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96bb5a28dd9c1ccc864b1587e8e1a98">&#9670;&nbsp;</a></span>One()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64 operations_research::One </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns 1. </p>

<p class="definition">Definition at line <a class="el" href="constraint__solver_8h_source.html#l03120">3120</a> of file <a class="el" href="constraint__solver_8h_source.html">constraint_solver.h</a>.</p>

</div>
</div>
<a id="a741104fe08089fe3520676487f7a685d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741104fe08089fe3520676487f7a685d">&#9670;&nbsp;</a></span>operator *() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> operations_research::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99590470c6ad2d59331b6fcc56609877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99590470c6ad2d59331b6fcc56609877">&#9670;&nbsp;</a></span>operator *() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> operations_research::operator * </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97f9b83239285f5fdfcac1b8e8b4f162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f9b83239285f5fdfcac1b8e8b4f162">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> operations_research::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NOTE(user): in the ops below, the non-"const LinearExpr&amp;" are intentional. </p>
<p>We need to create a new <a class="el" href="classoperations__research_1_1LinearExpr.html" title="LinearExpr models a quantity that is linear in the decision variables (MPVariable) of an optimization...">LinearExpr</a> for the result, so we lose nothing by passing one argument by value, mutating it, and then returning it. In particular, this allows (with move semantics and RVO) an optimized evaluation of expressions such as a + b + c + d (see <a href="http://en.cppreference.com/w/cpp/language/operators">http://en.cppreference.com/w/cpp/language/operators</a>). </p>

</div>
</div>
<a id="a515cdaf4f9c4000bb3482a0c450e23c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515cdaf4f9c4000bb3482a0c450e23c3">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> operations_research::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abebdd7f40e90df8dc7d557b6e26da942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebdd7f40e90df8dc7d557b6e26da942">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> operations_research::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c341d9214d5d46014089435ba0e26d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c341d9214d5d46014089435ba0e26d3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operations_research::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1ClosedInterval.html">ClosedInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa301d39d2a9271daf8c65e779635335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa301d39d2a9271daf8c65e779635335">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operations_research::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structoperations__research_1_1ClosedInterval.html">ClosedInterval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>intervals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abebf3070a940da6bf678953a66584e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebf3070a940da6bf678953a66584e76">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operations_research::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a316abccdfa41512564d84365ea8f0ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316abccdfa41512564d84365ea8f0ead">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operations_research::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Solver.html">Solver</a> *const&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a991f7a823d83b455d6b1a45141cb9ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991f7a823d83b455d6b1a45141cb9ce9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operations_research::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1BaseObject.html">BaseObject</a> *&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f44b10aa7fc7b6e85b72e7f0c96cc1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f44b10aa7fc7b6e85b72e7f0c96cc1f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operations_research::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Assignment.html">Assignment</a> &amp;&#160;</td>
          <td class="paramname"><em>assignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d1fa20f9c9faf7027c0b16f97139e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1fa20f9c9faf7027c0b16f97139e80">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a> operations_research::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08146f196bd9c3f492ee108732449ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08146f196bd9c3f492ee108732449ced">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a> operations_research::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4052f92af6a7fbb1d45e17befcb68e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4052f92af6a7fbb1d45e17befcb68e0">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a> operations_research::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1LinearExpr.html">LinearExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0953b50b08320d1109c678555137f1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0953b50b08320d1109c678555137f1db">&#9670;&nbsp;</a></span>ParameterDebugString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::ParameterDebugString </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00544">544</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a3c2f93547af434566184b7dee7039c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2f93547af434566184b7dee7039c93">&#9670;&nbsp;</a></span>ParameterDebugString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::ParameterDebugString </td>
          <td>(</td>
          <td class="paramtype">P *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Support limited to pointers to classes which define DebugString(). </p>

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l00550">550</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a942ba2898a44303790c91e761b8f4630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942ba2898a44303790c91e761b8f4630">&#9670;&nbsp;</a></span>PosIntDivDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64 operations_research::PosIntDivDown </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02806">2806</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="a60dabfa452b4264887ef76c75edf3765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dabfa452b4264887ef76c75edf3765">&#9670;&nbsp;</a></span>PosIntDivUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64 operations_research::PosIntDivUp </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>--&mdash; Arithmetic operations --&mdash; </p>

<p class="definition">Definition at line <a class="el" href="constraint__solveri_8h_source.html#l02797">2797</a> of file <a class="el" href="constraint__solveri_8h_source.html">constraint_solveri.h</a>.</p>

</div>
</div>
<a id="aea2bf322fab4e2319a23ad22acf8ccf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2bf322fab4e2319a23ad22acf8ccf8">&#9670;&nbsp;</a></span>SetAssignmentFromAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::SetAssignmentFromAssignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Assignment.html">Assignment</a> *&#160;</td>
          <td class="paramname"><em>target_assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Assignment.html">Assignment</a> *&#160;</td>
          <td class="paramname"><em>source_assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1IntVar.html">IntVar</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>source_vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a "source_assignment", clears the "target_assignment" and adds all IntVars in "target_vars", with the values of the variables set according to the corresponding values of "source_vars" in "source_assignment". </p>
<p>source_vars and target_vars must have the same number of elements. The source and target assignments can belong to different Solvers. </p>

</div>
</div>
<a id="ad56bae19a2298c3163af96ca7f8b89b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56bae19a2298c3163af96ca7f8b89b1">&#9670;&nbsp;</a></span>StableDijkstraShortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::StableDijkstraShortestPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64(int, int)&gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>disconnected_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stable version of the Dijsktra Shortest path with callback based description of the graph. </p>
<p>The callback returns the distance between two nodes, a distance of 'disconnected_distance' indicates no arcs between these two nodes. Ownership of the callback is taken by the function that will delete it in the end. This function returns true if 'start_node' and 'end_node' are connected, false otherwise. </p>

</div>
</div>
<a id="aad4e1b406f0e56c83283747b038df88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4e1b406f0e56c83283747b038df88a">&#9670;&nbsp;</a></span>ToInt64Vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int64&gt; operations_research::ToInt64Vector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>--&mdash; Vector of integer manipulations --&mdash; </p>

</div>
</div>
<a id="a009f247167f32509baf749083e4bc984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009f247167f32509baf749083e4bc984">&#9670;&nbsp;</a></span>Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64 operations_research::Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>-------&mdash; Misc -------&mdash; </p>
<p>This method returns 0. It is useful when 0 can be cast either as a pointer or as an integer value and thus lead to an ambiguous function call. </p>

<p class="definition">Definition at line <a class="el" href="constraint__solver_8h_source.html#l03118">3118</a> of file <a class="el" href="constraint__solver_8h_source.html">constraint_solver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a88484804c6e66958d00fb3f1b0821b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88484804c6e66958d00fb3f1b0821b82">&#9670;&nbsp;</a></span>_FirstSolutionStrategy_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FirstSolutionStrategyDefaultTypeInternal operations_research::_FirstSolutionStrategy_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e179c1aa71c3f208d4dfbd8a27bfdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e179c1aa71c3f208d4dfbd8a27bfdc3">&#9670;&nbsp;</a></span>_LocalSearchMetaheuristic_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LocalSearchMetaheuristicDefaultTypeInternal operations_research::_LocalSearchMetaheuristic_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11d06964c51cd718a2a5c620c3289f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d06964c51cd718a2a5c620c3289f7e">&#9670;&nbsp;</a></span>_MPConstraintProto_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPConstraintProtoDefaultTypeInternal operations_research::_MPConstraintProto_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab18f88184af1e6b0197a98cf0485803f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18f88184af1e6b0197a98cf0485803f">&#9670;&nbsp;</a></span>_MPGeneralConstraintProto_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPGeneralConstraintProtoDefaultTypeInternal operations_research::_MPGeneralConstraintProto_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fa4d06ad0beb392a3144747d83fcc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa4d06ad0beb392a3144747d83fcc2c">&#9670;&nbsp;</a></span>_MPIndicatorConstraint_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPIndicatorConstraintDefaultTypeInternal operations_research::_MPIndicatorConstraint_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa214723b84fc52d727efc5067df690e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa214723b84fc52d727efc5067df690e2">&#9670;&nbsp;</a></span>_MPModelProto_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPModelProtoDefaultTypeInternal operations_research::_MPModelProto_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5557bc052354d9b956a609d0698281d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5557bc052354d9b956a609d0698281d5">&#9670;&nbsp;</a></span>_MPModelRequest_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPModelRequestDefaultTypeInternal operations_research::_MPModelRequest_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c99a96a8b2fcf4ab6890a4717c92da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c99a96a8b2fcf4ab6890a4717c92da5">&#9670;&nbsp;</a></span>_MPSolutionResponse_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPSolutionResponseDefaultTypeInternal operations_research::_MPSolutionResponse_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ece0f2b42b6eaf443223377343e1966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ece0f2b42b6eaf443223377343e1966">&#9670;&nbsp;</a></span>_MPSolverCommonParameters_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPSolverCommonParametersDefaultTypeInternal operations_research::_MPSolverCommonParameters_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3dce953fd737d51dcb003b93452b3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3dce953fd737d51dcb003b93452b3b6">&#9670;&nbsp;</a></span>_MPVariableProto_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPVariableProtoDefaultTypeInternal operations_research::_MPVariableProto_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fd6483b24c303a0fbf9ab49846d370c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd6483b24c303a0fbf9ab49846d370c">&#9670;&nbsp;</a></span>_OptionalDouble_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OptionalDoubleDefaultTypeInternal operations_research::_OptionalDouble_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac92dae0b80b47779fc1de1bf9e7df9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92dae0b80b47779fc1de1bf9e7df9dd">&#9670;&nbsp;</a></span>_PartialVariableAssignment_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PartialVariableAssignmentDefaultTypeInternal operations_research::_PartialVariableAssignment_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3a853384e4e580582b670a57018029d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a853384e4e580582b670a57018029d">&#9670;&nbsp;</a></span>_RoutingModelParameters_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RoutingModelParametersDefaultTypeInternal operations_research::_RoutingModelParameters_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a601e1a7c230fbf44503db528b20e30ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601e1a7c230fbf44503db528b20e30ca">&#9670;&nbsp;</a></span>_RoutingSearchParameters_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RoutingSearchParametersDefaultTypeInternal operations_research::_RoutingSearchParameters_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a595bafdd2ca0348c23f2c03da8ef2468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595bafdd2ca0348c23f2c03da8ef2468">&#9670;&nbsp;</a></span>_RoutingSearchParameters_LocalSearchNeighborhoodOperators_default_instance_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RoutingSearchParameters_LocalSearchNeighborhoodOperatorsDefaultTypeInternal operations_research::_RoutingSearchParameters_LocalSearchNeighborhoodOperators_default_instance_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e8e1305d7b00c52172281a44baad6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8e1305d7b00c52172281a44baad6c2">&#9670;&nbsp;</a></span>FirstSolutionStrategy_Value_Value_ARRAYSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int operations_research::FirstSolutionStrategy_Value_Value_ARRAYSIZE = <a class="el" href="namespaceoperations__research.html#a999203a7a00dc983c437624201cdbce2">FirstSolutionStrategy_Value_Value_MAX</a> + 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__enums_8pb_8h_source.html#l00091">91</a> of file <a class="el" href="routing__enums_8pb_8h_source.html">routing_enums.pb.h</a>.</p>

</div>
</div>
<a id="a999203a7a00dc983c437624201cdbce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999203a7a00dc983c437624201cdbce2">&#9670;&nbsp;</a></span>FirstSolutionStrategy_Value_Value_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362c">FirstSolutionStrategy_Value</a> operations_research::FirstSolutionStrategy_Value_Value_MAX = <a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362ca6c8e1e7a2859125316fe07082a2da868">FirstSolutionStrategy_Value_AUTOMATIC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__enums_8pb_8h_source.html#l00090">90</a> of file <a class="el" href="routing__enums_8pb_8h_source.html">routing_enums.pb.h</a>.</p>

</div>
</div>
<a id="a9aec91f2a6b9e10f98ded28a1df2925b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aec91f2a6b9e10f98ded28a1df2925b">&#9670;&nbsp;</a></span>FirstSolutionStrategy_Value_Value_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362c">FirstSolutionStrategy_Value</a> operations_research::FirstSolutionStrategy_Value_Value_MIN = <a class="el" href="namespaceoperations__research.html#ab567c87506c164323ce22036cf4c362cad02e019c28342793688466400afd032d">FirstSolutionStrategy_Value_UNSET</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__enums_8pb_8h_source.html#l00089">89</a> of file <a class="el" href="routing__enums_8pb_8h_source.html">routing_enums.pb.h</a>.</p>

</div>
</div>
<a id="a4fd8517c34ce555a83981c8cc3a00d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd8517c34ce555a83981c8cc3a00d3c">&#9670;&nbsp;</a></span>LocalSearchMetaheuristic_Value_Value_ARRAYSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int operations_research::LocalSearchMetaheuristic_Value_Value_ARRAYSIZE = <a class="el" href="namespaceoperations__research.html#a86aef277165b7aacec371daebe466690">LocalSearchMetaheuristic_Value_Value_MAX</a> + 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__enums_8pb_8h_source.html#l00117">117</a> of file <a class="el" href="routing__enums_8pb_8h_source.html">routing_enums.pb.h</a>.</p>

</div>
</div>
<a id="a86aef277165b7aacec371daebe466690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86aef277165b7aacec371daebe466690">&#9670;&nbsp;</a></span>LocalSearchMetaheuristic_Value_Value_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77">LocalSearchMetaheuristic_Value</a> operations_research::LocalSearchMetaheuristic_Value_Value_MAX = <a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77a883a6e25cd8984a9e4e06636823f7201">LocalSearchMetaheuristic_Value_AUTOMATIC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__enums_8pb_8h_source.html#l00116">116</a> of file <a class="el" href="routing__enums_8pb_8h_source.html">routing_enums.pb.h</a>.</p>

</div>
</div>
<a id="a3713cc7fe59ec4df14e26ac0310cf0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3713cc7fe59ec4df14e26ac0310cf0e5">&#9670;&nbsp;</a></span>LocalSearchMetaheuristic_Value_Value_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77">LocalSearchMetaheuristic_Value</a> operations_research::LocalSearchMetaheuristic_Value_Value_MIN = <a class="el" href="namespaceoperations__research.html#a96ad216f076775131996dbfd897ace77ab1177884bf5c3fda2cac819cca8279ec">LocalSearchMetaheuristic_Value_UNSET</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__enums_8pb_8h_source.html#l00115">115</a> of file <a class="el" href="routing__enums_8pb_8h_source.html">routing_enums.pb.h</a>.</p>

</div>
</div>
<a id="ae6eb74cbdb5037acc1fb265d11616274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6eb74cbdb5037acc1fb265d11616274">&#9670;&nbsp;</a></span>MPModelRequest_SolverType_SolverType_ARRAYSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int operations_research::MPModelRequest_SolverType_SolverType_ARRAYSIZE = <a class="el" href="namespaceoperations__research.html#a955948242965463248545e1785583654">MPModelRequest_SolverType_SolverType_MAX</a> + 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00140">140</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a955948242965463248545e1785583654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955948242965463248545e1785583654">&#9670;&nbsp;</a></span>MPModelRequest_SolverType_SolverType_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5">MPModelRequest_SolverType</a> operations_research::MPModelRequest_SolverType_SolverType_MAX = <a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5ac0fedb2082db5e7c96da01b4149c318e">MPModelRequest_SolverType_SAT_INTEGER_PROGRAMMING</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00139">139</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a33e0cbbffcf3c459144e44b3f00dc2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e0cbbffcf3c459144e44b3f00dc2bf">&#9670;&nbsp;</a></span>MPModelRequest_SolverType_SolverType_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5">MPModelRequest_SolverType</a> operations_research::MPModelRequest_SolverType_SolverType_MIN = <a class="el" href="namespaceoperations__research.html#a66408fd9c4c05711631d208dce3118f5a0969851c637668f95c10ddb1ade866a7">MPModelRequest_SolverType_CLP_LINEAR_PROGRAMMING</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00138">138</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a5dc5431b0bd4640975c7f6502e8013d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc5431b0bd4640975c7f6502e8013d9">&#9670;&nbsp;</a></span>MPSolverCommonParameters_LPAlgorithmValues_LPAlgorithmValues_ARRAYSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int operations_research::MPSolverCommonParameters_LPAlgorithmValues_LPAlgorithmValues_ARRAYSIZE = <a class="el" href="namespaceoperations__research.html#a35686dabc230ba01c79fb8fd0f457e40">MPSolverCommonParameters_LPAlgorithmValues_LPAlgorithmValues_MAX</a> + 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00110">110</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a35686dabc230ba01c79fb8fd0f457e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35686dabc230ba01c79fb8fd0f457e40">&#9670;&nbsp;</a></span>MPSolverCommonParameters_LPAlgorithmValues_LPAlgorithmValues_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85f">MPSolverCommonParameters_LPAlgorithmValues</a> operations_research::MPSolverCommonParameters_LPAlgorithmValues_LPAlgorithmValues_MAX = <a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85fa89ff8ffa01928d5993a1414705eecd15">MPSolverCommonParameters_LPAlgorithmValues_LP_ALGO_BARRIER</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00109">109</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a1e4803399c53b73b9ae985751803d01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4803399c53b73b9ae985751803d01a">&#9670;&nbsp;</a></span>MPSolverCommonParameters_LPAlgorithmValues_LPAlgorithmValues_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85f">MPSolverCommonParameters_LPAlgorithmValues</a> operations_research::MPSolverCommonParameters_LPAlgorithmValues_LPAlgorithmValues_MIN = <a class="el" href="namespaceoperations__research.html#ab042145a1da0eaafbe215ded57dfe85fa2218d316cfcac5a88342c95b188f3fda">MPSolverCommonParameters_LPAlgorithmValues_LP_ALGO_UNSPECIFIED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00108">108</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a04af4e3a977e967ddd2f2db792ac2ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04af4e3a977e967ddd2f2db792ac2ad7">&#9670;&nbsp;</a></span>MPSolverResponseStatus_ARRAYSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int operations_research::MPSolverResponseStatus_ARRAYSIZE = <a class="el" href="namespaceoperations__research.html#a92f022bd33162332383c5f70e4821498">MPSolverResponseStatus_MAX</a> + 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00169">169</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a92f022bd33162332383c5f70e4821498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f022bd33162332383c5f70e4821498">&#9670;&nbsp;</a></span>MPSolverResponseStatus_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56">MPSolverResponseStatus</a> operations_research::MPSolverResponseStatus_MAX = <a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56a84ea2a63b24de389aac6aa33b1203cd4">MPSOLVER_UNKNOWN_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00168">168</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="aaf5325d95fb273624f43bf2741836834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5325d95fb273624f43bf2741836834">&#9670;&nbsp;</a></span>MPSolverResponseStatus_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56">MPSolverResponseStatus</a> operations_research::MPSolverResponseStatus_MIN = <a class="el" href="namespaceoperations__research.html#a51d0df17eb5fb24fcdd0a134178cde56ac95cb5be9e36b31647dd28910ac6cae4">MPSOLVER_OPTIMAL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8pb_8h_source.html#l00167">167</a> of file <a class="el" href="linear__solver_8pb_8h_source.html">linear_solver.pb.h</a>.</p>

</div>
</div>
<a id="a144750b8ec3f03decd898cc08c6b2894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144750b8ec3f03decd898cc08c6b2894">&#9670;&nbsp;</a></span>starts_ends</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::starts_ends</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__index__manager_8h_source.html#l00035">35</a> of file <a class="el" href="routing__index__manager_8h_source.html">routing_index_manager.h</a>.</p>

</div>
</div>
<a id="ad86181cc5dff70e9ce3bfa1f8393cb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86181cc5dff70e9ce3bfa1f8393cb6a">&#9670;&nbsp;</a></span>Then</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* * operations_research::Then</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="routing__index__manager_8h_source.html#l00038">38</a> of file <a class="el" href="routing__index__manager_8h_source.html">routing_index_manager.h</a>.</p>

</div>
</div>
</div><!-- contents -->
        </div>
        <div id="footer-container">
            <div id="footer">
            </div>
        </div>
    </body>
</html>
