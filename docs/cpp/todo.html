<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>OR-Tools</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">OR-Tools 7.1@</span>
            </div>
        </div>
        <div id="content">
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Member <a class="el" href="routing_8h.html#a822458cc9a9a6fa02e86af3e3a1e5c89">CloseVisitTypes</a>  ()</dt>
<dd><a class="anchor" id="_todo000031"></a>(user): Reconsider the logic and potentially remove the need to "close" types.  </dd>
<dt>Member <a class="el" href="routing_8h.html#ae9b2404a26ab1e6acf562b8261eeba38">ComputeLowerBound</a>  ()</dt>
<dd><a class="anchor" id="_todo000032"></a>(user): Add support for non-homogeneous costs and disjunctions.  </dd>
<dt>Member <a class="el" href="strongly__connected__components_8h.html#aafab5785b250e1013c13511ce478f36b">FindStronglyConnectedComponents</a>  (const NodeIndex num_nodes, const Graph &amp;graph, SccOutput *components)</dt>
<dd><a class="anchor" id="_todo000099"></a>(user): Possible optimizations:<ul>
<li>Try to reserve the vectors which sizes are bounded by num_nodes.</li>
<li>Use an index rather than doing push_back(), pop_back() on them.</li>
<li>For a client needing many Scc computations one after another, it could be better to wrap this in a class so we don't need to allocate the stacks at each computation.  </li>
</ul>
</dd>
<dt>Member <a class="el" href="routing_8h.html#a874eb2862dd884ad47e30746e03627f5">GetVisitType</a>  (int64 index) const</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000029"></a>(user): Add a section on costs (vehicle arc costs, span costs, disjunctions costs).</p>
<p class="enddd"><a class="anchor" id="_todo000030"></a>(user): Support multiple visit types per node?  </p>
</dd>
<dt>Member <a class="el" href="routing_8h.html#aa1c45751ee316e0948ba32494262f006">MakeGreedyDescentLSOperator</a>  (std::vector&lt; IntVar * &gt; variables)</dt>
<dd><a class="anchor" id="_todo000035"></a>(user): MakeGreedyDescentLSOperator is too general for <a class="el" href="routing_8h.html">routing.h</a>. </dd>
<dt>Member <a class="el" href="routing_8h.html#a20d0a3f5cec2e425c86f358e5f06b4a8">MakeGuidedSlackFinalizer</a>  (const RoutingDimension *dimension, std::function&lt; int64(int64)&gt; initializer)</dt>
<dd><a class="anchor" id="_todo000034"></a>(user): Find a way to test and restrict the access at the same time. </dd>
<dt>Namespace <a class="el" href="namespaceoperations__research.html">operations_research</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000050"></a>(user): add depth-first-search based connectivity for directed graphs. </p>
<p class="interdd">(user): add depth-first-search based biconnectivity for directed graphs. </p>
<p class="interdd"><a class="anchor" id="_todo000052"></a>(user) although it is already possible, using the GroupForwardArcsByFunctor method, to group all the outgoing (resp. incoming) arcs of a node, the iterator logic could still be improved to allow traversing the outgoing (resp. incoming) arcs in O(out_degree(node)) (resp. O(in_degree(node))) instead of O(degree(node)).</p><ul>
<li></li>
</ul>
<p class="interdd">(user) it is possible to implement arc deletion and garbage collection in an efficient (relatively) manner. For the time being we haven't seen an application for this.</p>
<p class="interdd"><a class="anchor" id="_todo000070"></a>(user): implement pruning procedures on top of the Held-Karp algorithm.</p>
<p class="interdd"><a class="anchor" id="_todo000085"></a>(user): implement the above active node choice rule.</p>
<p class="interdd"><a class="anchor" id="_todo000086"></a>(user): an alternative would be to evaluate: A.V. Goldberg, "The Partial Augment-Relabel Algorithm for the Maximum Flow Problem.‚Äù In Proceedings of Algorithms ESA, LNCS 5193:466-477, Springer 2008. <a href="http://www.springerlink.com/index/5535k2j1mt646338.pdf">http://www.springerlink.com/index/5535k2j1mt646338.pdf</a></p>
<p class="enddd"><a class="anchor" id="_todo000093"></a>(user): See whether the following can bring any improvements on real-life problems. R.K. Ahuja, A.V. Goldberg, J.B. Orlin, and R.E. Tarjan, "Finding minimum-cost
flows by double scaling," Mathematical Programming, (1992) 53:243-266. <a href="http://www.springerlink.com/index/gu7404218u6kt166.pdf">http://www.springerlink.com/index/gu7404218u6kt166.pdf</a> </p>
</dd>
<dt>Member <a class="el" href="classoperations__research_1_1Assignment.html#ae8af25911cdd4091cd6a0ec08c9a38c7">operations_research::Assignment::IntVarContainer</a>  () const</dt>
<dd><a class="anchor" id="_todo000021"></a>(user): Add element iterators to avoid exposing container class.  </dd>
<dt>Member <a class="el" href="namespaceoperations__research.html#a00ab79ee21ffd8dece0996e37f9faa7a">operations_research::BuildKruskalMinimumSpanningTreeFromSortedArcs</a>  (const Graph &amp;graph, const std::vector&lt; typename Graph::ArcIndex &gt; &amp;sorted_arcs)</dt>
<dd><a class="anchor" id="_todo000096"></a>(user): Add a global Minimum Spanning Tree API automatically switching between Prim and Kruskal depending on problem size. </dd>
<dt>Member <a class="el" href="namespaceoperations__research.html#a95da1d3a46432afd40024f79279a48b2">operations_research::BuildSearchParametersFromFlags</a>  ()</dt>
<dd><a class="anchor" id="_todo000043"></a>(user): Make this return a StatusOr, verifying that the flags describe a valid set of routing search parameters.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1ChristofidesPathSolver.html#a76c636e1d48da64087686dd06bc45519">operations_research::ChristofidesPathSolver&lt; CostType, ArcIndex, NodeIndex, CostFunction &gt;::SetMatchingAlgorithm</a>  (MatchingAlgorithm matching)</dt>
<dd><a class="anchor" id="_todo000049"></a>(user): Change the default when minimum matching gets faster.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1ConnectedComponents.html#a257c3606c853fb7b79f62a5b62c65359">operations_research::ConnectedComponents&lt; NodeIndex, ArcIndex &gt;::AddGraph</a>  (const Graph &amp;graph)</dt>
<dd><a class="anchor" id="_todo000051"></a>(user): implement Depth-First Search-based connected components finder.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Domain.html#a153837b45a0e9ddf5620679f243baa96">operations_research::Domain::intervals</a>  () const</dt>
<dd><a class="anchor" id="_todo000107"></a>(user): remove, this makes a copy and is of a different type that our internal InlinedVector() anyway. </dd>
<dt>Member <a class="el" href="classoperations__research_1_1EbertGraphBase.html#a7adcbbf1af098a96abf7a3397246304d">operations_research::EbertGraphBase&lt; NodeIndexType, ArcIndexType, DerivedGraph &gt;::GroupForwardArcsByFunctor</a>  (const ArcIndexTypeStrictWeakOrderingFunctor &amp;compare, PermutationCycleHandler&lt; ArcIndexType &gt; *annotation_handler)</dt>
<dd><a class="anchor" id="_todo000055"></a>(user): Configure SWIG to handle the GroupForwardArcsByFunctor member template and the <a class="el" href="classoperations__research_1_1EbertGraphBase_1_1CycleHandlerForAnnotatedArcs.html">CycleHandlerForAnnotatedArcs</a> class. </dd>
<dt>Class <a class="el" href="classoperations__research_1_1ElementIterator.html">operations_research::ElementIterator&lt; Set &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000071"></a>(user): Move the Set-related classbelow to util/bitset.h Iterates over the elements of a set represented as an unsigned integer, starting from the smallest element. </dd>
<dt>Class <a class="el" href="classoperations__research_1_1ForwardStaticGraph_1_1CycleHandlerForAnnotatedArcs.html">operations_research::ForwardStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::CycleHandlerForAnnotatedArcs</a>  </dt>
<dd><a class="anchor" id="_todo000053"></a>(user): Configure SWIG to handle the <a class="el" href="classoperations__research_1_1ForwardStaticGraph_1_1CycleHandlerForAnnotatedArcs.html">CycleHandlerForAnnotatedArcs</a> class. </dd>
<dt>Member <a class="el" href="classoperations__research_1_1ForwardStaticGraph.html#a299d30373ebbfcb70fc84ecc66d95b92">operations_research::ForwardStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::ForwardStaticGraph</a>  (const NodeIndexType num_nodes, const ArcIndexType num_arcs, const bool sort_arcs_by_head, std::vector&lt; std::pair&lt; NodeIndexType, NodeIndexType &gt; &gt; *client_input_arcs, operations_research::PermutationCycleHandler&lt; ArcIndexType &gt; *const client_cycle_handler)</dt>
<dd><a class="anchor" id="_todo000054"></a>(user): For some reason, SWIG breaks if the <a class="el" href="namespaceoperations__research.html" title="Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in c...">operations_research</a> namespace is not explicit in the following argument declaration.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a92fbc9576b457ceddeb21395181b3273">operations_research::GenericMaxFlow&lt; Graph &gt;::check_result_</a>  </dt>
<dd><a class="anchor" id="_todo000092"></a>(user): Make the check more exhaustive by checking the optimality?  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1GenericMaxFlow.html#ad7892ad5aa8338015f320267fb7f298f">operations_research::GenericMaxFlow&lt; Graph &gt;::GetSinkSideMinCut</a>  (std::vector&lt; NodeIndex &gt; *result)</dt>
<dd><a class="anchor" id="_todo000091"></a>(user): In the two-phases algorithm, we can get this minimum cut without doing the second phase. Add an option for this if there is a need to, note that the second phase is pretty fast so the gain will be small.  </dd>
<dt>Class <a class="el" href="classoperations__research_1_1GenericMinCostFlow.html">operations_research::GenericMinCostFlow&lt; Graph, ArcFlowType, ArcScaledCostType &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000095"></a>(user): Avoid using the globally defined type CostValue and FlowQuantity. Also uses the Arc*Type where there is no risk of overflow in more places.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html#aa5992cec63596c5d6c2ed51fc4f7c9c6">operations_research::HamiltonianPathSolver&lt; CostType, CostFunction &gt;::Integer</a>  </dt>
<dd><a class="anchor" id="_todo000078"></a>(user): remove this limitation by using pruning techniques.  </dd>
<dt>Member <a class="el" href="namespaceoperations__research.html#a64cf3e1336ec61275bdd2ae853d38406">operations_research::Hash1</a>  (uint64 value)</dt>
<dd><a class="anchor" id="_todo000022"></a>(user): use murmurhash. </dd>
<dt>Member <a class="el" href="classoperations__research_1_1IntVarLocalSearchOperator.html#a821c7457813d5411b11e6bbfce63f47a">operations_research::IntVarLocalSearchOperator::MakeOneNeighbor</a>  ()</dt>
<dd><a class="anchor" id="_todo000024"></a>(user): make it pure virtual, implies porting all apps overriding <a class="el" href="classoperations__research_1_1IntVarLocalSearchOperator.html#a5bc78fdde6b4e5a6ad9c3b00a6d47d65" title="Redefines MakeNextNeighbor to export a simpler interface.">MakeNextNeighbor()</a> in a subclass of <a class="el" href="classoperations__research_1_1IntVarLocalSearchOperator.html" title="Specialization of LocalSearchOperator built from an array of IntVars which specifies the scope of the...">IntVarLocalSearchOperator</a>.  </dd>
<dt>Member <a class="el" href="namespaceoperations__research.html#ab1cf773de0cae72d0c44efe5b8f4bb89">operations_research::IsEulerianGraph</a>  (const Graph &amp;graph)</dt>
<dd><a class="anchor" id="_todo000056"></a>(user): Check graph connectivity.  </dd>
<dt>Member <a class="el" href="namespaceoperations__research.html#a6b312dd19c90b2af099e6f159869f7ee">operations_research::IsSemiEulerianGraph</a>  (const Graph &amp;graph, std::vector&lt; NodeIndex &gt; *odd_nodes)</dt>
<dd><a class="anchor" id="_todo000057"></a>(user): Check graph connectivity.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1LatticeMemoryManager.html#a5369cd69622c4264ffcf11a2d5006ecd">operations_research::LatticeMemoryManager&lt; Set, CostType &gt;::BaseOffset</a>  (int card, <a class="el" href="classoperations__research_1_1Set.html">Set</a> s) const</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000077"></a>(user): Investigate how to compute BaseOffset(card - 1, s \ { n }) from BaseOffset(card, n) to speed up the DP iteration. </p>
<p class="enddd"><a class="anchor" id="_todo000072"></a>(user): Evaluate the interest of the above. There are 'card' f(set, j) to store. That is why we need to multiply local_offset by card before adding it to the corresponding base_offset_.  </p>
</dd>
<dt>Member <a class="el" href="classoperations__research_1_1LocalSearchMonitor.html#aa69f2ddc0e76eecc333aa6505f7d6a8e">operations_research::LocalSearchMonitor::LocalSearchMonitor</a>  (<a class="el" href="classoperations__research_1_1Solver.html" title="Solver Class.">Solver</a> *const solver)</dt>
<dd><a class="anchor" id="_todo000028"></a>(user): Add monitoring of local search filters.  </dd>
<dt>Class <a class="el" href="classoperations__research_1_1LocalSearchOperator.html">operations_research::LocalSearchOperator</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000023"></a>(user): rename Start to Synchronize ? </p>
<p class="enddd">(user): decouple the iterating from the defining of a neighbor.  </p>
</dd>
<dt>Class <a class="el" href="classoperations__research_1_1MakePairActiveOperator.html">operations_research::MakePairActiveOperator</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000046"></a>(user): Add option to prune neighbords where the order of node pairs is violated (ie precedence between pickup and delivery nodes). </p>
<p class="interdd">(user): Move this to local_search.cc if it's generic enough. </p>
<p class="enddd">(user): Detect pairs automatically by parsing the constraint model; we could then get rid of the pair API in the RoutingModel class.  </p>
</dd>
<dt>Class <a class="el" href="classoperations__research_1_1MakeRelocateNeighborsOperator.html">operations_research::MakeRelocateNeighborsOperator</a>  </dt>
<dd><a class="anchor" id="_todo000045"></a>(user): Consider merging with standard Relocate in local_search.cc.  </dd>
<dt>Class <a class="el" href="classoperations__research_1_1MaxFlow.html">operations_research::MaxFlow</a>  </dt>
<dd><a class="anchor" id="_todo000088"></a>(user): Modify this code and remove it.  </dd>
<dt>Member <a class="el" href="namespaceoperations__research.html#a891fd91407acbbeb1c47d22be7991b3f">operations_research::NodeToIndex</a>  (node)' whenever 'model' requires a variable *index. */class RoutingIndexManager</dt>
<dd><a class="anchor" id="_todo000044"></a>(user): Remove when removal of NodeIndex from RoutingModel is complete.  </dd>
<dt>Class <a class="el" href="classoperations__research_1_1OptimizeVar.html">operations_research::OptimizeVar</a>  </dt>
<dd><a class="anchor" id="_todo000001"></a>(user): Refactor this into an Objective class:<ul>
<li>print methods for AtNode and AtSolution. </li>
</ul>
</dd>
<dt>Member <a class="el" href="classoperations__research_1_1PathOperator.html#a661ecee1a13c036a57c5c75b97882462">operations_research::PathOperator::OnSamePathAsPreviousBase</a>  (int64 base_index)</dt>
<dd><a class="anchor" id="_todo000027"></a>(user): ideally this should be OnSamePath(int64 node1, int64 node2); it's currently way more complicated to implement.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1PathOperator.html#a6580d6cdf003656019a25f7e9f2d8496">operations_research::PathOperator::RestartAtPathStartOnSynchronize</a>  ()</dt>
<dd><a class="anchor" id="_todo000026"></a>(user): remove this when automatic detection of such cases in done.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1PathOperator.html#a13fc3f3cb8f8de7198d1b16338df06ad">operations_research::PathOperator::SkipUnchanged</a>  (int index) const override</dt>
<dd><a class="anchor" id="_todo000025"></a>(user): Make the following methods protected.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1PruningHamiltonianSolver.html#a2857abdd40d541b03ad21bd053b0ac54">operations_research::PruningHamiltonianSolver&lt; CostType, CostFunction &gt;::Integer</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000080"></a>(user): Use generic map-based cache instead of lattice-based one.</p>
<p class="enddd"><a class="anchor" id="_todo000081"></a>(user): Use SaturatedArithmetic for better precision.  </p>
</dd>
<dt>Member <a class="el" href="classoperations__research_1_1sat_1_1CpModelBuilder.html#a8e1b64644f124be491431bbae9d5d843">operations_research::sat::CpModelBuilder::Build</a>  () const</dt>
<dd><a class="anchor" id="_todo000103"></a>(user) : add MapDomain?  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1sat_1_1Model.html#af4eb422b7cfd963c58d65b18b4e47717">operations_research::sat::Model::GetOrCreate</a>  ()</dt>
<dd><a class="anchor" id="_todo000104"></a>(user): directly store std::unique_ptr&lt;&gt; in singletons_?  </dd>
<dt>Class <a class="el" href="classoperations__research_1_1SimpleMaxFlow.html">operations_research::SimpleMaxFlow</a>  </dt>
<dd><a class="anchor" id="_todo000087"></a>(user): If the need arises, extend this interface to support warm start.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1SimpleMaxFlow.html#a8a7acde49c4d55f2eb42e2b6869cdb3da18a3ff25435f10be68329d4b39de4700">operations_research::SimpleMaxFlow::POSSIBLE_OVERFLOW</a>  </dt>
<dd><a class="anchor" id="_todo000090"></a>(user): rename POSSIBLE_OVERFLOW to INT_OVERFLOW and modify our clients.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1SimpleMaxFlow.html#a57296b653813abdd8d711048e87d1212">operations_research::SimpleMaxFlow::SetArcCapacity</a>  (ArcIndex arc, FlowQuantity capacity)</dt>
<dd><a class="anchor" id="_todo000089"></a>(user): Support incrementality in the max flow implementation.  </dd>
<dt>Class <a class="el" href="classoperations__research_1_1SimpleMinCostFlow.html">operations_research::SimpleMinCostFlow</a>  </dt>
<dd><a class="anchor" id="_todo000094"></a>(user): If the need arises, extend this interface to support warm start and incrementality between solves. Note that this is already supported by the GenericMinCostFlow&lt;&gt; interface.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#a87ca0b6abf9c8724900387f5aa557c04">operations_research::Solver::Action</a>  </dt>
<dd><a class="anchor" id="_todo000003"></a>(user): wrap in swig.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#ad47d47ea8e05e2187fcb81ae1dea508a">operations_research::Solver::DefaultSolverParameters</a>  ()</dt>
<dd><a class="anchor" id="_todo000004"></a>(user): Move to constraint_solver_parameters.h.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#a3d0f049e3e28448b276346341717d945">operations_research::Solver::GetOrCreateLocalSearchState</a>  ()</dt>
<dd><a class="anchor" id="_todo000020"></a>(user): Investigate if this should be moved to Search.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#ae63acd77b8c2ee40387795051298f659">operations_research::Solver::IntValueStrategy</a>  </dt>
<dd><a class="anchor" id="_todo000002"></a>(user): add HIGHEST_MIN and LOWEST_MAX.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#a64fd8adbc00c3bed16bf4b824dfd3e2b">operations_research::Solver::LocalSearchProfile</a>  () const</dt>
<dd><a class="anchor" id="_todo000018"></a>(user): Add a profiling protocol buffer and merge demon and local search profiles.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#a16cf34d9d8c3f46d7d1414b8c0e3b0c8">operations_research::Solver::MakeDelayedPathCumul</a>  (const std::vector&lt; IntVar * &gt; &amp;nexts, const std::vector&lt; IntVar * &gt; &amp;active, const std::vector&lt; IntVar * &gt; &amp;cumuls, const std::vector&lt; IntVar * &gt; &amp;transits)</dt>
<dd><a class="anchor" id="_todo000009"></a>(user): Merge with other path-cumuls constraints.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#a82743e5fcfb142e69798225fc83305ca">operations_research::Solver::MakeLexicalLess</a>  (const std::vector&lt; IntVar * &gt; &amp;left, const std::vector&lt; IntVar * &gt; &amp;right)</dt>
<dd><a class="anchor" id="_todo000007"></a>(user): Add void MakeSortedArray(const std::vector&lt;IntVar*&gt;&amp; vars, std::vector&lt;IntVar*&gt;* const sorted);  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#a6c4750d9d038ef7c4fac71b6f3d12f46">operations_research::Solver::MakeLocalSearchPhase</a>  (<a class="el" href="classoperations__research_1_1Assignment.html" title="--‚Äî Assignment --‚Äî">Assignment</a> *const assignment, LocalSearchPhaseParameters *const parameters)</dt>
<dd><a class="anchor" id="_todo000017"></a>(user): Make a variant which runs a local search after each solution found in a DFS.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#a3a2e8e7abcce51fb754da16c477fca45">operations_research::Solver::MakeNoCycle</a>  (const std::vector&lt; IntVar * &gt; &amp;nexts, const std::vector&lt; IntVar * &gt; &amp;active, IndexFilter1 sink_handler=nullptr)</dt>
<dd><a class="anchor" id="_todo000008"></a>(user): Implement MakeAllNullIntersect taking an array of variable vectors. </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#a538593eed20666ff33b3e5d9a2d86da7">operations_research::Solver::MakeOperator</a>  (const std::vector&lt; IntVar * &gt; &amp;vars, IndexEvaluator3 evaluator, EvaluatorLocalSearchOperators op)</dt>
<dd><a class="anchor" id="_todo000016"></a>(user): Make the callback an IndexEvaluator2 when there are no secondary variables. </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#a65bedad451869cdc814f87ceb68f2a7c">operations_research::Solver::MakePathConnected</a>  (std::vector&lt; IntVar * &gt; nexts, std::vector&lt; int64 &gt; sources, std::vector&lt; int64 &gt; sinks, std::vector&lt; IntVar * &gt; status)</dt>
<dd><a class="anchor" id="_todo000010"></a>(user): Only does checking on WhenBound events on next variables. Check whether more propagation is needed.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#abdda7108c8185b3dcea12523567b96a4">operations_research::Solver::MakePathPrecedenceConstraint</a>  (std::vector&lt; IntVar * &gt; nexts, const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;precedences)</dt>
<dd><a class="anchor" id="_todo000011"></a>(user): This constraint does not make holes in variable domains; the implementation can easily be modified to do that; evaluate the impact on models solved with local search.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#a2f30468d938065d5e3ae986a09b66df4">operations_research::Solver::MakePhase</a>  (const std::vector&lt; IntVar * &gt; &amp;vars, IntVarStrategy var_str, IntValueStrategy val_str)</dt>
<dd><a class="anchor" id="_todo000015"></a>(user): name each of them differently, and document them (and do that for all other functions that have several homonyms in this .h).  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#aaa52f2620322c849e2142fdfc0eb4213">operations_research::Solver::MakePiecewiseLinearExpr</a>  (<a class="el" href="classoperations__research_1_1IntExpr.html" title="The class IntExpr is the base of all integer expressions in constraint programming.">IntExpr</a> *expr, const PiecewiseLinearFunction &amp;f)</dt>
<dd><a class="anchor" id="_todo000005"></a>(user): Investigate if we can merge all three piecewise linear expressions.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#ab46fa9dd348f4228f9b830fcf8ab0ca6">operations_research::Solver::MakeSearchLog</a>  (int branch_period)</dt>
<dd><a class="anchor" id="_todo000013"></a>(user): DEPRECATE API of MakeSearchLog(.., IntVar* var,..).  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#aaba6e77a62dd706b07a0c993f6e0a945">operations_research::Solver::MakeSimulatedAnnealing</a>  (bool maximize, <a class="el" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a> *const v, int64 step, int64 initial_temperature)</dt>
<dd><a class="anchor" id="_todo000012"></a>(user): document behavior  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#af46c19361350e8714e3749c9d70047cf">operations_research::Solver::MakeSortingConstraint</a>  (const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; IntVar * &gt; &amp;sorted)</dt>
<dd><a class="anchor" id="_todo000006"></a>(user): Do we need a version with an array of escape values. </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#afa66a85cec14980401bb16d4f4a84aa1">operations_research::Solver::SetUseFastLocalSearch</a>  (bool use_fast_local_search)</dt>
<dd><a class="anchor" id="_todo000019"></a>(user): Get rid of the following methods once fast local search is enabled for metaheuristics. </dd>
<dt>Member <a class="el" href="classoperations__research_1_1Solver.html#add5cfd638da3fe013e6d86aef1426009">operations_research::Solver::Try</a>  (<a class="el" href="classoperations__research_1_1DecisionBuilder.html" title="A DecisionBuilder is responsible for creating the search tree.">DecisionBuilder</a> *const db1, <a class="el" href="classoperations__research_1_1DecisionBuilder.html" title="A DecisionBuilder is responsible for creating the search tree.">DecisionBuilder</a> *const db2)</dt>
<dd><a class="anchor" id="_todo000014"></a>(user): The search tree can be balanced by using binary "Try"-builders "recursively". For instance, Try(a,b,c,d) will give a tree unbalanced to the right, whereas Try(Try(a,b), Try(b,c)) will give a balanced tree. Investigate if we should only provide the binary version and/or if we should balance automatically.  </dd>
<dt>Class <a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html">operations_research::SortedDisjointIntervalList</a>  </dt>
<dd><a class="anchor" id="_todo000106"></a>(user): Templatize the class on the type of the bounds.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html#a85b8188b348ebff82e5ff38ef49da201">operations_research::SortedDisjointIntervalList::SortedDisjointIntervalList</a>  (const std::vector&lt; int64 &gt; &amp;starts, const std::vector&lt; int64 &gt; &amp;ends)</dt>
<dd><a class="anchor" id="_todo000108"></a>(user): Explain why we favored this API to the more natural input std::vector&lt;ClosedInterval&gt; or std::vector&lt;std::pair&lt;int, int&gt;&gt;.  </dd>
<dt>Member <a class="el" href="routing_8h.html#a700982f228080c6278eb5a2f7f06f31d">SetSweepArranger</a>  (SweepArranger *sweep_arranger)</dt>
<dd><a class="anchor" id="_todo000033"></a>(user): Revisit if coordinates are added to the RoutingModel class.  </dd>
<dt>Member <a class="el" href="classutil_1_1BaseGraph.html#a92ffd852b2ab2e5241f9832e71a2de71">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::arc_capacity</a>  () const</dt>
<dd><a class="anchor" id="_todo000060"></a>(user): Same questions as the ones in <a class="el" href="classutil_1_1BaseGraph.html#a463d57480c9563a7a707c5d0928c9946" title="Capacity reserved for future nodes, always &gt;= num_nodes_.">node_capacity()</a>.  </dd>
<dt>Member <a class="el" href="classutil_1_1BaseGraph.html#aa3bd051d1e141b09dda17aa9b5f24f69">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::FreezeCapacities</a>  ()</dt>
<dd><a class="anchor" id="_todo000061"></a>(user): Only define this in debug mode at the cost of having a lot of ifndef NDEBUG all over the place? remove the function completely ?  </dd>
<dt>Member <a class="el" href="classutil_1_1BaseGraph.html#a07214b96597069d781e27b1dd17ef83e">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::GroupForwardArcsByFunctor</a>  (const A &amp;a, B *b)</dt>
<dd><a class="anchor" id="_todo000063"></a>(user): remove the public functions below. </dd>
<dt>Member <a class="el" href="classutil_1_1BaseGraph.html#a463d57480c9563a7a707c5d0928c9946">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::node_capacity</a>  () const</dt>
<dd><a class="anchor" id="_todo000059"></a>(user): Is it needed? remove completely? return the real capacities at the cost of having a different implementation for each graphs?  </dd>
<dt>Member <a class="el" href="namespaceutil.html#a9470623ca7db3c4a62ce3b326c6b07d8">util::PermuteWithExplicitElementType</a>  (const IntVector &amp;permutation, Array *array_to_permute, ElementType unused)</dt>
<dd><a class="anchor" id="_todo000058"></a>(user): consider slower but more memory efficient implementations that follow the cycles of the permutation and use a bitmap to indicate what has been permuted or to mark the beginning of each cycle.  </dd>
<dt>Member <a class="el" href="namespaceutil.html#a06fa201576c927d92657e090fa86bfdb">util::RemoveCyclesFromPath</a>  (const Graph &amp;graph, std::vector&lt; int &gt; *arc_path)</dt>
<dd><a class="anchor" id="_todo000100"></a>(user): In some cases, there is more than one possible solution. We could take some arc costs and return the cheapest path instead. Or return the shortest path in term of number of arcs.  </dd>
<dt>Member <a class="el" href="classutil_1_1ReverseArcMixedGraph.html#a5ebe11f2abcd78ad1f5606e27d1688bb">util::ReverseArcMixedGraph&lt; NodeIndexType, ArcIndexType &gt;::Head</a>  (ArcIndexType arc) const</dt>
<dd><a class="anchor" id="_todo000065"></a>(user): support <a class="el" href="classutil_1_1ReverseArcMixedGraph.html#a5ebe11f2abcd78ad1f5606e27d1688bb">Head()</a> and <a class="el" href="classutil_1_1ReverseArcMixedGraph.html#a351cbc3c0c79e22f010e697bf65d7100">Tail()</a> before <a class="el" href="classutil_1_1ReverseArcMixedGraph.html#a06e56a529396bbd2595f5c32c2f73142">Build()</a>, like StaticGraph&lt;&gt;.  </dd>
<dt>Member <a class="el" href="classutil_1_1ReverseArcMixedGraph_1_1OutgoingArcIterator.html#ac265893b8e1a6db1380522442bf66c84">util::ReverseArcMixedGraph&lt; NodeIndexType, ArcIndexType &gt;::OutgoingArcIterator::DEFINE_STL_ITERATOR_FUNCTIONS</a>  (<a class="el" href="classutil_1_1ReverseArcMixedGraph_1_1OutgoingArcIterator.html">OutgoingArcIterator</a>)</dt>
<dd><a class="anchor" id="_todo000069"></a>(user): we lose a bit by returning a BeginEndWrapper&lt;&gt; on top of this iterator rather than a simple IntegerRange on the arc indices. </dd>
<dt>Member <a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a590ee70b96ce87433ba89b067495aa5f">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::Build</a>  (std::vector&lt; ArcIndexType &gt; *permutation)</dt>
<dd><a class="anchor" id="_todo000062"></a>(user): the 0 is wasted here, but minor optimisation.  </dd>
<dt>Member <a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a72e8ed03fe3f8ff27d156622a86900aa">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::Head</a>  (ArcIndexType arc) const</dt>
<dd><a class="anchor" id="_todo000064"></a>(user): support <a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a72e8ed03fe3f8ff27d156622a86900aa">Head()</a> and <a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a12cf8d1312236cac409d9a1a934c1ad3">Tail()</a> before <a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a485803d141f9c80beaaae7094548d672">Build()</a>, like StaticGraph&lt;&gt;.  </dd>
<dt>Member <a class="el" href="classutil_1_1ReverseArcStaticGraph_1_1OutgoingArcIterator.html#a4f7501971b3fcc6ab34772a93c449ac6">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::OutgoingArcIterator::DEFINE_STL_ITERATOR_FUNCTIONS</a>  (<a class="el" href="classutil_1_1ReverseArcStaticGraph_1_1OutgoingArcIterator.html">OutgoingArcIterator</a>)</dt>
<dd><a class="anchor" id="_todo000068"></a>(user): we lose a bit by returning a BeginEndWrapper&lt;&gt; on top of this iterator rather than a simple IntegerRange on the arc indices. </dd>
<dt>Member <a class="el" href="classutil_1_1SVector.html#a287f9791ba2e68e137d53fc038bbe432">util::SVector&lt; T &gt;::reserve</a>  (int n)</dt>
<dd><a class="anchor" id="_todo000066"></a>(user): in C++17 we could use std::uninitialized_move instead of this loop. </dd>
</dl>
</div></div><!-- PageDoc -->
</div><!-- contents -->
        </div>
        <div id="footer-container">
            <div id="footer">
            </div>
        </div>
    </body>
</html>
